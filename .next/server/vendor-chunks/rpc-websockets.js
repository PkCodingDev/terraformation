"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/rpc-websockets";
exports.ids = ["vendor-chunks/rpc-websockets"];
exports.modules = {

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/eventemitter3/index.js ***!
  \*************************************************************************/
/***/ ((module) => {

eval("\nvar has = Object.prototype.hasOwnProperty, prefix = \"~\";\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */ function Events() {}\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n    Events.prototype = Object.create(null);\n    //\n    // This hack is needed because the `__proto__` property is still inherited in\n    // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n    //\n    if (!new Events().__proto__) prefix = false;\n}\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */ function EE(fn, context, once) {\n    this.fn = fn;\n    this.context = context;\n    this.once = once || false;\n}\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */ function addListener(emitter, event, fn, context, once) {\n    if (typeof fn !== \"function\") {\n        throw new TypeError(\"The listener must be a function\");\n    }\n    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;\n    if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n    else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n    else emitter._events[evt] = [\n        emitter._events[evt],\n        listener\n    ];\n    return emitter;\n}\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */ function clearEvent(emitter, evt) {\n    if (--emitter._eventsCount === 0) emitter._events = new Events();\n    else delete emitter._events[evt];\n}\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */ function EventEmitter() {\n    this._events = new Events();\n    this._eventsCount = 0;\n}\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */ EventEmitter.prototype.eventNames = function eventNames() {\n    var names = [], events, name;\n    if (this._eventsCount === 0) return names;\n    for(name in events = this._events){\n        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n    }\n    if (Object.getOwnPropertySymbols) {\n        return names.concat(Object.getOwnPropertySymbols(events));\n    }\n    return names;\n};\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */ EventEmitter.prototype.listeners = function listeners(event) {\n    var evt = prefix ? prefix + event : event, handlers = this._events[evt];\n    if (!handlers) return [];\n    if (handlers.fn) return [\n        handlers.fn\n    ];\n    for(var i = 0, l = handlers.length, ee = new Array(l); i < l; i++){\n        ee[i] = handlers[i].fn;\n    }\n    return ee;\n};\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */ EventEmitter.prototype.listenerCount = function listenerCount(event) {\n    var evt = prefix ? prefix + event : event, listeners = this._events[evt];\n    if (!listeners) return 0;\n    if (listeners.fn) return 1;\n    return listeners.length;\n};\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */ EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return false;\n    var listeners = this._events[evt], len = arguments.length, args, i;\n    if (listeners.fn) {\n        if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n        switch(len){\n            case 1:\n                return listeners.fn.call(listeners.context), true;\n            case 2:\n                return listeners.fn.call(listeners.context, a1), true;\n            case 3:\n                return listeners.fn.call(listeners.context, a1, a2), true;\n            case 4:\n                return listeners.fn.call(listeners.context, a1, a2, a3), true;\n            case 5:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n            case 6:\n                return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n        }\n        for(i = 1, args = new Array(len - 1); i < len; i++){\n            args[i - 1] = arguments[i];\n        }\n        listeners.fn.apply(listeners.context, args);\n    } else {\n        var length = listeners.length, j;\n        for(i = 0; i < length; i++){\n            if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n            switch(len){\n                case 1:\n                    listeners[i].fn.call(listeners[i].context);\n                    break;\n                case 2:\n                    listeners[i].fn.call(listeners[i].context, a1);\n                    break;\n                case 3:\n                    listeners[i].fn.call(listeners[i].context, a1, a2);\n                    break;\n                case 4:\n                    listeners[i].fn.call(listeners[i].context, a1, a2, a3);\n                    break;\n                default:\n                    if (!args) for(j = 1, args = new Array(len - 1); j < len; j++){\n                        args[j - 1] = arguments[j];\n                    }\n                    listeners[i].fn.apply(listeners[i].context, args);\n            }\n        }\n    }\n    return true;\n};\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.on = function on(event, fn, context) {\n    return addListener(this, event, fn, context, false);\n};\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.once = function once(event, fn, context) {\n    return addListener(this, event, fn, context, true);\n};\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n    var evt = prefix ? prefix + event : event;\n    if (!this._events[evt]) return this;\n    if (!fn) {\n        clearEvent(this, evt);\n        return this;\n    }\n    var listeners = this._events[evt];\n    if (listeners.fn) {\n        if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {\n            clearEvent(this, evt);\n        }\n    } else {\n        for(var i = 0, events = [], length = listeners.length; i < length; i++){\n            if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {\n                events.push(listeners[i]);\n            }\n        }\n        //\n        // Reset the array, or remove it completely if we have no more listeners.\n        //\n        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n        else clearEvent(this, evt);\n    }\n    return this;\n};\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */ EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n    var evt;\n    if (event) {\n        evt = prefix ? prefix + event : event;\n        if (this._events[evt]) clearEvent(this, evt);\n    } else {\n        this._events = new Events();\n        this._eventsCount = 0;\n    }\n    return this;\n};\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n//\n// Expose the module.\n//\nif (true) {\n    module.exports = EventEmitter;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxNQUFNQyxPQUFPQyxTQUFTLENBQUNDLGNBQWMsRUFDckNDLFNBQVM7QUFFYjs7Ozs7O0NBTUMsR0FDRCxTQUFTQyxVQUFVO0FBRW5CLEVBQUU7QUFDRiw2RUFBNkU7QUFDN0UsOEVBQThFO0FBQzlFLDZFQUE2RTtBQUM3RSxxRUFBcUU7QUFDckUsMENBQTBDO0FBQzFDLEVBQUU7QUFDRixJQUFJSixPQUFPSyxNQUFNLEVBQUU7SUFDakJELE9BQU9ILFNBQVMsR0FBR0QsT0FBT0ssTUFBTSxDQUFDO0lBRWpDLEVBQUU7SUFDRiw2RUFBNkU7SUFDN0UsdUVBQXVFO0lBQ3ZFLEVBQUU7SUFDRixJQUFJLENBQUMsSUFBSUQsU0FBU0UsU0FBUyxFQUFFSCxTQUFTO0FBQ3hDO0FBRUE7Ozs7Ozs7O0NBUUMsR0FDRCxTQUFTSSxHQUFHQyxFQUFFLEVBQUVDLE9BQU8sRUFBRUMsSUFBSTtJQUMzQixJQUFJLENBQUNGLEVBQUUsR0FBR0E7SUFDVixJQUFJLENBQUNDLE9BQU8sR0FBR0E7SUFDZixJQUFJLENBQUNDLElBQUksR0FBR0EsUUFBUTtBQUN0QjtBQUVBOzs7Ozs7Ozs7O0NBVUMsR0FDRCxTQUFTQyxZQUFZQyxPQUFPLEVBQUVDLEtBQUssRUFBRUwsRUFBRSxFQUFFQyxPQUFPLEVBQUVDLElBQUk7SUFDcEQsSUFBSSxPQUFPRixPQUFPLFlBQVk7UUFDNUIsTUFBTSxJQUFJTSxVQUFVO0lBQ3RCO0lBRUEsSUFBSUMsV0FBVyxJQUFJUixHQUFHQyxJQUFJQyxXQUFXRyxTQUFTRixPQUMxQ00sTUFBTWIsU0FBU0EsU0FBU1UsUUFBUUE7SUFFcEMsSUFBSSxDQUFDRCxRQUFRSyxPQUFPLENBQUNELElBQUksRUFBRUosUUFBUUssT0FBTyxDQUFDRCxJQUFJLEdBQUdELFVBQVVILFFBQVFNLFlB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YXRpb24vLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXguanM/NWNjNCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5XG4gICwgcHJlZml4ID0gJ34nO1xuXG4vKipcbiAqIENvbnN0cnVjdG9yIHRvIGNyZWF0ZSBhIHN0b3JhZ2UgZm9yIG91ciBgRUVgIG9iamVjdHMuXG4gKiBBbiBgRXZlbnRzYCBpbnN0YW5jZSBpcyBhIHBsYWluIG9iamVjdCB3aG9zZSBwcm9wZXJ0aWVzIGFyZSBldmVudCBuYW1lcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIEV2ZW50cygpIHt9XG5cbi8vXG4vLyBXZSB0cnkgdG8gbm90IGluaGVyaXQgZnJvbSBgT2JqZWN0LnByb3RvdHlwZWAuIEluIHNvbWUgZW5naW5lcyBjcmVhdGluZyBhblxuLy8gaW5zdGFuY2UgaW4gdGhpcyB3YXkgaXMgZmFzdGVyIHRoYW4gY2FsbGluZyBgT2JqZWN0LmNyZWF0ZShudWxsKWAgZGlyZWN0bHkuXG4vLyBJZiBgT2JqZWN0LmNyZWF0ZShudWxsKWAgaXMgbm90IHN1cHBvcnRlZCB3ZSBwcmVmaXggdGhlIGV2ZW50IG5hbWVzIHdpdGggYVxuLy8gY2hhcmFjdGVyIHRvIG1ha2Ugc3VyZSB0aGF0IHRoZSBidWlsdC1pbiBvYmplY3QgcHJvcGVydGllcyBhcmUgbm90XG4vLyBvdmVycmlkZGVuIG9yIHVzZWQgYXMgYW4gYXR0YWNrIHZlY3Rvci5cbi8vXG5pZiAoT2JqZWN0LmNyZWF0ZSkge1xuICBFdmVudHMucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblxuICAvL1xuICAvLyBUaGlzIGhhY2sgaXMgbmVlZGVkIGJlY2F1c2UgdGhlIGBfX3Byb3RvX19gIHByb3BlcnR5IGlzIHN0aWxsIGluaGVyaXRlZCBpblxuICAvLyBzb21lIG9sZCBicm93c2VycyBsaWtlIEFuZHJvaWQgNCwgaVBob25lIDUuMSwgT3BlcmEgMTEgYW5kIFNhZmFyaSA1LlxuICAvL1xuICBpZiAoIW5ldyBFdmVudHMoKS5fX3Byb3RvX18pIHByZWZpeCA9IGZhbHNlO1xufVxuXG4vKipcbiAqIFJlcHJlc2VudGF0aW9uIG9mIGEgc2luZ2xlIGV2ZW50IGxpc3RlbmVyLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IFtvbmNlPWZhbHNlXSBTcGVjaWZ5IGlmIHRoZSBsaXN0ZW5lciBpcyBhIG9uZS10aW1lIGxpc3RlbmVyLlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBFRShmbiwgY29udGV4dCwgb25jZSkge1xuICB0aGlzLmZuID0gZm47XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMub25jZSA9IG9uY2UgfHwgZmFsc2U7XG59XG5cbi8qKlxuICogQWRkIGEgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IGVtaXR0ZXIgUmVmZXJlbmNlIHRvIHRoZSBgRXZlbnRFbWl0dGVyYCBpbnN0YW5jZS5cbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gY29udGV4dCBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcGFyYW0ge0Jvb2xlYW59IG9uY2UgU3BlY2lmeSBpZiB0aGUgbGlzdGVuZXIgaXMgYSBvbmUtdGltZSBsaXN0ZW5lci5cbiAqIEByZXR1cm5zIHtFdmVudEVtaXR0ZXJ9XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhZGRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcbiAgfVxuXG4gIHZhciBsaXN0ZW5lciA9IG5ldyBFRShmbiwgY29udGV4dCB8fCBlbWl0dGVyLCBvbmNlKVxuICAgICwgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudDtcblxuICBpZiAoIWVtaXR0ZXIuX2V2ZW50c1tldnRdKSBlbWl0dGVyLl9ldmVudHNbZXZ0XSA9IGxpc3RlbmVyLCBlbWl0dGVyLl9ldmVudHNDb3VudCsrO1xuICBlbHNlIGlmICghZW1pdHRlci5fZXZlbnRzW2V2dF0uZm4pIGVtaXR0ZXIuX2V2ZW50c1tldnRdLnB1c2gobGlzdGVuZXIpO1xuICBlbHNlIGVtaXR0ZXIuX2V2ZW50c1tldnRdID0gW2VtaXR0ZXIuX2V2ZW50c1tldnRdLCBsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIGVtaXR0ZXI7XG59XG5cbi8qKlxuICogQ2xlYXIgZXZlbnQgYnkgbmFtZS5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gZW1pdHRlciBSZWZlcmVuY2UgdG8gdGhlIGBFdmVudEVtaXR0ZXJgIGluc3RhbmNlLlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2dCBUaGUgRXZlbnQgbmFtZS5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGNsZWFyRXZlbnQoZW1pdHRlciwgZXZ0KSB7XG4gIGlmICgtLWVtaXR0ZXIuX2V2ZW50c0NvdW50ID09PSAwKSBlbWl0dGVyLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIGVsc2UgZGVsZXRlIGVtaXR0ZXIuX2V2ZW50c1tldnRdO1xufVxuXG4vKipcbiAqIE1pbmltYWwgYEV2ZW50RW1pdHRlcmAgaW50ZXJmYWNlIHRoYXQgaXMgbW9sZGVkIGFnYWluc3QgdGhlIE5vZGUuanNcbiAqIGBFdmVudEVtaXR0ZXJgIGludGVyZmFjZS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRzKCk7XG4gIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbn1cblxuLyoqXG4gKiBSZXR1cm4gYW4gYXJyYXkgbGlzdGluZyB0aGUgZXZlbnRzIGZvciB3aGljaCB0aGUgZW1pdHRlciBoYXMgcmVnaXN0ZXJlZFxuICogbGlzdGVuZXJzLlxuICpcbiAqIEByZXR1cm5zIHtBcnJheX1cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5ldmVudE5hbWVzID0gZnVuY3Rpb24gZXZlbnROYW1lcygpIHtcbiAgdmFyIG5hbWVzID0gW11cbiAgICAsIGV2ZW50c1xuICAgICwgbmFtZTtcblxuICBpZiAodGhpcy5fZXZlbnRzQ291bnQgPT09IDApIHJldHVybiBuYW1lcztcblxuICBmb3IgKG5hbWUgaW4gKGV2ZW50cyA9IHRoaXMuX2V2ZW50cykpIHtcbiAgICBpZiAoaGFzLmNhbGwoZXZlbnRzLCBuYW1lKSkgbmFtZXMucHVzaChwcmVmaXggPyBuYW1lLnNsaWNlKDEpIDogbmFtZSk7XG4gIH1cblxuICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgIHJldHVybiBuYW1lcy5jb25jYXQoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhldmVudHMpKTtcbiAgfVxuXG4gIHJldHVybiBuYW1lcztcbn07XG5cbi8qKlxuICogUmV0dXJuIHRoZSBsaXN0ZW5lcnMgcmVnaXN0ZXJlZCBmb3IgYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7QXJyYXl9IFRoZSByZWdpc3RlcmVkIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoZXZlbnQpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnRcbiAgICAsIGhhbmRsZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFoYW5kbGVycykgcmV0dXJuIFtdO1xuICBpZiAoaGFuZGxlcnMuZm4pIHJldHVybiBbaGFuZGxlcnMuZm5dO1xuXG4gIGZvciAodmFyIGkgPSAwLCBsID0gaGFuZGxlcnMubGVuZ3RoLCBlZSA9IG5ldyBBcnJheShsKTsgaSA8IGw7IGkrKykge1xuICAgIGVlW2ldID0gaGFuZGxlcnNbaV0uZm47XG4gIH1cblxuICByZXR1cm4gZWU7XG59O1xuXG4vKipcbiAqIFJldHVybiB0aGUgbnVtYmVyIG9mIGxpc3RlbmVycyBsaXN0ZW5pbmcgdG8gYSBnaXZlbiBldmVudC5cbiAqXG4gKiBAcGFyYW0geyhTdHJpbmd8U3ltYm9sKX0gZXZlbnQgVGhlIGV2ZW50IG5hbWUuXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtYmVyIG9mIGxpc3RlbmVycy5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24gbGlzdGVuZXJDb3VudChldmVudCkge1xuICB2YXIgZXZ0ID0gcHJlZml4ID8gcHJlZml4ICsgZXZlbnQgOiBldmVudFxuICAgICwgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKCFsaXN0ZW5lcnMpIHJldHVybiAwO1xuICBpZiAobGlzdGVuZXJzLmZuKSByZXR1cm4gMTtcbiAgcmV0dXJuIGxpc3RlbmVycy5sZW5ndGg7XG59O1xuXG4vKipcbiAqIENhbGxzIGVhY2ggb2YgdGhlIGxpc3RlbmVycyByZWdpc3RlcmVkIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIGV2ZW50IGhhZCBsaXN0ZW5lcnMsIGVsc2UgYGZhbHNlYC5cbiAqIEBwdWJsaWNcbiAqL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24gZW1pdChldmVudCwgYTEsIGEyLCBhMywgYTQsIGE1KSB7XG4gIHZhciBldnQgPSBwcmVmaXggPyBwcmVmaXggKyBldmVudCA6IGV2ZW50O1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW2V2dF0pIHJldHVybiBmYWxzZTtcblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF1cbiAgICAsIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGhcbiAgICAsIGFyZ3NcbiAgICAsIGk7XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChsaXN0ZW5lcnMub25jZSkgdGhpcy5yZW1vdmVMaXN0ZW5lcihldmVudCwgbGlzdGVuZXJzLmZuLCB1bmRlZmluZWQsIHRydWUpO1xuXG4gICAgc3dpdGNoIChsZW4pIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0KSwgdHJ1ZTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSksIHRydWU7XG4gICAgICBjYXNlIDM6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNDogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzKSwgdHJ1ZTtcbiAgICAgIGNhc2UgNTogcmV0dXJuIGxpc3RlbmVycy5mbi5jYWxsKGxpc3RlbmVycy5jb250ZXh0LCBhMSwgYTIsIGEzLCBhNCksIHRydWU7XG4gICAgICBjYXNlIDY6IHJldHVybiBsaXN0ZW5lcnMuZm4uY2FsbChsaXN0ZW5lcnMuY29udGV4dCwgYTEsIGEyLCBhMywgYTQsIGE1KSwgdHJ1ZTtcbiAgICB9XG5cbiAgICBmb3IgKGkgPSAxLCBhcmdzID0gbmV3IEFycmF5KGxlbiAtMSk7IGkgPCBsZW47IGkrKykge1xuICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuXG4gICAgbGlzdGVuZXJzLmZuLmFwcGx5KGxpc3RlbmVycy5jb250ZXh0LCBhcmdzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgbGVuZ3RoID0gbGlzdGVuZXJzLmxlbmd0aFxuICAgICAgLCBqO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAobGlzdGVuZXJzW2ldLm9uY2UpIHRoaXMucmVtb3ZlTGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyc1tpXS5mbiwgdW5kZWZpbmVkLCB0cnVlKTtcblxuICAgICAgc3dpdGNoIChsZW4pIHtcbiAgICAgICAgY2FzZSAxOiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCk7IGJyZWFrO1xuICAgICAgICBjYXNlIDI6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSk7IGJyZWFrO1xuICAgICAgICBjYXNlIDM6IGxpc3RlbmVyc1tpXS5mbi5jYWxsKGxpc3RlbmVyc1tpXS5jb250ZXh0LCBhMSwgYTIpOyBicmVhaztcbiAgICAgICAgY2FzZSA0OiBsaXN0ZW5lcnNbaV0uZm4uY2FsbChsaXN0ZW5lcnNbaV0uY29udGV4dCwgYTEsIGEyLCBhMyk7IGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGlmICghYXJncykgZm9yIChqID0gMSwgYXJncyA9IG5ldyBBcnJheShsZW4gLTEpOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaiAtIDFdID0gYXJndW1lbnRzW2pdO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGxpc3RlbmVyc1tpXS5mbi5hcHBseShsaXN0ZW5lcnNbaV0uY29udGV4dCwgYXJncyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG4vKipcbiAqIEFkZCBhIGxpc3RlbmVyIGZvciBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqIEBwYXJhbSB7Kn0gW2NvbnRleHQ9dGhpc10gVGhlIGNvbnRleHQgdG8gaW52b2tlIHRoZSBsaXN0ZW5lciB3aXRoLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gb24oZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIGZhbHNlKTtcbn07XG5cbi8qKlxuICogQWRkIGEgb25lLXRpbWUgbGlzdGVuZXIgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gKlxuICogQHBhcmFtIHsoU3RyaW5nfFN5bWJvbCl9IGV2ZW50IFRoZSBldmVudCBuYW1lLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBbY29udGV4dD10aGlzXSBUaGUgY29udGV4dCB0byBpbnZva2UgdGhlIGxpc3RlbmVyIHdpdGguXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uIG9uY2UoZXZlbnQsIGZuLCBjb250ZXh0KSB7XG4gIHJldHVybiBhZGRMaXN0ZW5lcih0aGlzLCBldmVudCwgZm4sIGNvbnRleHQsIHRydWUpO1xufTtcblxuLyoqXG4gKiBSZW1vdmUgdGhlIGxpc3RlbmVycyBvZiBhIGdpdmVuIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBldmVudCBUaGUgZXZlbnQgbmFtZS5cbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCB0aGlzIGZ1bmN0aW9uLlxuICogQHBhcmFtIHsqfSBjb250ZXh0IE9ubHkgcmVtb3ZlIHRoZSBsaXN0ZW5lcnMgdGhhdCBoYXZlIHRoaXMgY29udGV4dC5cbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb25jZSBPbmx5IHJlbW92ZSBvbmUtdGltZSBsaXN0ZW5lcnMuXG4gKiBAcmV0dXJucyB7RXZlbnRFbWl0dGVyfSBgdGhpc2AuXG4gKiBAcHVibGljXG4gKi9cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlTGlzdGVuZXIgPSBmdW5jdGlvbiByZW1vdmVMaXN0ZW5lcihldmVudCwgZm4sIGNvbnRleHQsIG9uY2UpIHtcbiAgdmFyIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbZXZ0XSkgcmV0dXJuIHRoaXM7XG4gIGlmICghZm4pIHtcbiAgICBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICB2YXIgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW2V2dF07XG5cbiAgaWYgKGxpc3RlbmVycy5mbikge1xuICAgIGlmIChcbiAgICAgIGxpc3RlbmVycy5mbiA9PT0gZm4gJiZcbiAgICAgICghb25jZSB8fCBsaXN0ZW5lcnMub25jZSkgJiZcbiAgICAgICghY29udGV4dCB8fCBsaXN0ZW5lcnMuY29udGV4dCA9PT0gY29udGV4dClcbiAgICApIHtcbiAgICAgIGNsZWFyRXZlbnQodGhpcywgZXZ0KTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGV2ZW50cyA9IFtdLCBsZW5ndGggPSBsaXN0ZW5lcnMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChcbiAgICAgICAgbGlzdGVuZXJzW2ldLmZuICE9PSBmbiB8fFxuICAgICAgICAob25jZSAmJiAhbGlzdGVuZXJzW2ldLm9uY2UpIHx8XG4gICAgICAgIChjb250ZXh0ICYmIGxpc3RlbmVyc1tpXS5jb250ZXh0ICE9PSBjb250ZXh0KVxuICAgICAgKSB7XG4gICAgICAgIGV2ZW50cy5wdXNoKGxpc3RlbmVyc1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy9cbiAgICAvLyBSZXNldCB0aGUgYXJyYXksIG9yIHJlbW92ZSBpdCBjb21wbGV0ZWx5IGlmIHdlIGhhdmUgbm8gbW9yZSBsaXN0ZW5lcnMuXG4gICAgLy9cbiAgICBpZiAoZXZlbnRzLmxlbmd0aCkgdGhpcy5fZXZlbnRzW2V2dF0gPSBldmVudHMubGVuZ3RoID09PSAxID8gZXZlbnRzWzBdIDogZXZlbnRzO1xuICAgIGVsc2UgY2xlYXJFdmVudCh0aGlzLCBldnQpO1xuICB9XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vKipcbiAqIFJlbW92ZSBhbGwgbGlzdGVuZXJzLCBvciB0aG9zZSBvZiB0aGUgc3BlY2lmaWVkIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFN0cmluZ3xTeW1ib2wpfSBbZXZlbnRdIFRoZSBldmVudCBuYW1lLlxuICogQHJldHVybnMge0V2ZW50RW1pdHRlcn0gYHRoaXNgLlxuICogQHB1YmxpY1xuICovXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUFsbExpc3RlbmVycyA9IGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyhldmVudCkge1xuICB2YXIgZXZ0O1xuXG4gIGlmIChldmVudCkge1xuICAgIGV2dCA9IHByZWZpeCA/IHByZWZpeCArIGV2ZW50IDogZXZlbnQ7XG4gICAgaWYgKHRoaXMuX2V2ZW50c1tldnRdKSBjbGVhckV2ZW50KHRoaXMsIGV2dCk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fZXZlbnRzID0gbmV3IEV2ZW50cygpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuLy9cbi8vIEFsaWFzIG1ldGhvZHMgbmFtZXMgYmVjYXVzZSBwZW9wbGUgcm9sbCBsaWtlIHRoYXQuXG4vL1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vZmYgPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyO1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUub247XG5cbi8vXG4vLyBFeHBvc2UgdGhlIHByZWZpeC5cbi8vXG5FdmVudEVtaXR0ZXIucHJlZml4ZWQgPSBwcmVmaXg7XG5cbi8vXG4vLyBBbGxvdyBgRXZlbnRFbWl0dGVyYCB0byBiZSBpbXBvcnRlZCBhcyBtb2R1bGUgbmFtZXNwYWNlLlxuLy9cbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbi8vXG4vLyBFeHBvc2UgdGhlIG1vZHVsZS5cbi8vXG5pZiAoJ3VuZGVmaW5lZCcgIT09IHR5cGVvZiBtb2R1bGUpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBFdmVudEVtaXR0ZXI7XG59XG4iXSwibmFtZXMiOlsiaGFzIiwiT2JqZWN0IiwicHJvdG90eXBlIiwiaGFzT3duUHJvcGVydHkiLCJwcmVmaXgiLCJFdmVudHMiLCJjcmVhdGUiLCJfX3Byb3RvX18iLCJFRSIsImZuIiwiY29udGV4dCIsIm9uY2UiLCJhZGRMaXN0ZW5lciIsImVtaXR0ZXIiLCJldmVudCIsIlR5cGVFcnJvciIsImxpc3RlbmVyIiwiZXZ0IiwiX2V2ZW50cyIsIl9ldmVudHNDb3VudCIsInB1c2giLCJjbGVhckV2ZW50IiwiRXZlbnRFbWl0dGVyIiwiZXZlbnROYW1lcyIsIm5hbWVzIiwiZXZlbnRzIiwibmFtZSIsImNhbGwiLCJzbGljZSIsImdldE93blByb3BlcnR5U3ltYm9scyIsImNvbmNhdCIsImxpc3RlbmVycyIsImhhbmRsZXJzIiwiaSIsImwiLCJsZW5ndGgiLCJlZSIsIkFycmF5IiwibGlzdGVuZXJDb3VudCIsImVtaXQiLCJhMSIsImEyIiwiYTMiLCJhNCIsImE1IiwibGVuIiwiYXJndW1lbnRzIiwiYXJncyIsInJlbW92ZUxpc3RlbmVyIiwidW5kZWZpbmVkIiwiYXBwbHkiLCJqIiwib24iLCJyZW1vdmVBbGxMaXN0ZW5lcnMiLCJvZmYiLCJwcmVmaXhlZCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js":
/*!************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { EMPTY_BUFFER } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\n/**\n * Merges an array of buffers into a new buffer.\n *\n * @param {Buffer[]} list The array of buffers to concat\n * @param {Number} totalLength The total length of buffers in the list\n * @return {Buffer} The resulting buffer\n * @public\n */ function concat(list, totalLength) {\n    if (list.length === 0) return EMPTY_BUFFER;\n    if (list.length === 1) return list[0];\n    const target = Buffer.allocUnsafe(totalLength);\n    let offset = 0;\n    for(let i = 0; i < list.length; i++){\n        const buf = list[i];\n        target.set(buf, offset);\n        offset += buf.length;\n    }\n    if (offset < totalLength) {\n        return new FastBuffer(target.buffer, target.byteOffset, offset);\n    }\n    return target;\n}\n/**\n * Masks a buffer using the given mask.\n *\n * @param {Buffer} source The buffer to mask\n * @param {Buffer} mask The mask to use\n * @param {Buffer} output The buffer where to store the result\n * @param {Number} offset The offset at which to start writing\n * @param {Number} length The number of bytes to mask.\n * @public\n */ function _mask(source, mask, output, offset, length) {\n    for(let i = 0; i < length; i++){\n        output[offset + i] = source[i] ^ mask[i & 3];\n    }\n}\n/**\n * Unmasks a buffer using the given mask.\n *\n * @param {Buffer} buffer The buffer to unmask\n * @param {Buffer} mask The mask to use\n * @public\n */ function _unmask(buffer, mask) {\n    for(let i = 0; i < buffer.length; i++){\n        buffer[i] ^= mask[i & 3];\n    }\n}\n/**\n * Converts a buffer to an `ArrayBuffer`.\n *\n * @param {Buffer} buf The buffer to convert\n * @return {ArrayBuffer} Converted buffer\n * @public\n */ function toArrayBuffer(buf) {\n    if (buf.length === buf.buffer.byteLength) {\n        return buf.buffer;\n    }\n    return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);\n}\n/**\n * Converts `data` to a `Buffer`.\n *\n * @param {*} data The data to convert\n * @return {Buffer} The buffer\n * @throws {TypeError}\n * @public\n */ function toBuffer(data) {\n    toBuffer.readOnly = true;\n    if (Buffer.isBuffer(data)) return data;\n    let buf;\n    if (data instanceof ArrayBuffer) {\n        buf = new FastBuffer(data);\n    } else if (ArrayBuffer.isView(data)) {\n        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);\n    } else {\n        buf = Buffer.from(data);\n        toBuffer.readOnly = false;\n    }\n    return buf;\n}\nmodule.exports = {\n    concat,\n    mask: _mask,\n    toArrayBuffer,\n    toBuffer,\n    unmask: _unmask\n};\n/* istanbul ignore else  */ if (!process.env.WS_NO_BUFFER_UTIL) {\n    try {\n        const bufferUtil = __webpack_require__(/*! bufferutil */ \"?010f\");\n        module.exports.mask = function(source, mask, output, offset, length) {\n            if (length < 48) _mask(source, mask, output, offset, length);\n            else bufferUtil.mask(source, mask, output, offset, length);\n        };\n        module.exports.unmask = function(buffer, mask) {\n            if (buffer.length < 32) _unmask(buffer, mask);\n            else bufferUtil.unmask(buffer, mask);\n        };\n    } catch (e) {\n    // Continue regardless of the error.\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9idWZmZXItdXRpbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsWUFBWSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRWpDLE1BQU1DLGFBQWFDLE1BQU0sQ0FBQ0MsT0FBT0MsT0FBTyxDQUFDO0FBRXpDOzs7Ozs7O0NBT0MsR0FDRCxTQUFTQyxPQUFPQyxJQUFJLEVBQUVDLFdBQVc7SUFDL0IsSUFBSUQsS0FBS0UsTUFBTSxLQUFLLEdBQUcsT0FBT1Q7SUFDOUIsSUFBSU8sS0FBS0UsTUFBTSxLQUFLLEdBQUcsT0FBT0YsSUFBSSxDQUFDLEVBQUU7SUFFckMsTUFBTUcsU0FBU1AsT0FBT1EsV0FBVyxDQUFDSDtJQUNsQyxJQUFJSSxTQUFTO0lBRWIsSUFBSyxJQUFJQyxJQUFJLEdBQUdBLElBQUlOLEtBQUtFLE1BQU0sRUFBRUksSUFBSztRQUNwQyxNQUFNQyxNQUFNUCxJQUFJLENBQUNNLEVBQUU7UUFDbkJILE9BQU9LLEdBQUcsQ0FBQ0QsS0FBS0Y7UUFDaEJBLFVBQVVFLElBQUlMLE1BQU07SUFDdEI7SUFFQSxJQUFJRyxTQUFTSixhQUFhO1FBQ3hCLE9BQU8sSUFBSU4sV0FBV1EsT0FBT00sTUFBTSxFQUFFTixPQUFPTyxVQUFVLEVBQUVMO0lBQzFEO0lBRUEsT0FBT0Y7QUFDVDtBQUVBOzs7Ozs7Ozs7Q0FTQyxHQUNELFNBQVNRLE1BQU1DLE1BQU0sRUFBRUMsSUFBSSxFQUFFQyxNQUFNLEVBQUVULE1BQU0sRUFBRUgsTUFBTTtJQUNqRCxJQUFLLElBQUlJLElBQUksR0FBR0EsSUFBSUosUUFBUUksSUFBSztRQUMvQlEsTUFBTSxDQUFDVCxTQUFTQyxFQUFFLEdBQUdNLE1BQU0sQ0FBQ04sRUFBRSxHQUFHTyxJQUFJLENBQUNQLElBQUksRUFBRTtJQUM5QztBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1MsUUFBUU4sTUFBTSxFQUFFSSxJQUFJO0lBQzNCLElBQUssSUFBSVAsSUFBSSxHQUFHQSxJQUFJRyxPQUFPUCxNQUFNLEVBQUVJLElBQUs7UUFDdENHLE1BQU0sQ0FBQ0gsRUFBRSxJQUFJTyxJQUFJLENBQUNQLElBQUksRUFBRTtJQUMxQjtBQUNGO0FBRUE7Ozs7OztDQU1DLEdBQ0QsU0FBU1UsY0FBY1QsR0FBRztJQUN4QixJQUFJQSxJQUFJTCxNQUFNLEtBQUtLLElBQUlFLE1BQU0sQ0FBQ1EsVUFBVSxFQUFFO1FBQ3hDLE9BQU9WLElBQUlFLE1BQU07SUFDbkI7SUFFQSxPQUFPRixJQUFJRSxNQUFNLENBQUNTLEtBQUssQ0FBQ1gsSUFBSUcsVUFBVSxFQUFFSCxJQUFJRyxVQUFVLEdBQUdILElBQUlMLE1BQU07QUFDckU7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU2lCLFNBQVNDLElBQUk7SUFDcEJELFNBQVNFLFFBQVEsR0FBRztJQUVwQixJQUFJekIsT0FBTzBCLFFBQVEsQ0FBQ0YsT0FBTyxPQUFPQTtJQUVsQyxJQUFJYjtJQUVKLElBQUlhLGdCQUFnQkcsYUFBYTtRQUMvQmhCLE1BQU0sSUFBSVosV0FBV3lCO0lBQ3ZCLE9BQU8sSUFBSUcsWUFBWUMsTUFBTSxDQUFDSixPQUFPO1FBQ25DYixNQUFNLElBQUlaLFdBQVd5QixLQUFLWCxNQUFNLEVBQUVXLEtBQUtWLFVBQVUsRUFBRVUsS0FBS0gsVUFBVTtJQUNwRSxPQUFPO1FBQ0xWLE1BQU1YLE9BQU82QixJQUFJLENBQUNMO1FBQ2xCRCxTQUFTRSxRQUFRLEdBQUc7SUFDdEI7SUFFQSxPQUFPZDtBQUNUO0FBRUFtQixPQUFPQyxPQUFPLEdBQUc7SUFDZjVCO0lBQ0FjLE1BQU1GO0lBQ05LO0lBQ0FHO0lBQ0FTLFFBQVFiO0FBQ1Y7QUFFQSx5QkFBeUIsR0FDekIsSUFBSSxDQUFDYyxRQUFRQyxHQUFHLENBQUNDLGlCQUFpQixFQUFFO0lBQ2xDLElBQUk7UUFDRixNQUFNQyxhQUFhdEMsbUJBQU9BLENBQUM7UUFFM0JnQyxtQkFBbUIsR0FBRyxTQUFVZCxNQUFNLEVBQUVDLElBQUksRUFBRUMsTUFBTSxFQUFFVCxNQUFNLEVBQUVILE1BQU07WUFDbEUsSUFBSUEsU0FBUyxJQUFJUyxNQUFNQyxRQUFRQyxNQUFNQyxRQUFRVCxRQUFRSDtpQkFDaEQ4QixXQUFXbkIsSUFBSSxDQUFDRCxRQUFRQyxNQUFNQyxRQUFRVCxRQUFRSDtRQUNyRDtRQUVBd0IscUJBQXFCLEdBQUcsU0FBVWpCLE1BQU0sRUFBRUksSUFBSTtZQUM1QyxJQUFJSixPQUFPUCxNQUFNLEdBQUcsSUFBSWEsUUFBUU4sUUFBUUk7aUJBQ25DbUIsV0FBV0osTUFBTSxDQUFDbkIsUUFBUUk7UUFDakM7SUFDRixFQUFFLE9BQU9vQixHQUFHO0lBQ1Ysb0NBQW9DO0lBQ3RDO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyYWZvcm1hdGlvbi8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvd3MvbGliL2J1ZmZlci11dGlsLmpzPzRlNzkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IEVNUFRZX0JVRkZFUiB9ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cbi8qKlxuICogTWVyZ2VzIGFuIGFycmF5IG9mIGJ1ZmZlcnMgaW50byBhIG5ldyBidWZmZXIuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJbXX0gbGlzdCBUaGUgYXJyYXkgb2YgYnVmZmVycyB0byBjb25jYXRcbiAqIEBwYXJhbSB7TnVtYmVyfSB0b3RhbExlbmd0aCBUaGUgdG90YWwgbGVuZ3RoIG9mIGJ1ZmZlcnMgaW4gdGhlIGxpc3RcbiAqIEByZXR1cm4ge0J1ZmZlcn0gVGhlIHJlc3VsdGluZyBidWZmZXJcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY29uY2F0KGxpc3QsIHRvdGFsTGVuZ3RoKSB7XG4gIGlmIChsaXN0Lmxlbmd0aCA9PT0gMCkgcmV0dXJuIEVNUFRZX0JVRkZFUjtcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSByZXR1cm4gbGlzdFswXTtcblxuICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcblxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBidWYgPSBsaXN0W2ldO1xuICAgIHRhcmdldC5zZXQoYnVmLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBidWYubGVuZ3RoO1xuICB9XG5cbiAgaWYgKG9mZnNldCA8IHRvdGFsTGVuZ3RoKSB7XG4gICAgcmV0dXJuIG5ldyBGYXN0QnVmZmVyKHRhcmdldC5idWZmZXIsIHRhcmdldC5ieXRlT2Zmc2V0LCBvZmZzZXQpO1xuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuLyoqXG4gKiBNYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gc291cmNlIFRoZSBidWZmZXIgdG8gbWFza1xuICogQHBhcmFtIHtCdWZmZXJ9IG1hc2sgVGhlIG1hc2sgdG8gdXNlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gb3V0cHV0IFRoZSBidWZmZXIgd2hlcmUgdG8gc3RvcmUgdGhlIHJlc3VsdFxuICogQHBhcmFtIHtOdW1iZXJ9IG9mZnNldCBUaGUgb2Zmc2V0IGF0IHdoaWNoIHRvIHN0YXJ0IHdyaXRpbmdcbiAqIEBwYXJhbSB7TnVtYmVyfSBsZW5ndGggVGhlIG51bWJlciBvZiBieXRlcyB0byBtYXNrLlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBfbWFzayhzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFtvZmZzZXQgKyBpXSA9IHNvdXJjZVtpXSBeIG1hc2tbaSAmIDNdO1xuICB9XG59XG5cbi8qKlxuICogVW5tYXNrcyBhIGJ1ZmZlciB1c2luZyB0aGUgZ2l2ZW4gbWFzay5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gYnVmZmVyIFRoZSBidWZmZXIgdG8gdW5tYXNrXG4gKiBAcGFyYW0ge0J1ZmZlcn0gbWFzayBUaGUgbWFzayB0byB1c2VcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX3VubWFzayhidWZmZXIsIG1hc2spIHtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICBidWZmZXJbaV0gXj0gbWFza1tpICYgM107XG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBhIGJ1ZmZlciB0byBhbiBgQXJyYXlCdWZmZXJgLlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBidWYgVGhlIGJ1ZmZlciB0byBjb252ZXJ0XG4gKiBAcmV0dXJuIHtBcnJheUJ1ZmZlcn0gQ29udmVydGVkIGJ1ZmZlclxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiB0b0FycmF5QnVmZmVyKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gYnVmLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJ1Zi5idWZmZXI7XG4gIH1cblxuICByZXR1cm4gYnVmLmJ1ZmZlci5zbGljZShidWYuYnl0ZU9mZnNldCwgYnVmLmJ5dGVPZmZzZXQgKyBidWYubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0cyBgZGF0YWAgdG8gYSBgQnVmZmVyYC5cbiAqXG4gKiBAcGFyYW0geyp9IGRhdGEgVGhlIGRhdGEgdG8gY29udmVydFxuICogQHJldHVybiB7QnVmZmVyfSBUaGUgYnVmZmVyXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9XG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvQnVmZmVyKGRhdGEpIHtcbiAgdG9CdWZmZXIucmVhZE9ubHkgPSB0cnVlO1xuXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoZGF0YSkpIHJldHVybiBkYXRhO1xuXG4gIGxldCBidWY7XG5cbiAgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEpO1xuICB9IGVsc2UgaWYgKEFycmF5QnVmZmVyLmlzVmlldyhkYXRhKSkge1xuICAgIGJ1ZiA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEuYnl0ZUxlbmd0aCk7XG4gIH0gZWxzZSB7XG4gICAgYnVmID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgdG9CdWZmZXIucmVhZE9ubHkgPSBmYWxzZTtcbiAgfVxuXG4gIHJldHVybiBidWY7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBjb25jYXQsXG4gIG1hc2s6IF9tYXNrLFxuICB0b0FycmF5QnVmZmVyLFxuICB0b0J1ZmZlcixcbiAgdW5tYXNrOiBfdW5tYXNrXG59O1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAgKi9cbmlmICghcHJvY2Vzcy5lbnYuV1NfTk9fQlVGRkVSX1VUSUwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBidWZmZXJVdGlsID0gcmVxdWlyZSgnYnVmZmVydXRpbCcpO1xuXG4gICAgbW9kdWxlLmV4cG9ydHMubWFzayA9IGZ1bmN0aW9uIChzb3VyY2UsIG1hc2ssIG91dHB1dCwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICAgIGlmIChsZW5ndGggPCA0OCkgX21hc2soc291cmNlLCBtYXNrLCBvdXRwdXQsIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC5tYXNrKHNvdXJjZSwgbWFzaywgb3V0cHV0LCBvZmZzZXQsIGxlbmd0aCk7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzLnVubWFzayA9IGZ1bmN0aW9uIChidWZmZXIsIG1hc2spIHtcbiAgICAgIGlmIChidWZmZXIubGVuZ3RoIDwgMzIpIF91bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICAgIGVsc2UgYnVmZmVyVXRpbC51bm1hc2soYnVmZmVyLCBtYXNrKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFTVBUWV9CVUZGRVIiLCJyZXF1aXJlIiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJjb25jYXQiLCJsaXN0IiwidG90YWxMZW5ndGgiLCJsZW5ndGgiLCJ0YXJnZXQiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsImkiLCJidWYiLCJzZXQiLCJidWZmZXIiLCJieXRlT2Zmc2V0IiwiX21hc2siLCJzb3VyY2UiLCJtYXNrIiwib3V0cHV0IiwiX3VubWFzayIsInRvQXJyYXlCdWZmZXIiLCJieXRlTGVuZ3RoIiwic2xpY2UiLCJ0b0J1ZmZlciIsImRhdGEiLCJyZWFkT25seSIsImlzQnVmZmVyIiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJmcm9tIiwibW9kdWxlIiwiZXhwb3J0cyIsInVubWFzayIsInByb2Nlc3MiLCJlbnYiLCJXU19OT19CVUZGRVJfVVRJTCIsImJ1ZmZlclV0aWwiLCJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/constants.js ***!
  \**********************************************************************/
/***/ ((module) => {

eval("\nconst BINARY_TYPES = [\n    \"nodebuffer\",\n    \"arraybuffer\",\n    \"fragments\"\n];\nconst hasBlob = typeof Blob !== \"undefined\";\nif (hasBlob) BINARY_TYPES.push(\"blob\");\nmodule.exports = {\n    BINARY_TYPES,\n    CLOSE_TIMEOUT: 30000,\n    EMPTY_BUFFER: Buffer.alloc(0),\n    GUID: \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\",\n    hasBlob,\n    kForOnEventAttribute: Symbol(\"kIsForOnEventAttribute\"),\n    kListener: Symbol(\"kListener\"),\n    kStatusCode: Symbol(\"status-code\"),\n    kWebSocket: Symbol(\"websocket\"),\n    NOOP: ()=>{}\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9jb25zdGFudHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxlQUFlO0lBQUM7SUFBYztJQUFlO0NBQVk7QUFDL0QsTUFBTUMsVUFBVSxPQUFPQyxTQUFTO0FBRWhDLElBQUlELFNBQVNELGFBQWFHLElBQUksQ0FBQztBQUUvQkMsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZMO0lBQ0FNLGVBQWU7SUFDZkMsY0FBY0MsT0FBT0MsS0FBSyxDQUFDO0lBQzNCQyxNQUFNO0lBQ05UO0lBQ0FVLHNCQUFzQkMsT0FBTztJQUM3QkMsV0FBV0QsT0FBTztJQUNsQkUsYUFBYUYsT0FBTztJQUNwQkcsWUFBWUgsT0FBTztJQUNuQkksTUFBTSxLQUFPO0FBQ2YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyYWZvcm1hdGlvbi8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvd3MvbGliL2NvbnN0YW50cy5qcz9lYTEyIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgQklOQVJZX1RZUEVTID0gWydub2RlYnVmZmVyJywgJ2FycmF5YnVmZmVyJywgJ2ZyYWdtZW50cyddO1xuY29uc3QgaGFzQmxvYiA9IHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJztcblxuaWYgKGhhc0Jsb2IpIEJJTkFSWV9UWVBFUy5wdXNoKCdibG9iJyk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBCSU5BUllfVFlQRVMsXG4gIENMT1NFX1RJTUVPVVQ6IDMwMDAwLFxuICBFTVBUWV9CVUZGRVI6IEJ1ZmZlci5hbGxvYygwKSxcbiAgR1VJRDogJzI1OEVBRkE1LUU5MTQtNDdEQS05NUNBLUM1QUIwREM4NUIxMScsXG4gIGhhc0Jsb2IsXG4gIGtGb3JPbkV2ZW50QXR0cmlidXRlOiBTeW1ib2woJ2tJc0Zvck9uRXZlbnRBdHRyaWJ1dGUnKSxcbiAga0xpc3RlbmVyOiBTeW1ib2woJ2tMaXN0ZW5lcicpLFxuICBrU3RhdHVzQ29kZTogU3ltYm9sKCdzdGF0dXMtY29kZScpLFxuICBrV2ViU29ja2V0OiBTeW1ib2woJ3dlYnNvY2tldCcpLFxuICBOT09QOiAoKSA9PiB7fVxufTtcbiJdLCJuYW1lcyI6WyJCSU5BUllfVFlQRVMiLCJoYXNCbG9iIiwiQmxvYiIsInB1c2giLCJtb2R1bGUiLCJleHBvcnRzIiwiQ0xPU0VfVElNRU9VVCIsIkVNUFRZX0JVRkZFUiIsIkJ1ZmZlciIsImFsbG9jIiwiR1VJRCIsImtGb3JPbkV2ZW50QXR0cmlidXRlIiwiU3ltYm9sIiwia0xpc3RlbmVyIiwia1N0YXR1c0NvZGUiLCJrV2ViU29ja2V0IiwiTk9PUCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/event-target.js":
/*!*************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/event-target.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { kForOnEventAttribute, kListener } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\nconst kCode = Symbol(\"kCode\");\nconst kData = Symbol(\"kData\");\nconst kError = Symbol(\"kError\");\nconst kMessage = Symbol(\"kMessage\");\nconst kReason = Symbol(\"kReason\");\nconst kTarget = Symbol(\"kTarget\");\nconst kType = Symbol(\"kType\");\nconst kWasClean = Symbol(\"kWasClean\");\n/**\n * Class representing an event.\n */ class Event {\n    /**\n   * Create a new `Event`.\n   *\n   * @param {String} type The name of the event\n   * @throws {TypeError} If the `type` argument is not specified\n   */ constructor(type){\n        this[kTarget] = null;\n        this[kType] = type;\n    }\n    /**\n   * @type {*}\n   */ get target() {\n        return this[kTarget];\n    }\n    /**\n   * @type {String}\n   */ get type() {\n        return this[kType];\n    }\n}\nObject.defineProperty(Event.prototype, \"target\", {\n    enumerable: true\n});\nObject.defineProperty(Event.prototype, \"type\", {\n    enumerable: true\n});\n/**\n * Class representing a close event.\n *\n * @extends Event\n */ class CloseEvent extends Event {\n    /**\n   * Create a new `CloseEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {Number} [options.code=0] The status code explaining why the\n   *     connection was closed\n   * @param {String} [options.reason=''] A human-readable string explaining why\n   *     the connection was closed\n   * @param {Boolean} [options.wasClean=false] Indicates whether or not the\n   *     connection was cleanly closed\n   */ constructor(type, options = {}){\n        super(type);\n        this[kCode] = options.code === undefined ? 0 : options.code;\n        this[kReason] = options.reason === undefined ? \"\" : options.reason;\n        this[kWasClean] = options.wasClean === undefined ? false : options.wasClean;\n    }\n    /**\n   * @type {Number}\n   */ get code() {\n        return this[kCode];\n    }\n    /**\n   * @type {String}\n   */ get reason() {\n        return this[kReason];\n    }\n    /**\n   * @type {Boolean}\n   */ get wasClean() {\n        return this[kWasClean];\n    }\n}\nObject.defineProperty(CloseEvent.prototype, \"code\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"reason\", {\n    enumerable: true\n});\nObject.defineProperty(CloseEvent.prototype, \"wasClean\", {\n    enumerable: true\n});\n/**\n * Class representing an error event.\n *\n * @extends Event\n */ class ErrorEvent extends Event {\n    /**\n   * Create a new `ErrorEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.error=null] The error that generated this event\n   * @param {String} [options.message=''] The error message\n   */ constructor(type, options = {}){\n        super(type);\n        this[kError] = options.error === undefined ? null : options.error;\n        this[kMessage] = options.message === undefined ? \"\" : options.message;\n    }\n    /**\n   * @type {*}\n   */ get error() {\n        return this[kError];\n    }\n    /**\n   * @type {String}\n   */ get message() {\n        return this[kMessage];\n    }\n}\nObject.defineProperty(ErrorEvent.prototype, \"error\", {\n    enumerable: true\n});\nObject.defineProperty(ErrorEvent.prototype, \"message\", {\n    enumerable: true\n});\n/**\n * Class representing a message event.\n *\n * @extends Event\n */ class MessageEvent extends Event {\n    /**\n   * Create a new `MessageEvent`.\n   *\n   * @param {String} type The name of the event\n   * @param {Object} [options] A dictionary object that allows for setting\n   *     attributes via object members of the same name\n   * @param {*} [options.data=null] The message content\n   */ constructor(type, options = {}){\n        super(type);\n        this[kData] = options.data === undefined ? null : options.data;\n    }\n    /**\n   * @type {*}\n   */ get data() {\n        return this[kData];\n    }\n}\nObject.defineProperty(MessageEvent.prototype, \"data\", {\n    enumerable: true\n});\n/**\n * This provides methods for emulating the `EventTarget` interface. It's not\n * meant to be used directly.\n *\n * @mixin\n */ const EventTarget = {\n    /**\n   * Register an event listener.\n   *\n   * @param {String} type A string representing the event type to listen for\n   * @param {(Function|Object)} handler The listener to add\n   * @param {Object} [options] An options object specifies characteristics about\n   *     the event listener\n   * @param {Boolean} [options.once=false] A `Boolean` indicating that the\n   *     listener should be invoked at most once after being added. If `true`,\n   *     the listener would be automatically removed when invoked.\n   * @public\n   */ addEventListener (type, handler, options = {}) {\n        for (const listener of this.listeners(type)){\n            if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                return;\n            }\n        }\n        let wrapper;\n        if (type === \"message\") {\n            wrapper = function onMessage(data, isBinary) {\n                const event = new MessageEvent(\"message\", {\n                    data: isBinary ? data : data.toString()\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"close\") {\n            wrapper = function onClose(code, message) {\n                const event = new CloseEvent(\"close\", {\n                    code,\n                    reason: message.toString(),\n                    wasClean: this._closeFrameReceived && this._closeFrameSent\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"error\") {\n            wrapper = function onError(error) {\n                const event = new ErrorEvent(\"error\", {\n                    error,\n                    message: error.message\n                });\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else if (type === \"open\") {\n            wrapper = function onOpen() {\n                const event = new Event(\"open\");\n                event[kTarget] = this;\n                callListener(handler, this, event);\n            };\n        } else {\n            return;\n        }\n        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];\n        wrapper[kListener] = handler;\n        if (options.once) {\n            this.once(type, wrapper);\n        } else {\n            this.on(type, wrapper);\n        }\n    },\n    /**\n   * Remove an event listener.\n   *\n   * @param {String} type A string representing the event type to remove\n   * @param {(Function|Object)} handler The listener to remove\n   * @public\n   */ removeEventListener (type, handler) {\n        for (const listener of this.listeners(type)){\n            if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {\n                this.removeListener(type, listener);\n                break;\n            }\n        }\n    }\n};\nmodule.exports = {\n    CloseEvent,\n    ErrorEvent,\n    Event,\n    EventTarget,\n    MessageEvent\n};\n/**\n * Call an event listener\n *\n * @param {(Function|Object)} listener The listener to call\n * @param {*} thisArg The value to use as `this`` when calling the listener\n * @param {Event} event The event to pass to the listener\n * @private\n */ function callListener(listener, thisArg, event) {\n    if (typeof listener === \"object\" && listener.handleEvent) {\n        listener.handleEvent.call(listener, event);\n    } else {\n        listener.call(thisArg, event);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9ldmVudC10YXJnZXQuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLG9CQUFvQixFQUFFQyxTQUFTLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFcEQsTUFBTUMsUUFBUUMsT0FBTztBQUNyQixNQUFNQyxRQUFRRCxPQUFPO0FBQ3JCLE1BQU1FLFNBQVNGLE9BQU87QUFDdEIsTUFBTUcsV0FBV0gsT0FBTztBQUN4QixNQUFNSSxVQUFVSixPQUFPO0FBQ3ZCLE1BQU1LLFVBQVVMLE9BQU87QUFDdkIsTUFBTU0sUUFBUU4sT0FBTztBQUNyQixNQUFNTyxZQUFZUCxPQUFPO0FBRXpCOztDQUVDLEdBQ0QsTUFBTVE7SUFDSjs7Ozs7R0FLQyxHQUNEQyxZQUFZQyxJQUFJLENBQUU7UUFDaEIsSUFBSSxDQUFDTCxRQUFRLEdBQUc7UUFDaEIsSUFBSSxDQUFDQyxNQUFNLEdBQUdJO0lBQ2hCO0lBRUE7O0dBRUMsR0FDRCxJQUFJQyxTQUFTO1FBQ1gsT0FBTyxJQUFJLENBQUNOLFFBQVE7SUFDdEI7SUFFQTs7R0FFQyxHQUNELElBQUlLLE9BQU87UUFDVCxPQUFPLElBQUksQ0FBQ0osTUFBTTtJQUNwQjtBQUNGO0FBRUFNLE9BQU9DLGNBQWMsQ0FBQ0wsTUFBTU0sU0FBUyxFQUFFLFVBQVU7SUFBRUMsWUFBWTtBQUFLO0FBQ3BFSCxPQUFPQyxjQUFjLENBQUNMLE1BQU1NLFNBQVMsRUFBRSxRQUFRO0lBQUVDLFlBQVk7QUFBSztBQUVsRTs7OztDQUlDLEdBQ0QsTUFBTUMsbUJBQW1CUjtJQUN2Qjs7Ozs7Ozs7Ozs7O0dBWUMsR0FDREMsWUFBWUMsSUFBSSxFQUFFTyxVQUFVLENBQUMsQ0FBQyxDQUFFO1FBQzlCLEtBQUssQ0FBQ1A7UUFFTixJQUFJLENBQUNYLE1BQU0sR0FBR2tCLFFBQVFDLElBQUksS0FBS0MsWUFBWSxJQUFJRixRQUFRQyxJQUFJO1FB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LEVBQUVtQixPQUFPO1FBQy9CLEtBQUssTUFBTUMsWUFBWSxJQUFJLENBQUNDLFNBQVMsQ0FBQ3JCLE1BQU87WUFDM0MsSUFBSW9CLFFBQVEsQ0FBQ2pDLFVBQVUsS0FBS2dDLFdBQVcsQ0FBQ0MsUUFBUSxDQUFDbEMscUJBQXFCLEVBQUU7Z0JBQ3RFLElBQUksQ0FBQ2tELGNBQWMsQ0FBQ3BDLE1BQU1vQjtnQkFDMUI7WUFDRjtRQUNGO0lBQ0Y7QUFDRjtBQUVBaUIsT0FBT0MsT0FBTyxHQUFHO0lBQ2ZoQztJQUNBTTtJQUNBZDtJQUNBbUI7SUFDQUY7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTWSxhQUFhUCxRQUFRLEVBQUVtQixPQUFPLEVBQUVkLEtBQUs7SUFDNUMsSUFBSSxPQUFPTCxhQUFhLFlBQVlBLFNBQVNvQixXQUFXLEVBQUU7UUFDeERwQixTQUFTb0IsV0FBVyxDQUFDQyxJQUFJLENBQUNyQixVQUFVSztJQUN0QyxPQUFPO1FBQ0xMLFNBQVNxQixJQUFJLENBQUNGLFNBQVNkO0lBQ3pCO0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyYWZvcm1hdGlvbi8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvd3MvbGliL2V2ZW50LXRhcmdldC5qcz80NjYwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBrRm9yT25FdmVudEF0dHJpYnV0ZSwga0xpc3RlbmVyIH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrQ29kZSA9IFN5bWJvbCgna0NvZGUnKTtcbmNvbnN0IGtEYXRhID0gU3ltYm9sKCdrRGF0YScpO1xuY29uc3Qga0Vycm9yID0gU3ltYm9sKCdrRXJyb3InKTtcbmNvbnN0IGtNZXNzYWdlID0gU3ltYm9sKCdrTWVzc2FnZScpO1xuY29uc3Qga1JlYXNvbiA9IFN5bWJvbCgna1JlYXNvbicpO1xuY29uc3Qga1RhcmdldCA9IFN5bWJvbCgna1RhcmdldCcpO1xuY29uc3Qga1R5cGUgPSBTeW1ib2woJ2tUeXBlJyk7XG5jb25zdCBrV2FzQ2xlYW4gPSBTeW1ib2woJ2tXYXNDbGVhbicpO1xuXG4vKipcbiAqIENsYXNzIHJlcHJlc2VudGluZyBhbiBldmVudC5cbiAqL1xuY2xhc3MgRXZlbnQge1xuICAvKipcbiAgICogQ3JlYXRlIGEgbmV3IGBFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIHRoZSBgdHlwZWAgYXJndW1lbnQgaXMgbm90IHNwZWNpZmllZFxuICAgKi9cbiAgY29uc3RydWN0b3IodHlwZSkge1xuICAgIHRoaXNba1RhcmdldF0gPSBudWxsO1xuICAgIHRoaXNba1R5cGVdID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Kn1cbiAgICovXG4gIGdldCB0YXJnZXQoKSB7XG4gICAgcmV0dXJuIHRoaXNba1RhcmdldF07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB0eXBlKCkge1xuICAgIHJldHVybiB0aGlzW2tUeXBlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXZlbnQucHJvdG90eXBlLCAndGFyZ2V0JywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KEV2ZW50LnByb3RvdHlwZSwgJ3R5cGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgY2xvc2UgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgQ2xvc2VFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgQ2xvc2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNvZGU9MF0gVGhlIHN0YXR1cyBjb2RlIGV4cGxhaW5pbmcgd2h5IHRoZVxuICAgKiAgICAgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5yZWFzb249JyddIEEgaHVtYW4tcmVhZGFibGUgc3RyaW5nIGV4cGxhaW5pbmcgd2h5XG4gICAqICAgICB0aGUgY29ubmVjdGlvbiB3YXMgY2xvc2VkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMud2FzQ2xlYW49ZmFsc2VdIEluZGljYXRlcyB3aGV0aGVyIG9yIG5vdCB0aGVcbiAgICogICAgIGNvbm5lY3Rpb24gd2FzIGNsZWFubHkgY2xvc2VkXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih0eXBlLCBvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcih0eXBlKTtcblxuICAgIHRoaXNba0NvZGVdID0gb3B0aW9ucy5jb2RlID09PSB1bmRlZmluZWQgPyAwIDogb3B0aW9ucy5jb2RlO1xuICAgIHRoaXNba1JlYXNvbl0gPSBvcHRpb25zLnJlYXNvbiA9PT0gdW5kZWZpbmVkID8gJycgOiBvcHRpb25zLnJlYXNvbjtcbiAgICB0aGlzW2tXYXNDbGVhbl0gPSBvcHRpb25zLndhc0NsZWFuID09PSB1bmRlZmluZWQgPyBmYWxzZSA6IG9wdGlvbnMud2FzQ2xlYW47XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge051bWJlcn1cbiAgICovXG4gIGdldCBjb2RlKCkge1xuICAgIHJldHVybiB0aGlzW2tDb2RlXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHJlYXNvbigpIHtcbiAgICByZXR1cm4gdGhpc1trUmVhc29uXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCB3YXNDbGVhbigpIHtcbiAgICByZXR1cm4gdGhpc1trV2FzQ2xlYW5dO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShDbG9zZUV2ZW50LnByb3RvdHlwZSwgJ2NvZGUnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICdyZWFzb24nLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoQ2xvc2VFdmVudC5wcm90b3R5cGUsICd3YXNDbGVhbicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYW4gZXJyb3IgZXZlbnQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRcbiAqL1xuY2xhc3MgRXJyb3JFdmVudCBleHRlbmRzIEV2ZW50IHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhIG5ldyBgRXJyb3JFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5lcnJvcj1udWxsXSBUaGUgZXJyb3IgdGhhdCBnZW5lcmF0ZWQgdGhpcyBldmVudFxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMubWVzc2FnZT0nJ10gVGhlIGVycm9yIG1lc3NhZ2VcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRXJyb3JdID0gb3B0aW9ucy5lcnJvciA9PT0gdW5kZWZpbmVkID8gbnVsbCA6IG9wdGlvbnMuZXJyb3I7XG4gICAgdGhpc1trTWVzc2FnZV0gPSBvcHRpb25zLm1lc3NhZ2UgPT09IHVuZGVmaW5lZCA/ICcnIDogb3B0aW9ucy5tZXNzYWdlO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHsqfVxuICAgKi9cbiAgZ2V0IGVycm9yKCkge1xuICAgIHJldHVybiB0aGlzW2tFcnJvcl07XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCBtZXNzYWdlKCkge1xuICAgIHJldHVybiB0aGlzW2tNZXNzYWdlXTtcbiAgfVxufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRXJyb3JFdmVudC5wcm90b3R5cGUsICdlcnJvcicsIHsgZW51bWVyYWJsZTogdHJ1ZSB9KTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShFcnJvckV2ZW50LnByb3RvdHlwZSwgJ21lc3NhZ2UnLCB7IGVudW1lcmFibGU6IHRydWUgfSk7XG5cbi8qKlxuICogQ2xhc3MgcmVwcmVzZW50aW5nIGEgbWVzc2FnZSBldmVudC5cbiAqXG4gKiBAZXh0ZW5kcyBFdmVudFxuICovXG5jbGFzcyBNZXNzYWdlRXZlbnQgZXh0ZW5kcyBFdmVudCB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYE1lc3NhZ2VFdmVudGAuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBuYW1lIG9mIHRoZSBldmVudFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEEgZGljdGlvbmFyeSBvYmplY3QgdGhhdCBhbGxvd3MgZm9yIHNldHRpbmdcbiAgICogICAgIGF0dHJpYnV0ZXMgdmlhIG9iamVjdCBtZW1iZXJzIG9mIHRoZSBzYW1lIG5hbWVcbiAgICogQHBhcmFtIHsqfSBbb3B0aW9ucy5kYXRhPW51bGxdIFRoZSBtZXNzYWdlIGNvbnRlbnRcbiAgICovXG4gIGNvbnN0cnVjdG9yKHR5cGUsIG9wdGlvbnMgPSB7fSkge1xuICAgIHN1cGVyKHR5cGUpO1xuXG4gICAgdGhpc1trRGF0YV0gPSBvcHRpb25zLmRhdGEgPT09IHVuZGVmaW5lZCA/IG51bGwgOiBvcHRpb25zLmRhdGE7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUgeyp9XG4gICAqL1xuICBnZXQgZGF0YSgpIHtcbiAgICByZXR1cm4gdGhpc1trRGF0YV07XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KE1lc3NhZ2VFdmVudC5wcm90b3R5cGUsICdkYXRhJywgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xuXG4vKipcbiAqIFRoaXMgcHJvdmlkZXMgbWV0aG9kcyBmb3IgZW11bGF0aW5nIHRoZSBgRXZlbnRUYXJnZXRgIGludGVyZmFjZS4gSXQncyBub3RcbiAqIG1lYW50IHRvIGJlIHVzZWQgZGlyZWN0bHkuXG4gKlxuICogQG1peGluXG4gKi9cbmNvbnN0IEV2ZW50VGFyZ2V0ID0ge1xuICAvKipcbiAgICogUmVnaXN0ZXIgYW4gZXZlbnQgbGlzdGVuZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgZXZlbnQgdHlwZSB0byBsaXN0ZW4gZm9yXG4gICAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGhhbmRsZXIgVGhlIGxpc3RlbmVyIHRvIGFkZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIEFuIG9wdGlvbnMgb2JqZWN0IHNwZWNpZmllcyBjaGFyYWN0ZXJpc3RpY3MgYWJvdXRcbiAgICogICAgIHRoZSBldmVudCBsaXN0ZW5lclxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm9uY2U9ZmFsc2VdIEEgYEJvb2xlYW5gIGluZGljYXRpbmcgdGhhdCB0aGVcbiAgICogICAgIGxpc3RlbmVyIHNob3VsZCBiZSBpbnZva2VkIGF0IG1vc3Qgb25jZSBhZnRlciBiZWluZyBhZGRlZC4gSWYgYHRydWVgLFxuICAgKiAgICAgdGhlIGxpc3RlbmVyIHdvdWxkIGJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCB3aGVuIGludm9rZWQuXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZEV2ZW50TGlzdGVuZXIodHlwZSwgaGFuZGxlciwgb3B0aW9ucyA9IHt9KSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKFxuICAgICAgICAhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV0gJiZcbiAgICAgICAgbGlzdGVuZXJba0xpc3RlbmVyXSA9PT0gaGFuZGxlciAmJlxuICAgICAgICAhbGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxldCB3cmFwcGVyO1xuXG4gICAgaWYgKHR5cGUgPT09ICdtZXNzYWdlJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uTWVzc2FnZShkYXRhLCBpc0JpbmFyeSkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBNZXNzYWdlRXZlbnQoJ21lc3NhZ2UnLCB7XG4gICAgICAgICAgZGF0YTogaXNCaW5hcnkgPyBkYXRhIDogZGF0YS50b1N0cmluZygpXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnY2xvc2UnKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25DbG9zZShjb2RlLCBtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IENsb3NlRXZlbnQoJ2Nsb3NlJywge1xuICAgICAgICAgIGNvZGUsXG4gICAgICAgICAgcmVhc29uOiBtZXNzYWdlLnRvU3RyaW5nKCksXG4gICAgICAgICAgd2FzQ2xlYW46IHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCAmJiB0aGlzLl9jbG9zZUZyYW1lU2VudFxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ2Vycm9yJykge1xuICAgICAgd3JhcHBlciA9IGZ1bmN0aW9uIG9uRXJyb3IoZXJyb3IpIHtcbiAgICAgICAgY29uc3QgZXZlbnQgPSBuZXcgRXJyb3JFdmVudCgnZXJyb3InLCB7XG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICB9KTtcblxuICAgICAgICBldmVudFtrVGFyZ2V0XSA9IHRoaXM7XG4gICAgICAgIGNhbGxMaXN0ZW5lcihoYW5kbGVyLCB0aGlzLCBldmVudCk7XG4gICAgICB9O1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gJ29wZW4nKSB7XG4gICAgICB3cmFwcGVyID0gZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjb25zdCBldmVudCA9IG5ldyBFdmVudCgnb3BlbicpO1xuXG4gICAgICAgIGV2ZW50W2tUYXJnZXRdID0gdGhpcztcbiAgICAgICAgY2FsbExpc3RlbmVyKGhhbmRsZXIsIHRoaXMsIGV2ZW50KTtcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB3cmFwcGVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSA9ICEhb3B0aW9uc1trRm9yT25FdmVudEF0dHJpYnV0ZV07XG4gICAgd3JhcHBlcltrTGlzdGVuZXJdID0gaGFuZGxlcjtcblxuICAgIGlmIChvcHRpb25zLm9uY2UpIHtcbiAgICAgIHRoaXMub25jZSh0eXBlLCB3cmFwcGVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5vbih0eXBlLCB3cmFwcGVyKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXG4gICAqIFJlbW92ZSBhbiBldmVudCBsaXN0ZW5lci5cbiAgICpcbiAgICogQHBhcmFtIHtTdHJpbmd9IHR5cGUgQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBldmVudCB0eXBlIHRvIHJlbW92ZVxuICAgKiBAcGFyYW0geyhGdW5jdGlvbnxPYmplY3QpfSBoYW5kbGVyIFRoZSBsaXN0ZW5lciB0byByZW1vdmVcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKSB7XG4gICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLmxpc3RlbmVycyh0eXBlKSkge1xuICAgICAgaWYgKGxpc3RlbmVyW2tMaXN0ZW5lcl0gPT09IGhhbmRsZXIgJiYgIWxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkge1xuICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgQ2xvc2VFdmVudCxcbiAgRXJyb3JFdmVudCxcbiAgRXZlbnQsXG4gIEV2ZW50VGFyZ2V0LFxuICBNZXNzYWdlRXZlbnRcbn07XG5cbi8qKlxuICogQ2FsbCBhbiBldmVudCBsaXN0ZW5lclxuICpcbiAqIEBwYXJhbSB7KEZ1bmN0aW9ufE9iamVjdCl9IGxpc3RlbmVyIFRoZSBsaXN0ZW5lciB0byBjYWxsXG4gKiBAcGFyYW0geyp9IHRoaXNBcmcgVGhlIHZhbHVlIHRvIHVzZSBhcyBgdGhpc2BgIHdoZW4gY2FsbGluZyB0aGUgbGlzdGVuZXJcbiAqIEBwYXJhbSB7RXZlbnR9IGV2ZW50IFRoZSBldmVudCB0byBwYXNzIHRvIHRoZSBsaXN0ZW5lclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2FsbExpc3RlbmVyKGxpc3RlbmVyLCB0aGlzQXJnLCBldmVudCkge1xuICBpZiAodHlwZW9mIGxpc3RlbmVyID09PSAnb2JqZWN0JyAmJiBsaXN0ZW5lci5oYW5kbGVFdmVudCkge1xuICAgIGxpc3RlbmVyLmhhbmRsZUV2ZW50LmNhbGwobGlzdGVuZXIsIGV2ZW50KTtcbiAgfSBlbHNlIHtcbiAgICBsaXN0ZW5lci5jYWxsKHRoaXNBcmcsIGV2ZW50KTtcbiAgfVxufVxuIl0sIm5hbWVzIjpbImtGb3JPbkV2ZW50QXR0cmlidXRlIiwia0xpc3RlbmVyIiwicmVxdWlyZSIsImtDb2RlIiwiU3ltYm9sIiwia0RhdGEiLCJrRXJyb3IiLCJrTWVzc2FnZSIsImtSZWFzb24iLCJrVGFyZ2V0Iiwia1R5cGUiLCJrV2FzQ2xlYW4iLCJFdmVudCIsImNvbnN0cnVjdG9yIiwidHlwZSIsInRhcmdldCIsIk9iamVjdCIsImRlZmluZVByb3BlcnR5IiwicHJvdG90eXBlIiwiZW51bWVyYWJsZSIsIkNsb3NlRXZlbnQiLCJvcHRpb25zIiwiY29kZSIsInVuZGVmaW5lZCIsInJlYXNvbiIsIndhc0NsZWFuIiwiRXJyb3JFdmVudCIsImVycm9yIiwibWVzc2FnZSIsIk1lc3NhZ2VFdmVudCIsImRhdGEiLCJFdmVudFRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJoYW5kbGVyIiwibGlzdGVuZXIiLCJsaXN0ZW5lcnMiLCJ3cmFwcGVyIiwib25NZXNzYWdlIiwiaXNCaW5hcnkiLCJldmVudCIsInRvU3RyaW5nIiwiY2FsbExpc3RlbmVyIiwib25DbG9zZSIsIl9jbG9zZUZyYW1lUmVjZWl2ZWQiLCJfY2xvc2VGcmFtZVNlbnQiLCJvbkVycm9yIiwib25PcGVuIiwib25jZSIsIm9uIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsInRoaXNBcmciLCJoYW5kbGVFdmVudCIsImNhbGwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/event-target.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/extension.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/extension.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/validation.js\");\n/**\n * Adds an offer to the map of extension offers or a parameter to the map of\n * parameters.\n *\n * @param {Object} dest The map of extension offers or parameters\n * @param {String} name The extension or parameter name\n * @param {(Object|Boolean|String)} elem The extension parameters or the\n *     parameter value\n * @private\n */ function push(dest, name, elem) {\n    if (dest[name] === undefined) dest[name] = [\n        elem\n    ];\n    else dest[name].push(elem);\n}\n/**\n * Parses the `Sec-WebSocket-Extensions` header into an object.\n *\n * @param {String} header The field value of the header\n * @return {Object} The parsed object\n * @public\n */ function parse(header) {\n    const offers = Object.create(null);\n    let params = Object.create(null);\n    let mustUnescape = false;\n    let isEscaping = false;\n    let inQuotes = false;\n    let extensionName;\n    let paramName;\n    let start = -1;\n    let code = -1;\n    let end = -1;\n    let i = 0;\n    for(; i < header.length; i++){\n        code = header.charCodeAt(i);\n        if (extensionName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b /* ';' */  || code === 0x2c /* ',' */ ) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                const name = header.slice(start, end);\n                if (code === 0x2c) {\n                    push(offers, name, params);\n                    params = Object.create(null);\n                } else {\n                    extensionName = name;\n                }\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else if (paramName === undefined) {\n            if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (code === 0x20 || code === 0x09) {\n                if (end === -1 && start !== -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                push(params, header.slice(start, end), true);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                start = end = -1;\n            } else if (code === 0x3d /* '=' */  && start !== -1 && end === -1) {\n                paramName = header.slice(start, i);\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        } else {\n            //\n            // The value of a quoted-string after unescaping must conform to the\n            // token ABNF, so only token characters are valid.\n            // Ref: https://tools.ietf.org/html/rfc6455#section-9.1\n            //\n            if (isEscaping) {\n                if (tokenChars[code] !== 1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (start === -1) start = i;\n                else if (!mustUnescape) mustUnescape = true;\n                isEscaping = false;\n            } else if (inQuotes) {\n                if (tokenChars[code] === 1) {\n                    if (start === -1) start = i;\n                } else if (code === 0x22 /* '\"' */  && start !== -1) {\n                    inQuotes = false;\n                    end = i;\n                } else if (code === 0x5c /* '\\' */ ) {\n                    isEscaping = true;\n                } else {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n            } else if (code === 0x22 && header.charCodeAt(i - 1) === 0x3d) {\n                inQuotes = true;\n            } else if (end === -1 && tokenChars[code] === 1) {\n                if (start === -1) start = i;\n            } else if (start !== -1 && (code === 0x20 || code === 0x09)) {\n                if (end === -1) end = i;\n            } else if (code === 0x3b || code === 0x2c) {\n                if (start === -1) {\n                    throw new SyntaxError(`Unexpected character at index ${i}`);\n                }\n                if (end === -1) end = i;\n                let value = header.slice(start, end);\n                if (mustUnescape) {\n                    value = value.replace(/\\\\/g, \"\");\n                    mustUnescape = false;\n                }\n                push(params, paramName, value);\n                if (code === 0x2c) {\n                    push(offers, extensionName, params);\n                    params = Object.create(null);\n                    extensionName = undefined;\n                }\n                paramName = undefined;\n                start = end = -1;\n            } else {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n        }\n    }\n    if (start === -1 || inQuotes || code === 0x20 || code === 0x09) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    if (end === -1) end = i;\n    const token = header.slice(start, end);\n    if (extensionName === undefined) {\n        push(offers, token, params);\n    } else {\n        if (paramName === undefined) {\n            push(params, token, true);\n        } else if (mustUnescape) {\n            push(params, paramName, token.replace(/\\\\/g, \"\"));\n        } else {\n            push(params, paramName, token);\n        }\n        push(offers, extensionName, params);\n    }\n    return offers;\n}\n/**\n * Builds the `Sec-WebSocket-Extensions` header field value.\n *\n * @param {Object} extensions The map of extensions and parameters to format\n * @return {String} A string representing the given object\n * @public\n */ function format(extensions) {\n    return Object.keys(extensions).map((extension)=>{\n        let configurations = extensions[extension];\n        if (!Array.isArray(configurations)) configurations = [\n            configurations\n        ];\n        return configurations.map((params)=>{\n            return [\n                extension\n            ].concat(Object.keys(params).map((k)=>{\n                let values = params[k];\n                if (!Array.isArray(values)) values = [\n                    values\n                ];\n                return values.map((v)=>v === true ? k : `${k}=${v}`).join(\"; \");\n            })).join(\"; \");\n        }).join(\", \");\n    }).join(\", \");\n}\nmodule.exports = {\n    format,\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNLEVBQUVBLFVBQVUsRUFBRSxHQUFHQyxtQkFBT0EsQ0FBQztBQUUvQjs7Ozs7Ozs7O0NBU0MsR0FDRCxTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsSUFBSTtJQUM1QixJQUFJRixJQUFJLENBQUNDLEtBQUssS0FBS0UsV0FBV0gsSUFBSSxDQUFDQyxLQUFLLEdBQUc7UUFBQ0M7S0FBSztTQUM1Q0YsSUFBSSxDQUFDQyxLQUFLLENBQUNGLElBQUksQ0FBQ0c7QUFDdkI7QUFFQTs7Ozs7O0NBTUMsR0FDRCxTQUFTRSxNQUFNQyxNQUFNO0lBQ25CLE1BQU1DLFNBQVNDLE9BQU9DLE1BQU0sQ0FBQztJQUM3QixJQUFJQyxTQUFTRixPQUFPQyxNQUFNLENBQUM7SUFDM0IsSUFBSUUsZUFBZTtJQUNuQixJQUFJQyxhQUFhO0lBQ2pCLElBQUlDLFdBQVc7SUFDZixJQUFJQztJQUNKLElBQUlDO0lBQ0osSUFBSUMsUUFBUSxDQUFDO0lBQ2IsSUFBSUMsT0FBTyxDQUFDO0lBQ1osSUFBSUMsTUFBTSxDQUFDO0lBQ1gsSUFBSUMsSUFBSTtJQUVSLE1BQU9BLElBQUliLE9BQU9jLE1BQU0sRUFBRUQsSUFBSztRQUM3QkYsT0FBT1gsT0FBT2UsVUFBVSxDQUFDRjtRQUV6QixJQUFJTCxrQkFBa0JWLFdBQVc7WUFDL0IsSUFBSWMsUUFBUSxDQUFDLEtBQUtwQixVQUFVLENBQUNtQixLQUFLLEtBQUssR0FBRztnQkFDeEMsSUFBSUQsVUFBVSxDQUFDLEdBQUdBLFFBQVFHO1lBQzVCLE9BQU8sSUFDTEEsTUFBTSxLQUNMRixDQUFBQSxTQUFTLEtBQUssT0FBTyxPQUFNQSxTQUFTLElBQUcsR0FDeEM7Z0JBQ0EsSUFBSUMsUUFBUSxDQUFDLEtBQUtGLFVBQVUsQ0FBQyxHQUFHRSxNQUFNQztZQUN4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YnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9leHRlbnNpb24uanM/MWYxMyJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogQWRkcyBhbiBvZmZlciB0byB0aGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgYSBwYXJhbWV0ZXIgdG8gdGhlIG1hcCBvZlxuICogcGFyYW1ldGVycy5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gZGVzdCBUaGUgbWFwIG9mIGV4dGVuc2lvbiBvZmZlcnMgb3IgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgVGhlIGV4dGVuc2lvbiBvciBwYXJhbWV0ZXIgbmFtZVxuICogQHBhcmFtIHsoT2JqZWN0fEJvb2xlYW58U3RyaW5nKX0gZWxlbSBUaGUgZXh0ZW5zaW9uIHBhcmFtZXRlcnMgb3IgdGhlXG4gKiAgICAgcGFyYW1ldGVyIHZhbHVlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBwdXNoKGRlc3QsIG5hbWUsIGVsZW0pIHtcbiAgaWYgKGRlc3RbbmFtZV0gPT09IHVuZGVmaW5lZCkgZGVzdFtuYW1lXSA9IFtlbGVtXTtcbiAgZWxzZSBkZXN0W25hbWVdLnB1c2goZWxlbSk7XG59XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zYCBoZWFkZXIgaW50byBhbiBvYmplY3QuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7T2JqZWN0fSBUaGUgcGFyc2VkIG9iamVjdFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBwYXJzZShoZWFkZXIpIHtcbiAgY29uc3Qgb2ZmZXJzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgbGV0IHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGxldCBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgbGV0IGlzRXNjYXBpbmcgPSBmYWxzZTtcbiAgbGV0IGluUXVvdGVzID0gZmFsc2U7XG4gIGxldCBleHRlbnNpb25OYW1lO1xuICBsZXQgcGFyYW1OYW1lO1xuICBsZXQgc3RhcnQgPSAtMTtcbiAgbGV0IGNvZGUgPSAtMTtcbiAgbGV0IGVuZCA9IC0xO1xuICBsZXQgaSA9IDA7XG5cbiAgZm9yICg7IGkgPCBoZWFkZXIubGVuZ3RoOyBpKyspIHtcbiAgICBjb2RlID0gaGVhZGVyLmNoYXJDb2RlQXQoaSk7XG5cbiAgICBpZiAoZXh0ZW5zaW9uTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiB0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGkgIT09IDAgJiZcbiAgICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgICApIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIC8qICc7JyAqLyB8fCBjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgY29uc3QgbmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgaWYgKGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgICBwdXNoKG9mZmVycywgbmFtZSwgcGFyYW1zKTtcbiAgICAgICAgICBwYXJhbXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4dGVuc2lvbk5hbWUgPSBuYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgc3RhcnQgPSBlbmQgPSAtMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocGFyYW1OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEgJiYgc3RhcnQgIT09IC0xKSBlbmQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChjb2RlID09PSAweDNiIHx8IGNvZGUgPT09IDB4MmMpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihgVW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgaW5kZXggJHtpfWApO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICAgIHB1c2gocGFyYW1zLCBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCksIHRydWUpO1xuICAgICAgICBpZiAoY29kZSA9PT0gMHgyYykge1xuICAgICAgICAgIHB1c2gob2ZmZXJzLCBleHRlbnNpb25OYW1lLCBwYXJhbXMpO1xuICAgICAgICAgIHBhcmFtcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgICAgZXh0ZW5zaW9uTmFtZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2QgLyogJz0nICovICYmIHN0YXJ0ICE9PSAtMSAmJiBlbmQgPT09IC0xKSB7XG4gICAgICAgIHBhcmFtTmFtZSA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG4gICAgICAgIHN0YXJ0ID0gZW5kID0gLTE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy9cbiAgICAgIC8vIFRoZSB2YWx1ZSBvZiBhIHF1b3RlZC1zdHJpbmcgYWZ0ZXIgdW5lc2NhcGluZyBtdXN0IGNvbmZvcm0gdG8gdGhlXG4gICAgICAvLyB0b2tlbiBBQk5GLCBzbyBvbmx5IHRva2VuIGNoYXJhY3RlcnMgYXJlIHZhbGlkLlxuICAgICAgLy8gUmVmOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjQ1NSNzZWN0aW9uLTkuMVxuICAgICAgLy9cbiAgICAgIGlmIChpc0VzY2FwaW5nKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICBlbHNlIGlmICghbXVzdFVuZXNjYXBlKSBtdXN0VW5lc2NhcGUgPSB0cnVlO1xuICAgICAgICBpc0VzY2FwaW5nID0gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGluUXVvdGVzKSB7XG4gICAgICAgIGlmICh0b2tlbkNoYXJzW2NvZGVdID09PSAxKSB7XG4gICAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4MjIgLyogJ1wiJyAqLyAmJiBzdGFydCAhPT0gLTEpIHtcbiAgICAgICAgICBpblF1b3RlcyA9IGZhbHNlO1xuICAgICAgICAgIGVuZCA9IGk7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHg1YyAvKiAnXFwnICovKSB7XG4gICAgICAgICAgaXNFc2NhcGluZyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoY29kZSA9PT0gMHgyMiAmJiBoZWFkZXIuY2hhckNvZGVBdChpIC0gMSkgPT09IDB4M2QpIHtcbiAgICAgICAgaW5RdW90ZXMgPSB0cnVlO1xuICAgICAgfSBlbHNlIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgICAgaWYgKHN0YXJ0ID09PSAtMSkgc3RhcnQgPSBpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCAhPT0gLTEgJiYgKGNvZGUgPT09IDB4MjAgfHwgY29kZSA9PT0gMHgwOSkpIHtcbiAgICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG4gICAgICB9IGVsc2UgaWYgKGNvZGUgPT09IDB4M2IgfHwgY29kZSA9PT0gMHgyYykge1xuICAgICAgICBpZiAoc3RhcnQgPT09IC0xKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgICAgICAgbGV0IHZhbHVlID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuICAgICAgICBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcL2csICcnKTtcbiAgICAgICAgICBtdXN0VW5lc2NhcGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB2YWx1ZSk7XG4gICAgICAgIGlmIChjb2RlID09PSAweDJjKSB7XG4gICAgICAgICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gICAgICAgICAgcGFyYW1zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICBleHRlbnNpb25OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG5cbiAgICAgICAgcGFyYW1OYW1lID0gdW5kZWZpbmVkO1xuICAgICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBVbmV4cGVjdGVkIGNoYXJhY3RlciBhdCBpbmRleCAke2l9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSAtMSB8fCBpblF1b3RlcyB8fCBjb2RlID09PSAweDIwIHx8IGNvZGUgPT09IDB4MDkpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBpZiAoZW5kID09PSAtMSkgZW5kID0gaTtcbiAgY29uc3QgdG9rZW4gPSBoZWFkZXIuc2xpY2Uoc3RhcnQsIGVuZCk7XG4gIGlmIChleHRlbnNpb25OYW1lID09PSB1bmRlZmluZWQpIHtcbiAgICBwdXNoKG9mZmVycywgdG9rZW4sIHBhcmFtcyk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHBhcmFtTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBwdXNoKHBhcmFtcywgdG9rZW4sIHRydWUpO1xuICAgIH0gZWxzZSBpZiAobXVzdFVuZXNjYXBlKSB7XG4gICAgICBwdXNoKHBhcmFtcywgcGFyYW1OYW1lLCB0b2tlbi5yZXBsYWNlKC9cXFxcL2csICcnKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHB1c2gocGFyYW1zLCBwYXJhbU5hbWUsIHRva2VuKTtcbiAgICB9XG4gICAgcHVzaChvZmZlcnMsIGV4dGVuc2lvbk5hbWUsIHBhcmFtcyk7XG4gIH1cblxuICByZXR1cm4gb2ZmZXJzO1xufVxuXG4vKipcbiAqIEJ1aWxkcyB0aGUgYFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9uc2AgaGVhZGVyIGZpZWxkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBtYXAgb2YgZXh0ZW5zaW9ucyBhbmQgcGFyYW1ldGVycyB0byBmb3JtYXRcbiAqIEByZXR1cm4ge1N0cmluZ30gQSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSBnaXZlbiBvYmplY3RcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gZm9ybWF0KGV4dGVuc2lvbnMpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpXG4gICAgLm1hcCgoZXh0ZW5zaW9uKSA9PiB7XG4gICAgICBsZXQgY29uZmlndXJhdGlvbnMgPSBleHRlbnNpb25zW2V4dGVuc2lvbl07XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29uZmlndXJhdGlvbnMpKSBjb25maWd1cmF0aW9ucyA9IFtjb25maWd1cmF0aW9uc107XG4gICAgICByZXR1cm4gY29uZmlndXJhdGlvbnNcbiAgICAgICAgLm1hcCgocGFyYW1zKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIFtleHRlbnNpb25dXG4gICAgICAgICAgICAuY29uY2F0KFxuICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLm1hcCgoaykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCB2YWx1ZXMgPSBwYXJhbXNba107XG4gICAgICAgICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlcykpIHZhbHVlcyA9IFt2YWx1ZXNdO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgICAgICAgICAgIC5tYXAoKHYpID0+ICh2ID09PSB0cnVlID8gayA6IGAke2t9PSR7dn1gKSlcbiAgICAgICAgICAgICAgICAgIC5qb2luKCc7ICcpO1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgICAgLmpvaW4oJzsgJyk7XG4gICAgICAgIH0pXG4gICAgICAgIC5qb2luKCcsICcpO1xuICAgIH0pXG4gICAgLmpvaW4oJywgJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0geyBmb3JtYXQsIHBhcnNlIH07XG4iXSwibmFtZXMiOlsidG9rZW5DaGFycyIsInJlcXVpcmUiLCJwdXNoIiwiZGVzdCIsIm5hbWUiLCJlbGVtIiwidW5kZWZpbmVkIiwicGFyc2UiLCJoZWFkZXIiLCJvZmZlcnMiLCJPYmplY3QiLCJjcmVhdGUiLCJwYXJhbXMiLCJtdXN0VW5lc2NhcGUiLCJpc0VzY2FwaW5nIiwiaW5RdW90ZXMiLCJleHRlbnNpb25OYW1lIiwicGFyYW1OYW1lIiwic3RhcnQiLCJjb2RlIiwiZW5kIiwiaSIsImxlbmd0aCIsImNoYXJDb2RlQXQiLCJTeW50YXhFcnJvciIsInNsaWNlIiwidmFsdWUiLCJyZXBsYWNlIiwidG9rZW4iLCJmb3JtYXQiLCJleHRlbnNpb25zIiwia2V5cyIsIm1hcCIsImV4dGVuc2lvbiIsImNvbmZpZ3VyYXRpb25zIiwiQXJyYXkiLCJpc0FycmF5IiwiY29uY2F0IiwiayIsInZhbHVlcyIsInYiLCJqb2luIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/extension.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/limiter.js":
/*!********************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/limiter.js ***!
  \********************************************************************/
/***/ ((module) => {

eval("\nconst kDone = Symbol(\"kDone\");\nconst kRun = Symbol(\"kRun\");\n/**\n * A very simple job queue with adjustable concurrency. Adapted from\n * https://github.com/STRML/async-limiter\n */ class Limiter {\n    /**\n   * Creates a new `Limiter`.\n   *\n   * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed\n   *     to run concurrently\n   */ constructor(concurrency){\n        this[kDone] = ()=>{\n            this.pending--;\n            this[kRun]();\n        };\n        this.concurrency = concurrency || Infinity;\n        this.jobs = [];\n        this.pending = 0;\n    }\n    /**\n   * Adds a job to the queue.\n   *\n   * @param {Function} job The job to run\n   * @public\n   */ add(job) {\n        this.jobs.push(job);\n        this[kRun]();\n    }\n    /**\n   * Removes a job from the queue and runs it if possible.\n   *\n   * @private\n   */ [kRun]() {\n        if (this.pending === this.concurrency) return;\n        if (this.jobs.length) {\n            const job = this.jobs.shift();\n            this.pending++;\n            job(this[kDone]);\n        }\n    }\n}\nmodule.exports = Limiter;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9saW1pdGVyLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTUEsUUFBUUMsT0FBTztBQUNyQixNQUFNQyxPQUFPRCxPQUFPO0FBRXBCOzs7Q0FHQyxHQUNELE1BQU1FO0lBQ0o7Ozs7O0dBS0MsR0FDREMsWUFBWUMsV0FBVyxDQUFFO1FBQ3ZCLElBQUksQ0FBQ0wsTUFBTSxHQUFHO1lBQ1osSUFBSSxDQUFDTSxPQUFPO1lBQ1osSUFBSSxDQUFDSixLQUFLO1FBQ1o7UUFDQSxJQUFJLENBQUNHLFdBQVcsR0FBR0EsZUFBZUU7UUFDbEMsSUFBSSxDQUFDQyxJQUFJLEdBQUcsRUFBRTtRQUNkLElBQUksQ0FBQ0YsT0FBTyxHQUFHO0lBQ2pCO0lBRUE7Ozs7O0dBS0MsR0FDREcsSUFBSUMsR0FBRyxFQUFFO1FBQ1AsSUFBSSxDQUFDRixJQUFJLENBQUNHLElBQUksQ0FBQ0Q7UUFDZixJQUFJLENBQUNSLEtBQUs7SUFDWjtJQUVBOzs7O0dBSUMsR0FDRCxDQUFDQSxLQUFLLEdBQUc7UUFDUCxJQUFJLElBQUksQ0FBQ0ksT0FBTyxLQUFLLElBQUksQ0FBQ0QsV0FBVyxFQUFFO1FBRXZDLElBQUksSUFBSSxDQUFDRyxJQUFJLENBQUNJLE1BQU0sRUFBRTtZQUNwQixNQUFNRixNQUFNLElBQUksQ0FBQ0YsSUFBSSxDQUFDSyxLQUFLO1lBRTNCLElBQUksQ0FBQ1AsT0FBTztZQUNaSSxJQUFJLElBQUksQ0FBQ1YsTUFBTTtRQUNqQjtJQUNGO0FBQ0Y7QUFFQWMsT0FBT0MsT0FBTyxHQUFHWiIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJhZm9ybWF0aW9uLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL25vZGVfbW9kdWxlcy93cy9saWIvbGltaXRlci5qcz9hY2VmIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3Qga0RvbmUgPSBTeW1ib2woJ2tEb25lJyk7XG5jb25zdCBrUnVuID0gU3ltYm9sKCdrUnVuJyk7XG5cbi8qKlxuICogQSB2ZXJ5IHNpbXBsZSBqb2IgcXVldWUgd2l0aCBhZGp1c3RhYmxlIGNvbmN1cnJlbmN5LiBBZGFwdGVkIGZyb21cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9TVFJNTC9hc3luYy1saW1pdGVyXG4gKi9cbmNsYXNzIExpbWl0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIG5ldyBgTGltaXRlcmAuXG4gICAqXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbY29uY3VycmVuY3k9SW5maW5pdHldIFRoZSBtYXhpbXVtIG51bWJlciBvZiBqb2JzIGFsbG93ZWRcbiAgICogICAgIHRvIHJ1biBjb25jdXJyZW50bHlcbiAgICovXG4gIGNvbnN0cnVjdG9yKGNvbmN1cnJlbmN5KSB7XG4gICAgdGhpc1trRG9uZV0gPSAoKSA9PiB7XG4gICAgICB0aGlzLnBlbmRpbmctLTtcbiAgICAgIHRoaXNba1J1bl0oKTtcbiAgICB9O1xuICAgIHRoaXMuY29uY3VycmVuY3kgPSBjb25jdXJyZW5jeSB8fCBJbmZpbml0eTtcbiAgICB0aGlzLmpvYnMgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmcgPSAwO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBqb2IgdG8gdGhlIHF1ZXVlLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBqb2IgVGhlIGpvYiB0byBydW5cbiAgICogQHB1YmxpY1xuICAgKi9cbiAgYWRkKGpvYikge1xuICAgIHRoaXMuam9icy5wdXNoKGpvYik7XG4gICAgdGhpc1trUnVuXSgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBqb2IgZnJvbSB0aGUgcXVldWUgYW5kIHJ1bnMgaXQgaWYgcG9zc2libGUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBba1J1bl0oKSB7XG4gICAgaWYgKHRoaXMucGVuZGluZyA9PT0gdGhpcy5jb25jdXJyZW5jeSkgcmV0dXJuO1xuXG4gICAgaWYgKHRoaXMuam9icy5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGpvYiA9IHRoaXMuam9icy5zaGlmdCgpO1xuXG4gICAgICB0aGlzLnBlbmRpbmcrKztcbiAgICAgIGpvYih0aGlzW2tEb25lXSk7XG4gICAgfVxuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTGltaXRlcjtcbiJdLCJuYW1lcyI6WyJrRG9uZSIsIlN5bWJvbCIsImtSdW4iLCJMaW1pdGVyIiwiY29uc3RydWN0b3IiLCJjb25jdXJyZW5jeSIsInBlbmRpbmciLCJJbmZpbml0eSIsImpvYnMiLCJhZGQiLCJqb2IiLCJwdXNoIiwibGVuZ3RoIiwic2hpZnQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/limiter.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js":
/*!*******************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js ***!
  \*******************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst bufferUtil = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js\");\nconst Limiter = __webpack_require__(/*! ./limiter */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/limiter.js\");\nconst { kStatusCode } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst TRAILER = Buffer.from([\n    0x00,\n    0x00,\n    0xff,\n    0xff\n]);\nconst kPerMessageDeflate = Symbol(\"permessage-deflate\");\nconst kTotalLength = Symbol(\"total-length\");\nconst kCallback = Symbol(\"callback\");\nconst kBuffers = Symbol(\"buffers\");\nconst kError = Symbol(\"error\");\n//\n// We limit zlib concurrency, which prevents severe memory fragmentation\n// as documented in https://github.com/nodejs/node/issues/8871#issuecomment-250915913\n// and https://github.com/websockets/ws/issues/1202\n//\n// Intentionally global; it's the global thread pool that's an issue.\n//\nlet zlibLimiter;\n/**\n * permessage-deflate implementation.\n */ class PerMessageDeflate {\n    /**\n   * Creates a PerMessageDeflate instance.\n   *\n   * @param {Object} [options] Configuration options\n   * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support\n   *     for, or request, a custom client window size\n   * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/\n   *     acknowledge disabling of client context takeover\n   * @param {Number} [options.concurrencyLimit=10] The number of concurrent\n   *     calls to zlib\n   * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the\n   *     use of a custom server window size\n   * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept\n   *     disabling of server context takeover\n   * @param {Number} [options.threshold=1024] Size (in bytes) below which\n   *     messages should not be compressed if context takeover is disabled\n   * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on\n   *     deflate\n   * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on\n   *     inflate\n   * @param {Boolean} [isServer=false] Create the instance in either server or\n   *     client mode\n   * @param {Number} [maxPayload=0] The maximum allowed message length\n   */ constructor(options, isServer, maxPayload){\n        this._maxPayload = maxPayload | 0;\n        this._options = options || {};\n        this._threshold = this._options.threshold !== undefined ? this._options.threshold : 1024;\n        this._isServer = !!isServer;\n        this._deflate = null;\n        this._inflate = null;\n        this.params = null;\n        if (!zlibLimiter) {\n            const concurrency = this._options.concurrencyLimit !== undefined ? this._options.concurrencyLimit : 10;\n            zlibLimiter = new Limiter(concurrency);\n        }\n    }\n    /**\n   * @type {String}\n   */ static get extensionName() {\n        return \"permessage-deflate\";\n    }\n    /**\n   * Create an extension negotiation offer.\n   *\n   * @return {Object} Extension parameters\n   * @public\n   */ offer() {\n        const params = {};\n        if (this._options.serverNoContextTakeover) {\n            params.server_no_context_takeover = true;\n        }\n        if (this._options.clientNoContextTakeover) {\n            params.client_no_context_takeover = true;\n        }\n        if (this._options.serverMaxWindowBits) {\n            params.server_max_window_bits = this._options.serverMaxWindowBits;\n        }\n        if (this._options.clientMaxWindowBits) {\n            params.client_max_window_bits = this._options.clientMaxWindowBits;\n        } else if (this._options.clientMaxWindowBits == null) {\n            params.client_max_window_bits = true;\n        }\n        return params;\n    }\n    /**\n   * Accept an extension negotiation offer/response.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Object} Accepted configuration\n   * @public\n   */ accept(configurations) {\n        configurations = this.normalizeParams(configurations);\n        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);\n        return this.params;\n    }\n    /**\n   * Releases all resources used by the extension.\n   *\n   * @public\n   */ cleanup() {\n        if (this._inflate) {\n            this._inflate.close();\n            this._inflate = null;\n        }\n        if (this._deflate) {\n            const callback = this._deflate[kCallback];\n            this._deflate.close();\n            this._deflate = null;\n            if (callback) {\n                callback(new Error(\"The deflate stream was closed while data was being processed\"));\n            }\n        }\n    }\n    /**\n   *  Accept an extension negotiation offer.\n   *\n   * @param {Array} offers The extension negotiation offers\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsServer(offers) {\n        const opts = this._options;\n        const accepted = offers.find((params)=>{\n            if (opts.serverNoContextTakeover === false && params.server_no_context_takeover || params.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === \"number\" && opts.serverMaxWindowBits > params.server_max_window_bits) || typeof opts.clientMaxWindowBits === \"number\" && !params.client_max_window_bits) {\n                return false;\n            }\n            return true;\n        });\n        if (!accepted) {\n            throw new Error(\"None of the extension offers can be accepted\");\n        }\n        if (opts.serverNoContextTakeover) {\n            accepted.server_no_context_takeover = true;\n        }\n        if (opts.clientNoContextTakeover) {\n            accepted.client_no_context_takeover = true;\n        }\n        if (typeof opts.serverMaxWindowBits === \"number\") {\n            accepted.server_max_window_bits = opts.serverMaxWindowBits;\n        }\n        if (typeof opts.clientMaxWindowBits === \"number\") {\n            accepted.client_max_window_bits = opts.clientMaxWindowBits;\n        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {\n            delete accepted.client_max_window_bits;\n        }\n        return accepted;\n    }\n    /**\n   * Accept the extension negotiation response.\n   *\n   * @param {Array} response The extension negotiation response\n   * @return {Object} Accepted configuration\n   * @private\n   */ acceptAsClient(response) {\n        const params = response[0];\n        if (this._options.clientNoContextTakeover === false && params.client_no_context_takeover) {\n            throw new Error('Unexpected parameter \"client_no_context_takeover\"');\n        }\n        if (!params.client_max_window_bits) {\n            if (typeof this._options.clientMaxWindowBits === \"number\") {\n                params.client_max_window_bits = this._options.clientMaxWindowBits;\n            }\n        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === \"number\" && params.client_max_window_bits > this._options.clientMaxWindowBits) {\n            throw new Error('Unexpected or invalid parameter \"client_max_window_bits\"');\n        }\n        return params;\n    }\n    /**\n   * Normalize parameters.\n   *\n   * @param {Array} configurations The extension negotiation offers/reponse\n   * @return {Array} The offers/response with normalized parameters\n   * @private\n   */ normalizeParams(configurations) {\n        configurations.forEach((params)=>{\n            Object.keys(params).forEach((key)=>{\n                let value = params[key];\n                if (value.length > 1) {\n                    throw new Error(`Parameter \"${key}\" must have only a single value`);\n                }\n                value = value[0];\n                if (key === \"client_max_window_bits\") {\n                    if (value !== true) {\n                        const num = +value;\n                        if (!Number.isInteger(num) || num < 8 || num > 15) {\n                            throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                        }\n                        value = num;\n                    } else if (!this._isServer) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else if (key === \"server_max_window_bits\") {\n                    const num = +value;\n                    if (!Number.isInteger(num) || num < 8 || num > 15) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                    value = num;\n                } else if (key === \"client_no_context_takeover\" || key === \"server_no_context_takeover\") {\n                    if (value !== true) {\n                        throw new TypeError(`Invalid value for parameter \"${key}\": ${value}`);\n                    }\n                } else {\n                    throw new Error(`Unknown parameter \"${key}\"`);\n                }\n                params[key] = value;\n            });\n        });\n        return configurations;\n    }\n    /**\n   * Decompress data. Concurrency limited.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ decompress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._decompress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Compress data. Concurrency limited.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @public\n   */ compress(data, fin, callback) {\n        zlibLimiter.add((done)=>{\n            this._compress(data, fin, (err, result)=>{\n                done();\n                callback(err, result);\n            });\n        });\n    }\n    /**\n   * Decompress data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _decompress(data, fin, callback) {\n        const endpoint = this._isServer ? \"client\" : \"server\";\n        if (!this._inflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._inflate = zlib.createInflateRaw({\n                ...this._options.zlibInflateOptions,\n                windowBits\n            });\n            this._inflate[kPerMessageDeflate] = this;\n            this._inflate[kTotalLength] = 0;\n            this._inflate[kBuffers] = [];\n            this._inflate.on(\"error\", inflateOnError);\n            this._inflate.on(\"data\", inflateOnData);\n        }\n        this._inflate[kCallback] = callback;\n        this._inflate.write(data);\n        if (fin) this._inflate.write(TRAILER);\n        this._inflate.flush(()=>{\n            const err = this._inflate[kError];\n            if (err) {\n                this._inflate.close();\n                this._inflate = null;\n                callback(err);\n                return;\n            }\n            const data = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);\n            if (this._inflate._readableState.endEmitted) {\n                this._inflate.close();\n                this._inflate = null;\n            } else {\n                this._inflate[kTotalLength] = 0;\n                this._inflate[kBuffers] = [];\n                if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                    this._inflate.reset();\n                }\n            }\n            callback(null, data);\n        });\n    }\n    /**\n   * Compress data.\n   *\n   * @param {(Buffer|String)} data Data to compress\n   * @param {Boolean} fin Specifies whether or not this is the last fragment\n   * @param {Function} callback Callback\n   * @private\n   */ _compress(data, fin, callback) {\n        const endpoint = this._isServer ? \"server\" : \"client\";\n        if (!this._deflate) {\n            const key = `${endpoint}_max_window_bits`;\n            const windowBits = typeof this.params[key] !== \"number\" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];\n            this._deflate = zlib.createDeflateRaw({\n                ...this._options.zlibDeflateOptions,\n                windowBits\n            });\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            this._deflate.on(\"data\", deflateOnData);\n        }\n        this._deflate[kCallback] = callback;\n        this._deflate.write(data);\n        this._deflate.flush(zlib.Z_SYNC_FLUSH, ()=>{\n            if (!this._deflate) {\n                //\n                // The deflate stream was closed while data was being processed.\n                //\n                return;\n            }\n            let data = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);\n            if (fin) {\n                data = new FastBuffer(data.buffer, data.byteOffset, data.length - 4);\n            }\n            //\n            // Ensure that the callback will not be called again in\n            // `PerMessageDeflate#cleanup()`.\n            //\n            this._deflate[kCallback] = null;\n            this._deflate[kTotalLength] = 0;\n            this._deflate[kBuffers] = [];\n            if (fin && this.params[`${endpoint}_no_context_takeover`]) {\n                this._deflate.reset();\n            }\n            callback(null, data);\n        });\n    }\n}\nmodule.exports = PerMessageDeflate;\n/**\n * The listener of the `zlib.DeflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function deflateOnData(chunk) {\n    this[kBuffers].push(chunk);\n    this[kTotalLength] += chunk.length;\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function inflateOnData(chunk) {\n    this[kTotalLength] += chunk.length;\n    if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {\n        this[kBuffers].push(chunk);\n        return;\n    }\n    this[kError] = new RangeError(\"Max payload size exceeded\");\n    this[kError].code = \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\";\n    this[kError][kStatusCode] = 1009;\n    this.removeListener(\"data\", inflateOnData);\n    //\n    // The choice to employ `zlib.reset()` over `zlib.close()` is dictated by the\n    // fact that in Node.js versions prior to 13.10.0, the callback for\n    // `zlib.flush()` is not called if `zlib.close()` is used. Utilizing\n    // `zlib.reset()` ensures that either the callback is invoked or an error is\n    // emitted.\n    //\n    this.reset();\n}\n/**\n * The listener of the `zlib.InflateRaw` stream `'error'` event.\n *\n * @param {Error} err The emitted error\n * @private\n */ function inflateOnError(err) {\n    //\n    // There is no need to call `Zlib#close()` as the handle is automatically\n    // closed when an error is emitted.\n    //\n    this[kPerMessageDeflate]._inflate = null;\n    if (this[kError]) {\n        this[kCallback](this[kError]);\n        return;\n    }\n    err[kStatusCode] = 1007;\n    this[kCallback](err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9wZXJtZXNzYWdlLWRlZmxhdGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxNQUFNQSxPQUFPQyxtQkFBT0EsQ0FBQztBQUVyQixNQUFNQyxhQUFhRCxtQkFBT0EsQ0FBQztBQUMzQixNQUFNRSxVQUFVRixtQkFBT0EsQ0FBQztBQUN4QixNQUFNLEVBQUVHLFdBQVcsRUFBRSxHQUFHSCxtQkFBT0EsQ0FBQztBQUVoQyxNQUFNSSxhQUFhQyxNQUFNLENBQUNDLE9BQU9DLE9BQU8sQ0FBQztBQUN6QyxNQUFNQyxVQUFVSCxPQUFPSSxJQUFJLENBQUM7SUFBQztJQUFNO0lBQU07SUFBTTtDQUFLO0FBQ3BELE1BQU1DLHFCQUFxQkosT0FBTztBQUNsQyxNQUFNSyxlQUFlTCxPQUFPO0FBQzVCLE1BQU1NLFlBQVlOLE9BQU87QUFDekIsTUFBTU8sV0FBV1AsT0FBTztBQUN4QixNQUFNUSxTQUFTUixPQUFPO0FBRXRCLEVBQUU7QUFDRix3RUFBd0U7QUFDeEUscUZBQXFGO0FBQ3JGLG1EQUFtRDtBQUNuRCxFQUFFO0FBQ0YscUVBQXFFO0FBQ3JFLEVBQUU7QUFDRixJQUFJUztBQUVKOztDQUVDLEdBQ0QsTUFBTUM7SUFDSjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0F1QkMsR0FDREMsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLEVBQUVDLFVBQVUsQ0FBRTtRQUN6QyxJQUFJLENBQUNDLFdBQVcsR0FBR0QsYUFBYTtRQUNoQyxJQUFJLENBQUNFLFFBQVEsR0FBR0osV0FBVyxDQUFDO1FBQzVCLElBQUksQ0FBQ0ssVUFBVSxHQUNiLElBQUksQ0FBQ0QsUUFBUSxDQUFDRSxTQUFTLEtBQUtDLFlBQVksSUFBSSxDQUFDSCxRQUFRLENBQUNFLFNBQVMsR0FBRztRQUNwRSxJQUFJLENBQUNFLFNBQVMsR0FBRyxDQUFDLENBQUNQO1FBQ25CLElBQUksQ0FBQ1EsUUFBUSxHQUFHO1FB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SSxDQUFDRDtRQUNwQjtJQUNGO0lBRUEsSUFBSSxDQUFDcEYsT0FBTyxHQUFHLElBQUlzRixXQUFXO0lBQzlCLElBQUksQ0FBQ3RGLE9BQU8sQ0FBQ3VGLElBQUksR0FBRztJQUNwQixJQUFJLENBQUN2RixPQUFPLENBQUNYLFlBQVksR0FBRztJQUM1QixJQUFJLENBQUNtRyxjQUFjLENBQUMsUUFBUW5CO0lBRTVCLEVBQUU7SUFDRiw2RUFBNkU7SUFDN0UsbUVBQW1FO0lBQ25FLG9FQUFvRTtJQUNwRSw0RUFBNEU7SUFDNUUsV0FBVztJQUNYLEVBQUU7SUFDRixJQUFJLENBQUNNLEtBQUs7QUFDWjtBQUVBOzs7OztDQUtDLEdBQ0QsU0FBU1AsZUFBZVYsR0FBRztJQUN6QixFQUFFO0lBQ0YseUVBQXlFO0lBQ3pFLG1DQUFtQztJQUNuQyxFQUFFO0lBQ0YsSUFBSSxDQUFDOUQsbUJBQW1CLENBQUNrQixRQUFRLEdBQUc7SUFFcEMsSUFBSSxJQUFJLENBQUNkLE9BQU8sRUFBRTtRQUNoQixJQUFJLENBQUNGLFVBQVUsQ0FBQyxJQUFJLENBQUNFLE9BQU87UUFDNUI7SUFDRjtJQUVBMEQsR0FBRyxDQUFDckUsWUFBWSxHQUFHO0lBQ25CLElBQUksQ0FBQ1MsVUFBVSxDQUFDNEQ7QUFDbEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyYWZvcm1hdGlvbi8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvd3MvbGliL3Blcm1lc3NhZ2UtZGVmbGF0ZS5qcz9hNmE4Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgemxpYiA9IHJlcXVpcmUoJ3psaWInKTtcblxuY29uc3QgYnVmZmVyVXRpbCA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IExpbWl0ZXIgPSByZXF1aXJlKCcuL2xpbWl0ZXInKTtcbmNvbnN0IHsga1N0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbmNvbnN0IEZhc3RCdWZmZXIgPSBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdO1xuY29uc3QgVFJBSUxFUiA9IEJ1ZmZlci5mcm9tKFsweDAwLCAweDAwLCAweGZmLCAweGZmXSk7XG5jb25zdCBrUGVyTWVzc2FnZURlZmxhdGUgPSBTeW1ib2woJ3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qga1RvdGFsTGVuZ3RoID0gU3ltYm9sKCd0b3RhbC1sZW5ndGgnKTtcbmNvbnN0IGtDYWxsYmFjayA9IFN5bWJvbCgnY2FsbGJhY2snKTtcbmNvbnN0IGtCdWZmZXJzID0gU3ltYm9sKCdidWZmZXJzJyk7XG5jb25zdCBrRXJyb3IgPSBTeW1ib2woJ2Vycm9yJyk7XG5cbi8vXG4vLyBXZSBsaW1pdCB6bGliIGNvbmN1cnJlbmN5LCB3aGljaCBwcmV2ZW50cyBzZXZlcmUgbWVtb3J5IGZyYWdtZW50YXRpb25cbi8vIGFzIGRvY3VtZW50ZWQgaW4gaHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlL2lzc3Vlcy84ODcxI2lzc3VlY29tbWVudC0yNTA5MTU5MTNcbi8vIGFuZCBodHRwczovL2dpdGh1Yi5jb20vd2Vic29ja2V0cy93cy9pc3N1ZXMvMTIwMlxuLy9cbi8vIEludGVudGlvbmFsbHkgZ2xvYmFsOyBpdCdzIHRoZSBnbG9iYWwgdGhyZWFkIHBvb2wgdGhhdCdzIGFuIGlzc3VlLlxuLy9cbmxldCB6bGliTGltaXRlcjtcblxuLyoqXG4gKiBwZXJtZXNzYWdlLWRlZmxhdGUgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFBlck1lc3NhZ2VEZWZsYXRlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBQZXJNZXNzYWdlRGVmbGF0ZSBpbnN0YW5jZS5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25maWd1cmF0aW9uIG9wdGlvbnNcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzXSBBZHZlcnRpc2Ugc3VwcG9ydFxuICAgKiAgICAgZm9yLCBvciByZXF1ZXN0LCBhIGN1c3RvbSBjbGllbnQgd2luZG93IHNpemVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnROb0NvbnRleHRUYWtlb3Zlcj1mYWxzZV0gQWR2ZXJ0aXNlL1xuICAgKiAgICAgYWNrbm93bGVkZ2UgZGlzYWJsaW5nIG9mIGNsaWVudCBjb250ZXh0IHRha2VvdmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5jb25jdXJyZW5jeUxpbWl0PTEwXSBUaGUgbnVtYmVyIG9mIGNvbmN1cnJlbnRcbiAgICogICAgIGNhbGxzIHRvIHpsaWJcbiAgICogQHBhcmFtIHsoQm9vbGVhbnxOdW1iZXIpfSBbb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzXSBSZXF1ZXN0L2NvbmZpcm0gdGhlXG4gICAqICAgICB1c2Ugb2YgYSBjdXN0b20gc2VydmVyIHdpbmRvdyBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXI9ZmFsc2VdIFJlcXVlc3QvYWNjZXB0XG4gICAqICAgICBkaXNhYmxpbmcgb2Ygc2VydmVyIGNvbnRleHQgdGFrZW92ZXJcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnRocmVzaG9sZD0xMDI0XSBTaXplIChpbiBieXRlcykgYmVsb3cgd2hpY2hcbiAgICogICAgIG1lc3NhZ2VzIHNob3VsZCBub3QgYmUgY29tcHJlc3NlZCBpZiBjb250ZXh0IHRha2VvdmVyIGlzIGRpc2FibGVkXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBkZWZsYXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnNdIE9wdGlvbnMgdG8gcGFzcyB0byB6bGliIG9uXG4gICAqICAgICBpbmZsYXRlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2lzU2VydmVyPWZhbHNlXSBDcmVhdGUgdGhlIGluc3RhbmNlIGluIGVpdGhlciBzZXJ2ZXIgb3JcbiAgICogICAgIGNsaWVudCBtb2RlXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2UgbGVuZ3RoXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBpc1NlcnZlciwgbWF4UGF5bG9hZCkge1xuICAgIHRoaXMuX21heFBheWxvYWQgPSBtYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICB0aGlzLl90aHJlc2hvbGQgPVxuICAgICAgdGhpcy5fb3B0aW9ucy50aHJlc2hvbGQgIT09IHVuZGVmaW5lZCA/IHRoaXMuX29wdGlvbnMudGhyZXNob2xkIDogMTAyNDtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhaXNTZXJ2ZXI7XG4gICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG4gICAgdGhpcy5faW5mbGF0ZSA9IG51bGw7XG5cbiAgICB0aGlzLnBhcmFtcyA9IG51bGw7XG5cbiAgICBpZiAoIXpsaWJMaW1pdGVyKSB7XG4gICAgICBjb25zdCBjb25jdXJyZW5jeSA9XG4gICAgICAgIHRoaXMuX29wdGlvbnMuY29uY3VycmVuY3lMaW1pdCAhPT0gdW5kZWZpbmVkXG4gICAgICAgICAgPyB0aGlzLl9vcHRpb25zLmNvbmN1cnJlbmN5TGltaXRcbiAgICAgICAgICA6IDEwO1xuICAgICAgemxpYkxpbWl0ZXIgPSBuZXcgTGltaXRlcihjb25jdXJyZW5jeSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtTdHJpbmd9XG4gICAqL1xuICBzdGF0aWMgZ2V0IGV4dGVuc2lvbk5hbWUoKSB7XG4gICAgcmV0dXJuICdwZXJtZXNzYWdlLWRlZmxhdGUnO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEByZXR1cm4ge09iamVjdH0gRXh0ZW5zaW9uIHBhcmFtZXRlcnNcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgb2ZmZXIoKSB7XG4gICAgY29uc3QgcGFyYW1zID0ge307XG5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3Zlcikge1xuICAgICAgcGFyYW1zLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIHBhcmFtcy5jbGllbnRfbm9fY29udGV4dF90YWtlb3ZlciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh0aGlzLl9vcHRpb25zLnNlcnZlck1heFdpbmRvd0JpdHMpIHtcbiAgICAgIHBhcmFtcy5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gdGhpcy5fb3B0aW9ucy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cyA9PSBudWxsKSB7XG4gICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgYW4gZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyL3Jlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0FycmF5fSBjb25maWd1cmF0aW9ucyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVycy9yZXBvbnNlXG4gICAqIEByZXR1cm4ge09iamVjdH0gQWNjZXB0ZWQgY29uZmlndXJhdGlvblxuICAgKiBAcHVibGljXG4gICAqL1xuICBhY2NlcHQoY29uZmlndXJhdGlvbnMpIHtcbiAgICBjb25maWd1cmF0aW9ucyA9IHRoaXMubm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKTtcblxuICAgIHRoaXMucGFyYW1zID0gdGhpcy5faXNTZXJ2ZXJcbiAgICAgID8gdGhpcy5hY2NlcHRBc1NlcnZlcihjb25maWd1cmF0aW9ucylcbiAgICAgIDogdGhpcy5hY2NlcHRBc0NsaWVudChjb25maWd1cmF0aW9ucyk7XG5cbiAgICByZXR1cm4gdGhpcy5wYXJhbXM7XG4gIH1cblxuICAvKipcbiAgICogUmVsZWFzZXMgYWxsIHJlc291cmNlcyB1c2VkIGJ5IHRoZSBleHRlbnNpb24uXG4gICAqXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuX2luZmxhdGUpIHtcbiAgICAgIHRoaXMuX2luZmxhdGUuY2xvc2UoKTtcbiAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9kZWZsYXRlKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5jbG9zZSgpO1xuICAgICAgdGhpcy5fZGVmbGF0ZSA9IG51bGw7XG5cbiAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayhcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkJ1xuICAgICAgICAgIClcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogIEFjY2VwdCBhbiBleHRlbnNpb24gbmVnb3RpYXRpb24gb2ZmZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IG9mZmVycyBUaGUgZXh0ZW5zaW9uIG5lZ290aWF0aW9uIG9mZmVyc1xuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzU2VydmVyKG9mZmVycykge1xuICAgIGNvbnN0IG9wdHMgPSB0aGlzLl9vcHRpb25zO1xuICAgIGNvbnN0IGFjY2VwdGVkID0gb2ZmZXJzLmZpbmQoKHBhcmFtcykgPT4ge1xuICAgICAgaWYgKFxuICAgICAgICAob3B0cy5zZXJ2ZXJOb0NvbnRleHRUYWtlb3ZlciA9PT0gZmFsc2UgJiZcbiAgICAgICAgICBwYXJhbXMuc2VydmVyX25vX2NvbnRleHRfdGFrZW92ZXIpIHx8XG4gICAgICAgIChwYXJhbXMuc2VydmVyX21heF93aW5kb3dfYml0cyAmJlxuICAgICAgICAgIChvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09IGZhbHNlIHx8XG4gICAgICAgICAgICAodHlwZW9mIG9wdHMuc2VydmVyTWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgICAgICAgb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzID4gcGFyYW1zLnNlcnZlcl9tYXhfd2luZG93X2JpdHMpKSkgfHxcbiAgICAgICAgKHR5cGVvZiBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgICAgIXBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG5cbiAgICBpZiAoIWFjY2VwdGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vbmUgb2YgdGhlIGV4dGVuc2lvbiBvZmZlcnMgY2FuIGJlIGFjY2VwdGVkJyk7XG4gICAgfVxuXG4gICAgaWYgKG9wdHMuc2VydmVyTm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLnNlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKG9wdHMuY2xpZW50Tm9Db250ZXh0VGFrZW92ZXIpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRzLnNlcnZlck1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInKSB7XG4gICAgICBhY2NlcHRlZC5zZXJ2ZXJfbWF4X3dpbmRvd19iaXRzID0gb3B0cy5zZXJ2ZXJNYXhXaW5kb3dCaXRzO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gJ251bWJlcicpIHtcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPSBvcHRzLmNsaWVudE1heFdpbmRvd0JpdHM7XG4gICAgfSBlbHNlIGlmIChcbiAgICAgIGFjY2VwdGVkLmNsaWVudF9tYXhfd2luZG93X2JpdHMgPT09IHRydWUgfHxcbiAgICAgIG9wdHMuY2xpZW50TWF4V2luZG93Qml0cyA9PT0gZmFsc2VcbiAgICApIHtcbiAgICAgIGRlbGV0ZSBhY2NlcHRlZC5jbGllbnRfbWF4X3dpbmRvd19iaXRzO1xuICAgIH1cblxuICAgIHJldHVybiBhY2NlcHRlZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBBY2NlcHQgdGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZS5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gcmVzcG9uc2UgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiByZXNwb25zZVxuICAgKiBAcmV0dXJuIHtPYmplY3R9IEFjY2VwdGVkIGNvbmZpZ3VyYXRpb25cbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjY2VwdEFzQ2xpZW50KHJlc3BvbnNlKSB7XG4gICAgY29uc3QgcGFyYW1zID0gcmVzcG9uc2VbMF07XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLl9vcHRpb25zLmNsaWVudE5vQ29udGV4dFRha2VvdmVyID09PSBmYWxzZSAmJlxuICAgICAgcGFyYW1zLmNsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgcGFyYW1ldGVyIFwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXJcIicpO1xuICAgIH1cblxuICAgIGlmICghcGFyYW1zLmNsaWVudF9tYXhfd2luZG93X2JpdHMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSAnbnVtYmVyJykge1xuICAgICAgICBwYXJhbXMuY2xpZW50X21heF93aW5kb3dfYml0cyA9IHRoaXMuX29wdGlvbnMuY2xpZW50TWF4V2luZG93Qml0cztcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKFxuICAgICAgdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzID09PSBmYWxzZSB8fFxuICAgICAgKHR5cGVvZiB0aGlzLl9vcHRpb25zLmNsaWVudE1heFdpbmRvd0JpdHMgPT09ICdudW1iZXInICYmXG4gICAgICAgIHBhcmFtcy5jbGllbnRfbWF4X3dpbmRvd19iaXRzID4gdGhpcy5fb3B0aW9ucy5jbGllbnRNYXhXaW5kb3dCaXRzKVxuICAgICkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5leHBlY3RlZCBvciBpbnZhbGlkIHBhcmFtZXRlciBcImNsaWVudF9tYXhfd2luZG93X2JpdHNcIidcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhcmFtcztcbiAgfVxuXG4gIC8qKlxuICAgKiBOb3JtYWxpemUgcGFyYW1ldGVycy5cbiAgICpcbiAgICogQHBhcmFtIHtBcnJheX0gY29uZmlndXJhdGlvbnMgVGhlIGV4dGVuc2lvbiBuZWdvdGlhdGlvbiBvZmZlcnMvcmVwb25zZVxuICAgKiBAcmV0dXJuIHtBcnJheX0gVGhlIG9mZmVycy9yZXNwb25zZSB3aXRoIG5vcm1hbGl6ZWQgcGFyYW1ldGVyc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgbm9ybWFsaXplUGFyYW1zKGNvbmZpZ3VyYXRpb25zKSB7XG4gICAgY29uZmlndXJhdGlvbnMuZm9yRWFjaCgocGFyYW1zKSA9PiB7XG4gICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBwYXJhbXNba2V5XTtcblxuICAgICAgICBpZiAodmFsdWUubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgUGFyYW1ldGVyIFwiJHtrZXl9XCIgbXVzdCBoYXZlIG9ubHkgYSBzaW5nbGUgdmFsdWVgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2NsaWVudF9tYXhfd2luZG93X2JpdHMnKSB7XG4gICAgICAgICAgaWYgKHZhbHVlICE9PSB0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobnVtKSB8fCBudW0gPCA4IHx8IG51bSA+IDE1KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMuX2lzU2VydmVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgSW52YWxpZCB2YWx1ZSBmb3IgcGFyYW1ldGVyIFwiJHtrZXl9XCI6ICR7dmFsdWV9YFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnc2VydmVyX21heF93aW5kb3dfYml0cycpIHtcbiAgICAgICAgICBjb25zdCBudW0gPSArdmFsdWU7XG4gICAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKG51bSkgfHwgbnVtIDwgOCB8fCBudW0gPiAxNSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICAgYEludmFsaWQgdmFsdWUgZm9yIHBhcmFtZXRlciBcIiR7a2V5fVwiOiAke3ZhbHVlfWBcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhbHVlID0gbnVtO1xuICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3NlcnZlcl9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICApIHtcbiAgICAgICAgICBpZiAodmFsdWUgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgXCIke2tleX1cIjogJHt2YWx1ZX1gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gcGFyYW1ldGVyIFwiJHtrZXl9XCJgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBhcmFtc1trZXldID0gdmFsdWU7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHJldHVybiBjb25maWd1cmF0aW9ucztcbiAgfVxuXG4gIC8qKlxuICAgKiBEZWNvbXByZXNzIGRhdGEuIENvbmN1cnJlbmN5IGxpbWl0ZWQuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBkZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2RlY29tcHJlc3MoZGF0YSwgZmluLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgZG9uZSgpO1xuICAgICAgICBjYWxsYmFjayhlcnIsIHJlc3VsdCk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wcmVzcyBkYXRhLiBDb25jdXJyZW5jeSBsaW1pdGVkLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBEYXRhIHRvIGNvbXByZXNzXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gZmluIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0aGlzIGlzIHRoZSBsYXN0IGZyYWdtZW50XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICB6bGliTGltaXRlci5hZGQoKGRvbmUpID0+IHtcbiAgICAgIHRoaXMuX2NvbXByZXNzKGRhdGEsIGZpbiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gICAgICAgIGRvbmUoKTtcbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXN1bHQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzcyBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBDb21wcmVzc2VkIGRhdGFcbiAgICogQHBhcmFtIHtCb29sZWFufSBmaW4gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRoaXMgaXMgdGhlIGxhc3QgZnJhZ21lbnRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9kZWNvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ2NsaWVudCcgOiAnc2VydmVyJztcblxuICAgIGlmICghdGhpcy5faW5mbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9pbmZsYXRlID0gemxpYi5jcmVhdGVJbmZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliSW5mbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faW5mbGF0ZVtrUGVyTWVzc2FnZURlZmxhdGVdID0gdGhpcztcbiAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXSA9IDA7XG4gICAgICB0aGlzLl9pbmZsYXRlW2tCdWZmZXJzXSA9IFtdO1xuICAgICAgdGhpcy5faW5mbGF0ZS5vbignZXJyb3InLCBpbmZsYXRlT25FcnJvcik7XG4gICAgICB0aGlzLl9pbmZsYXRlLm9uKCdkYXRhJywgaW5mbGF0ZU9uRGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5faW5mbGF0ZVtrQ2FsbGJhY2tdID0gY2FsbGJhY2s7XG5cbiAgICB0aGlzLl9pbmZsYXRlLndyaXRlKGRhdGEpO1xuICAgIGlmIChmaW4pIHRoaXMuX2luZmxhdGUud3JpdGUoVFJBSUxFUik7XG5cbiAgICB0aGlzLl9pbmZsYXRlLmZsdXNoKCgpID0+IHtcbiAgICAgIGNvbnN0IGVyciA9IHRoaXMuX2luZmxhdGVba0Vycm9yXTtcblxuICAgICAgaWYgKGVycikge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGRhdGEgPSBidWZmZXJVdGlsLmNvbmNhdChcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10sXG4gICAgICAgIHRoaXMuX2luZmxhdGVba1RvdGFsTGVuZ3RoXVxuICAgICAgKTtcblxuICAgICAgaWYgKHRoaXMuX2luZmxhdGUuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkge1xuICAgICAgICB0aGlzLl9pbmZsYXRlLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuX2luZmxhdGUgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrVG90YWxMZW5ndGhdID0gMDtcbiAgICAgICAgdGhpcy5faW5mbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgICBpZiAoZmluICYmIHRoaXMucGFyYW1zW2Ake2VuZHBvaW50fV9ub19jb250ZXh0X3Rha2VvdmVyYF0pIHtcbiAgICAgICAgICB0aGlzLl9pbmZsYXRlLnJlc2V0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHJlc3MgZGF0YS5cbiAgICpcbiAgICogQHBhcmFtIHsoQnVmZmVyfFN0cmluZyl9IGRhdGEgRGF0YSB0byBjb21wcmVzc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGZpbiBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdGhpcyBpcyB0aGUgbGFzdCBmcmFnbWVudFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2NvbXByZXNzKGRhdGEsIGZpbiwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuX2lzU2VydmVyID8gJ3NlcnZlcicgOiAnY2xpZW50JztcblxuICAgIGlmICghdGhpcy5fZGVmbGF0ZSkge1xuICAgICAgY29uc3Qga2V5ID0gYCR7ZW5kcG9pbnR9X21heF93aW5kb3dfYml0c2A7XG4gICAgICBjb25zdCB3aW5kb3dCaXRzID1cbiAgICAgICAgdHlwZW9mIHRoaXMucGFyYW1zW2tleV0gIT09ICdudW1iZXInXG4gICAgICAgICAgPyB6bGliLlpfREVGQVVMVF9XSU5ET1dCSVRTXG4gICAgICAgICAgOiB0aGlzLnBhcmFtc1trZXldO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlID0gemxpYi5jcmVhdGVEZWZsYXRlUmF3KHtcbiAgICAgICAgLi4udGhpcy5fb3B0aW9ucy56bGliRGVmbGF0ZU9wdGlvbnMsXG4gICAgICAgIHdpbmRvd0JpdHNcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgdGhpcy5fZGVmbGF0ZS5vbignZGF0YScsIGRlZmxhdGVPbkRhdGEpO1xuICAgIH1cblxuICAgIHRoaXMuX2RlZmxhdGVba0NhbGxiYWNrXSA9IGNhbGxiYWNrO1xuXG4gICAgdGhpcy5fZGVmbGF0ZS53cml0ZShkYXRhKTtcbiAgICB0aGlzLl9kZWZsYXRlLmZsdXNoKHpsaWIuWl9TWU5DX0ZMVVNILCAoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX2RlZmxhdGUpIHtcbiAgICAgICAgLy9cbiAgICAgICAgLy8gVGhlIGRlZmxhdGUgc3RyZWFtIHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgcHJvY2Vzc2VkLlxuICAgICAgICAvL1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGxldCBkYXRhID0gYnVmZmVyVXRpbC5jb25jYXQoXG4gICAgICAgIHRoaXMuX2RlZmxhdGVba0J1ZmZlcnNdLFxuICAgICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF1cbiAgICAgICk7XG5cbiAgICAgIGlmIChmaW4pIHtcbiAgICAgICAgZGF0YSA9IG5ldyBGYXN0QnVmZmVyKGRhdGEuYnVmZmVyLCBkYXRhLmJ5dGVPZmZzZXQsIGRhdGEubGVuZ3RoIC0gNCk7XG4gICAgICB9XG5cbiAgICAgIC8vXG4gICAgICAvLyBFbnN1cmUgdGhhdCB0aGUgY2FsbGJhY2sgd2lsbCBub3QgYmUgY2FsbGVkIGFnYWluIGluXG4gICAgICAvLyBgUGVyTWVzc2FnZURlZmxhdGUjY2xlYW51cCgpYC5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9kZWZsYXRlW2tDYWxsYmFja10gPSBudWxsO1xuXG4gICAgICB0aGlzLl9kZWZsYXRlW2tUb3RhbExlbmd0aF0gPSAwO1xuICAgICAgdGhpcy5fZGVmbGF0ZVtrQnVmZmVyc10gPSBbXTtcblxuICAgICAgaWYgKGZpbiAmJiB0aGlzLnBhcmFtc1tgJHtlbmRwb2ludH1fbm9fY29udGV4dF90YWtlb3ZlcmBdKSB7XG4gICAgICAgIHRoaXMuX2RlZmxhdGUucmVzZXQoKTtcbiAgICAgIH1cblxuICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgfSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBQZXJNZXNzYWdlRGVmbGF0ZTtcblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGB6bGliLkRlZmxhdGVSYXdgIHN0cmVhbSBgJ2RhdGEnYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgQSBjaHVuayBvZiBkYXRhXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWZsYXRlT25EYXRhKGNodW5rKSB7XG4gIHRoaXNba0J1ZmZlcnNdLnB1c2goY2h1bmspO1xuICB0aGlzW2tUb3RhbExlbmd0aF0gKz0gY2h1bmsubGVuZ3RoO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkRhdGEoY2h1bmspIHtcbiAgdGhpc1trVG90YWxMZW5ndGhdICs9IGNodW5rLmxlbmd0aDtcblxuICBpZiAoXG4gICAgdGhpc1trUGVyTWVzc2FnZURlZmxhdGVdLl9tYXhQYXlsb2FkIDwgMSB8fFxuICAgIHRoaXNba1RvdGFsTGVuZ3RoXSA8PSB0aGlzW2tQZXJNZXNzYWdlRGVmbGF0ZV0uX21heFBheWxvYWRcbiAgKSB7XG4gICAgdGhpc1trQnVmZmVyc10ucHVzaChjaHVuayk7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdGhpc1trRXJyb3JdID0gbmV3IFJhbmdlRXJyb3IoJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnKTtcbiAgdGhpc1trRXJyb3JdLmNvZGUgPSAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJztcbiAgdGhpc1trRXJyb3JdW2tTdGF0dXNDb2RlXSA9IDEwMDk7XG4gIHRoaXMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBpbmZsYXRlT25EYXRhKTtcblxuICAvL1xuICAvLyBUaGUgY2hvaWNlIHRvIGVtcGxveSBgemxpYi5yZXNldCgpYCBvdmVyIGB6bGliLmNsb3NlKClgIGlzIGRpY3RhdGVkIGJ5IHRoZVxuICAvLyBmYWN0IHRoYXQgaW4gTm9kZS5qcyB2ZXJzaW9ucyBwcmlvciB0byAxMy4xMC4wLCB0aGUgY2FsbGJhY2sgZm9yXG4gIC8vIGB6bGliLmZsdXNoKClgIGlzIG5vdCBjYWxsZWQgaWYgYHpsaWIuY2xvc2UoKWAgaXMgdXNlZC4gVXRpbGl6aW5nXG4gIC8vIGB6bGliLnJlc2V0KClgIGVuc3VyZXMgdGhhdCBlaXRoZXIgdGhlIGNhbGxiYWNrIGlzIGludm9rZWQgb3IgYW4gZXJyb3IgaXNcbiAgLy8gZW1pdHRlZC5cbiAgLy9cbiAgdGhpcy5yZXNldCgpO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYHpsaWIuSW5mbGF0ZVJhd2Agc3RyZWFtIGAnZXJyb3InYCBldmVudC5cbiAqXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluZmxhdGVPbkVycm9yKGVycikge1xuICAvL1xuICAvLyBUaGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgYFpsaWIjY2xvc2UoKWAgYXMgdGhlIGhhbmRsZSBpcyBhdXRvbWF0aWNhbGx5XG4gIC8vIGNsb3NlZCB3aGVuIGFuIGVycm9yIGlzIGVtaXR0ZWQuXG4gIC8vXG4gIHRoaXNba1Blck1lc3NhZ2VEZWZsYXRlXS5faW5mbGF0ZSA9IG51bGw7XG5cbiAgaWYgKHRoaXNba0Vycm9yXSkge1xuICAgIHRoaXNba0NhbGxiYWNrXSh0aGlzW2tFcnJvcl0pO1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGVycltrU3RhdHVzQ29kZV0gPSAxMDA3O1xuICB0aGlzW2tDYWxsYmFja10oZXJyKTtcbn1cbiJdLCJuYW1lcyI6WyJ6bGliIiwicmVxdWlyZSIsImJ1ZmZlclV0aWwiLCJMaW1pdGVyIiwia1N0YXR1c0NvZGUiLCJGYXN0QnVmZmVyIiwiQnVmZmVyIiwiU3ltYm9sIiwic3BlY2llcyIsIlRSQUlMRVIiLCJmcm9tIiwia1Blck1lc3NhZ2VEZWZsYXRlIiwia1RvdGFsTGVuZ3RoIiwia0NhbGxiYWNrIiwia0J1ZmZlcnMiLCJrRXJyb3IiLCJ6bGliTGltaXRlciIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiaXNTZXJ2ZXIiLCJtYXhQYXlsb2FkIiwiX21heFBheWxvYWQiLCJfb3B0aW9ucyIsIl90aHJlc2hvbGQiLCJ0aHJlc2hvbGQiLCJ1bmRlZmluZWQiLCJfaXNTZXJ2ZXIiLCJfZGVmbGF0ZSIsIl9pbmZsYXRlIiwicGFyYW1zIiwiY29uY3VycmVuY3kiLCJjb25jdXJyZW5jeUxpbWl0IiwiZXh0ZW5zaW9uTmFtZSIsIm9mZmVyIiwic2VydmVyTm9Db250ZXh0VGFrZW92ZXIiLCJzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlciIsImNsaWVudE5vQ29udGV4dFRha2VvdmVyIiwiY2xpZW50X25vX2NvbnRleHRfdGFrZW92ZXIiLCJzZXJ2ZXJNYXhXaW5kb3dCaXRzIiwic2VydmVyX21heF93aW5kb3dfYml0cyIsImNsaWVudE1heFdpbmRvd0JpdHMiLCJjbGllbnRfbWF4X3dpbmRvd19iaXRzIiwiYWNjZXB0IiwiY29uZmlndXJhdGlvbnMiLCJub3JtYWxpemVQYXJhbXMiLCJhY2NlcHRBc1NlcnZlciIsImFjY2VwdEFzQ2xpZW50IiwiY2xlYW51cCIsImNsb3NlIiwiY2FsbGJhY2siLCJFcnJvciIsIm9mZmVycyIsIm9wdHMiLCJhY2NlcHRlZCIsImZpbmQiLCJyZXNwb25zZSIsImZvckVhY2giLCJPYmplY3QiLCJrZXlzIiwia2V5IiwidmFsdWUiLCJsZW5ndGgiLCJudW0iLCJOdW1iZXIiLCJpc0ludGVnZXIiLCJUeXBlRXJyb3IiLCJkZWNvbXByZXNzIiwiZGF0YSIsImZpbiIsImFkZCIsImRvbmUiLCJfZGVjb21wcmVzcyIsImVyciIsInJlc3VsdCIsImNvbXByZXNzIiwiX2NvbXByZXNzIiwiZW5kcG9pbnQiLCJ3aW5kb3dCaXRzIiwiWl9ERUZBVUxUX1dJTkRPV0JJVFMiLCJjcmVhdGVJbmZsYXRlUmF3IiwiemxpYkluZmxhdGVPcHRpb25zIiwib24iLCJpbmZsYXRlT25FcnJvciIsImluZmxhdGVPbkRhdGEiLCJ3cml0ZSIsImZsdXNoIiwiY29uY2F0IiwiX3JlYWRhYmxlU3RhdGUiLCJlbmRFbWl0dGVkIiwicmVzZXQiLCJjcmVhdGVEZWZsYXRlUmF3IiwiemxpYkRlZmxhdGVPcHRpb25zIiwiZGVmbGF0ZU9uRGF0YSIsIlpfU1lOQ19GTFVTSCIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJtb2R1bGUiLCJleHBvcnRzIiwiY2h1bmsiLCJwdXNoIiwiUmFuZ2VFcnJvciIsImNvZGUiLCJyZW1vdmVMaXN0ZW5lciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/receiver.js":
/*!*********************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/receiver.js ***!
  \*********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { Writable } = __webpack_require__(/*! stream */ \"stream\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js\");\nconst { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\nconst { concat, toArrayBuffer, unmask } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js\");\nconst { isValidStatusCode, isValidUTF8 } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/validation.js\");\nconst FastBuffer = Buffer[Symbol.species];\nconst GET_INFO = 0;\nconst GET_PAYLOAD_LENGTH_16 = 1;\nconst GET_PAYLOAD_LENGTH_64 = 2;\nconst GET_MASK = 3;\nconst GET_DATA = 4;\nconst INFLATING = 5;\nconst DEFER_EVENT = 6;\n/**\n * HyBi Receiver implementation.\n *\n * @extends Writable\n */ class Receiver extends Writable {\n    /**\n   * Creates a Receiver instance.\n   *\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {String} [options.binaryType=nodebuffer] The type for binary data\n   * @param {Object} [options.extensions] An object containing the negotiated\n   *     extensions\n   * @param {Boolean} [options.isServer=false] Specifies whether to operate in\n   *     client or server mode\n   * @param {Number} [options.maxPayload=0] The maximum allowed message length\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   */ constructor(options = {}){\n        super();\n        this._allowSynchronousEvents = options.allowSynchronousEvents !== undefined ? options.allowSynchronousEvents : true;\n        this._binaryType = options.binaryType || BINARY_TYPES[0];\n        this._extensions = options.extensions || {};\n        this._isServer = !!options.isServer;\n        this._maxPayload = options.maxPayload | 0;\n        this._skipUTF8Validation = !!options.skipUTF8Validation;\n        this[kWebSocket] = undefined;\n        this._bufferedBytes = 0;\n        this._buffers = [];\n        this._compressed = false;\n        this._payloadLength = 0;\n        this._mask = undefined;\n        this._fragmented = 0;\n        this._masked = false;\n        this._fin = false;\n        this._opcode = 0;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragments = [];\n        this._errored = false;\n        this._loop = false;\n        this._state = GET_INFO;\n    }\n    /**\n   * Implements `Writable.prototype._write()`.\n   *\n   * @param {Buffer} chunk The chunk of data to write\n   * @param {String} encoding The character encoding of `chunk`\n   * @param {Function} cb Callback\n   * @private\n   */ _write(chunk, encoding, cb) {\n        if (this._opcode === 0x08 && this._state == GET_INFO) return cb();\n        this._bufferedBytes += chunk.length;\n        this._buffers.push(chunk);\n        this.startLoop(cb);\n    }\n    /**\n   * Consumes `n` bytes from the buffered data.\n   *\n   * @param {Number} n The number of bytes to consume\n   * @return {Buffer} The consumed bytes\n   * @private\n   */ consume(n) {\n        this._bufferedBytes -= n;\n        if (n === this._buffers[0].length) return this._buffers.shift();\n        if (n < this._buffers[0].length) {\n            const buf = this._buffers[0];\n            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n            return new FastBuffer(buf.buffer, buf.byteOffset, n);\n        }\n        const dst = Buffer.allocUnsafe(n);\n        do {\n            const buf = this._buffers[0];\n            const offset = dst.length - n;\n            if (n >= buf.length) {\n                dst.set(this._buffers.shift(), offset);\n            } else {\n                dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);\n                this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);\n            }\n            n -= buf.length;\n        }while (n > 0);\n        return dst;\n    }\n    /**\n   * Starts the parsing loop.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ startLoop(cb) {\n        this._loop = true;\n        do {\n            switch(this._state){\n                case GET_INFO:\n                    this.getInfo(cb);\n                    break;\n                case GET_PAYLOAD_LENGTH_16:\n                    this.getPayloadLength16(cb);\n                    break;\n                case GET_PAYLOAD_LENGTH_64:\n                    this.getPayloadLength64(cb);\n                    break;\n                case GET_MASK:\n                    this.getMask();\n                    break;\n                case GET_DATA:\n                    this.getData(cb);\n                    break;\n                case INFLATING:\n                case DEFER_EVENT:\n                    this._loop = false;\n                    return;\n            }\n        }while (this._loop);\n        if (!this._errored) cb();\n    }\n    /**\n   * Reads the first two bytes of a frame.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getInfo(cb) {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(2);\n        if ((buf[0] & 0x30) !== 0x00) {\n            const error = this.createError(RangeError, \"RSV2 and RSV3 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_2_3\");\n            cb(error);\n            return;\n        }\n        const compressed = (buf[0] & 0x40) === 0x40;\n        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {\n            const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n            cb(error);\n            return;\n        }\n        this._fin = (buf[0] & 0x80) === 0x80;\n        this._opcode = buf[0] & 0x0f;\n        this._payloadLength = buf[1] & 0x7f;\n        if (this._opcode === 0x00) {\n            if (compressed) {\n                const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n                cb(error);\n                return;\n            }\n            if (!this._fragmented) {\n                const error = this.createError(RangeError, \"invalid opcode 0\", true, 1002, \"WS_ERR_INVALID_OPCODE\");\n                cb(error);\n                return;\n            }\n            this._opcode = this._fragmented;\n        } else if (this._opcode === 0x01 || this._opcode === 0x02) {\n            if (this._fragmented) {\n                const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n                cb(error);\n                return;\n            }\n            this._compressed = compressed;\n        } else if (this._opcode > 0x07 && this._opcode < 0x0b) {\n            if (!this._fin) {\n                const error = this.createError(RangeError, \"FIN must be set\", true, 1002, \"WS_ERR_EXPECTED_FIN\");\n                cb(error);\n                return;\n            }\n            if (compressed) {\n                const error = this.createError(RangeError, \"RSV1 must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_RSV_1\");\n                cb(error);\n                return;\n            }\n            if (this._payloadLength > 0x7d || this._opcode === 0x08 && this._payloadLength === 1) {\n                const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, \"WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH\");\n                cb(error);\n                return;\n            }\n        } else {\n            const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, \"WS_ERR_INVALID_OPCODE\");\n            cb(error);\n            return;\n        }\n        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;\n        this._masked = (buf[1] & 0x80) === 0x80;\n        if (this._isServer) {\n            if (!this._masked) {\n                const error = this.createError(RangeError, \"MASK must be set\", true, 1002, \"WS_ERR_EXPECTED_MASK\");\n                cb(error);\n                return;\n            }\n        } else if (this._masked) {\n            const error = this.createError(RangeError, \"MASK must be clear\", true, 1002, \"WS_ERR_UNEXPECTED_MASK\");\n            cb(error);\n            return;\n        }\n        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;\n        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;\n        else this.haveLength(cb);\n    }\n    /**\n   * Gets extended payload length (7+16).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getPayloadLength16(cb) {\n        if (this._bufferedBytes < 2) {\n            this._loop = false;\n            return;\n        }\n        this._payloadLength = this.consume(2).readUInt16BE(0);\n        this.haveLength(cb);\n    }\n    /**\n   * Gets extended payload length (7+64).\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getPayloadLength64(cb) {\n        if (this._bufferedBytes < 8) {\n            this._loop = false;\n            return;\n        }\n        const buf = this.consume(8);\n        const num = buf.readUInt32BE(0);\n        //\n        // The maximum safe integer in JavaScript is 2^53 - 1. An error is returned\n        // if payload length is greater than this number.\n        //\n        if (num > Math.pow(2, 53 - 32) - 1) {\n            const error = this.createError(RangeError, \"Unsupported WebSocket frame: payload length > 2^53 - 1\", false, 1009, \"WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH\");\n            cb(error);\n            return;\n        }\n        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);\n        this.haveLength(cb);\n    }\n    /**\n   * Payload length has been read.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ haveLength(cb) {\n        if (this._payloadLength && this._opcode < 0x08) {\n            this._totalPayloadLength += this._payloadLength;\n            if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {\n                const error = this.createError(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n                cb(error);\n                return;\n            }\n        }\n        if (this._masked) this._state = GET_MASK;\n        else this._state = GET_DATA;\n    }\n    /**\n   * Reads mask bytes.\n   *\n   * @private\n   */ getMask() {\n        if (this._bufferedBytes < 4) {\n            this._loop = false;\n            return;\n        }\n        this._mask = this.consume(4);\n        this._state = GET_DATA;\n    }\n    /**\n   * Reads data bytes.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ getData(cb) {\n        let data = EMPTY_BUFFER;\n        if (this._payloadLength) {\n            if (this._bufferedBytes < this._payloadLength) {\n                this._loop = false;\n                return;\n            }\n            data = this.consume(this._payloadLength);\n            if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {\n                unmask(data, this._mask);\n            }\n        }\n        if (this._opcode > 0x07) {\n            this.controlMessage(data, cb);\n            return;\n        }\n        if (this._compressed) {\n            this._state = INFLATING;\n            this.decompress(data, cb);\n            return;\n        }\n        if (data.length) {\n            //\n            // This message is not compressed so its length is the sum of the payload\n            // length of all fragments.\n            //\n            this._messageLength = this._totalPayloadLength;\n            this._fragments.push(data);\n        }\n        this.dataMessage(cb);\n    }\n    /**\n   * Decompresses data.\n   *\n   * @param {Buffer} data Compressed data\n   * @param {Function} cb Callback\n   * @private\n   */ decompress(data, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        perMessageDeflate.decompress(data, this._fin, (err, buf)=>{\n            if (err) return cb(err);\n            if (buf.length) {\n                this._messageLength += buf.length;\n                if (this._messageLength > this._maxPayload && this._maxPayload > 0) {\n                    const error = this.createError(RangeError, \"Max payload size exceeded\", false, 1009, \"WS_ERR_UNSUPPORTED_MESSAGE_LENGTH\");\n                    cb(error);\n                    return;\n                }\n                this._fragments.push(buf);\n            }\n            this.dataMessage(cb);\n            if (this._state === GET_INFO) this.startLoop(cb);\n        });\n    }\n    /**\n   * Handles a data message.\n   *\n   * @param {Function} cb Callback\n   * @private\n   */ dataMessage(cb) {\n        if (!this._fin) {\n            this._state = GET_INFO;\n            return;\n        }\n        const messageLength = this._messageLength;\n        const fragments = this._fragments;\n        this._totalPayloadLength = 0;\n        this._messageLength = 0;\n        this._fragmented = 0;\n        this._fragments = [];\n        if (this._opcode === 2) {\n            let data;\n            if (this._binaryType === \"nodebuffer\") {\n                data = concat(fragments, messageLength);\n            } else if (this._binaryType === \"arraybuffer\") {\n                data = toArrayBuffer(concat(fragments, messageLength));\n            } else if (this._binaryType === \"blob\") {\n                data = new Blob(fragments);\n            } else {\n                data = fragments;\n            }\n            if (this._allowSynchronousEvents) {\n                this.emit(\"message\", data, true);\n                this._state = GET_INFO;\n            } else {\n                this._state = DEFER_EVENT;\n                setImmediate(()=>{\n                    this.emit(\"message\", data, true);\n                    this._state = GET_INFO;\n                    this.startLoop(cb);\n                });\n            }\n        } else {\n            const buf = concat(fragments, messageLength);\n            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                const error = this.createError(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                cb(error);\n                return;\n            }\n            if (this._state === INFLATING || this._allowSynchronousEvents) {\n                this.emit(\"message\", buf, false);\n                this._state = GET_INFO;\n            } else {\n                this._state = DEFER_EVENT;\n                setImmediate(()=>{\n                    this.emit(\"message\", buf, false);\n                    this._state = GET_INFO;\n                    this.startLoop(cb);\n                });\n            }\n        }\n    }\n    /**\n   * Handles a control message.\n   *\n   * @param {Buffer} data Data to handle\n   * @return {(Error|RangeError|undefined)} A possible error\n   * @private\n   */ controlMessage(data, cb) {\n        if (this._opcode === 0x08) {\n            if (data.length === 0) {\n                this._loop = false;\n                this.emit(\"conclude\", 1005, EMPTY_BUFFER);\n                this.end();\n            } else {\n                const code = data.readUInt16BE(0);\n                if (!isValidStatusCode(code)) {\n                    const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, \"WS_ERR_INVALID_CLOSE_CODE\");\n                    cb(error);\n                    return;\n                }\n                const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);\n                if (!this._skipUTF8Validation && !isValidUTF8(buf)) {\n                    const error = this.createError(Error, \"invalid UTF-8 sequence\", true, 1007, \"WS_ERR_INVALID_UTF8\");\n                    cb(error);\n                    return;\n                }\n                this._loop = false;\n                this.emit(\"conclude\", code, buf);\n                this.end();\n            }\n            this._state = GET_INFO;\n            return;\n        }\n        if (this._allowSynchronousEvents) {\n            this.emit(this._opcode === 0x09 ? \"ping\" : \"pong\", data);\n            this._state = GET_INFO;\n        } else {\n            this._state = DEFER_EVENT;\n            setImmediate(()=>{\n                this.emit(this._opcode === 0x09 ? \"ping\" : \"pong\", data);\n                this._state = GET_INFO;\n                this.startLoop(cb);\n            });\n        }\n    }\n    /**\n   * Builds an error object.\n   *\n   * @param {function(new:Error|RangeError)} ErrorCtor The error constructor\n   * @param {String} message The error message\n   * @param {Boolean} prefix Specifies whether or not to add a default prefix to\n   *     `message`\n   * @param {Number} statusCode The status code\n   * @param {String} errorCode The exposed error code\n   * @return {(Error|RangeError)} The error\n   * @private\n   */ createError(ErrorCtor, message, prefix, statusCode, errorCode) {\n        this._loop = false;\n        this._errored = true;\n        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);\n        Error.captureStackTrace(err, this.createError);\n        err.code = errorCode;\n        err[kStatusCode] = statusCode;\n        return err;\n    }\n}\nmodule.exports = Receiver;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsUUFBUSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU1DLG9CQUFvQkQsbUJBQU9BLENBQUM7QUFDbEMsTUFBTSxFQUNKRSxZQUFZLEVBQ1pDLFlBQVksRUFDWkMsV0FBVyxFQUNYQyxVQUFVLEVBQ1gsR0FBR0wsbUJBQU9BLENBQUM7QUFDWixNQUFNLEVBQUVNLE1BQU0sRUFBRUMsYUFBYSxFQUFFQyxNQUFNLEVBQUUsR0FBR1IsbUJBQU9BLENBQUM7QUFDbEQsTUFBTSxFQUFFUyxpQkFBaUIsRUFBRUMsV0FBVyxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBRW5ELE1BQU1XLGFBQWFDLE1BQU0sQ0FBQ0MsT0FBT0MsT0FBTyxDQUFDO0FBRXpDLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLHdCQUF3QjtBQUM5QixNQUFNQyxXQUFXO0FBQ2pCLE1BQU1DLFdBQVc7QUFDakIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxjQUFjO0FBRXBCOzs7O0NBSUMsR0FDRCxNQUFNQyxpQkFBaUJ2QjtJQUNyQjs7Ozs7Ozs7Ozs7Ozs7O0dBZUMsR0FDRHdCLFlBQVlDLFVBQVUsQ0FBQyxDQUFDLENBQUU7UUFDeEIsS0FBSztRQUVMLElBQUksQ0FBQ0MsdUJBQXVCLEdBQzFCRCxRQUFRRSxzQkFBc0IsS0FBS0MsWUFDL0JILFFBQVFFLHNCQUFzQixHQUM5QjtRQUNOLElBQUksQ0FBQ0UsV0FBVyxHQUFHSixRQUFRSyxVQUFVLElBQUkzQixZQUFZLENBQUMsRUFBRTtRQUN4RCxJQUFJLENBQUM0QixXQUFXLEdBQUdOLFFBQVFPLFVBQVUsSUFBSSxDQUFDO1FBQzFDLElBQUksQ0FBQ0MsU0FBUyxHQUFHLENBQUMsQ0FBQ1IsUUFBUVMsUUFBUTtRQUNuQyxJQUFJ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WUFBWXdCLFNBQVMsRUFBRUMsT0FBTyxFQUFFQyxNQUFNLEVBQUVDLFVBQVUsRUFBRUMsU0FBUyxFQUFFO1FBQzdELElBQUksQ0FBQ3RELEtBQUssR0FBRztRQUNiLElBQUksQ0FBQ0QsUUFBUSxHQUFHO1FBRWhCLE1BQU0wQyxNQUFNLElBQUlTLFVBQ2RFLFNBQVMsQ0FBQyx5QkFBeUIsRUFBRUQsUUFBUSxDQUFDLEdBQUdBO1FBR25ESixNQUFNUSxpQkFBaUIsQ0FBQ2QsS0FBSyxJQUFJLENBQUNmLFdBQVc7UUFDN0NlLElBQUlRLElBQUksR0FBR0s7UUFDWGIsR0FBRyxDQUFDeEYsWUFBWSxHQUFHb0c7UUFDbkIsT0FBT1o7SUFDVDtBQUNGO0FBRUFlLE9BQU9DLE9BQU8sR0FBR3RGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmFmb3JtYXRpb24vLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9yZWNlaXZlci5qcz9iYjBjIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBXcml0YWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IHtcbiAgQklOQVJZX1RZUEVTLFxuICBFTVBUWV9CVUZGRVIsXG4gIGtTdGF0dXNDb2RlLFxuICBrV2ViU29ja2V0XG59ID0gcmVxdWlyZSgnLi9jb25zdGFudHMnKTtcbmNvbnN0IHsgY29uY2F0LCB0b0FycmF5QnVmZmVyLCB1bm1hc2sgfSA9IHJlcXVpcmUoJy4vYnVmZmVyLXV0aWwnKTtcbmNvbnN0IHsgaXNWYWxpZFN0YXR1c0NvZGUsIGlzVmFsaWRVVEY4IH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3QgRmFzdEJ1ZmZlciA9IEJ1ZmZlcltTeW1ib2wuc3BlY2llc107XG5cbmNvbnN0IEdFVF9JTkZPID0gMDtcbmNvbnN0IEdFVF9QQVlMT0FEX0xFTkdUSF8xNiA9IDE7XG5jb25zdCBHRVRfUEFZTE9BRF9MRU5HVEhfNjQgPSAyO1xuY29uc3QgR0VUX01BU0sgPSAzO1xuY29uc3QgR0VUX0RBVEEgPSA0O1xuY29uc3QgSU5GTEFUSU5HID0gNTtcbmNvbnN0IERFRkVSX0VWRU5UID0gNjtcblxuLyoqXG4gKiBIeUJpIFJlY2VpdmVyIGltcGxlbWVudGF0aW9uLlxuICpcbiAqIEBleHRlbmRzIFdyaXRhYmxlXG4gKi9cbmNsYXNzIFJlY2VpdmVyIGV4dGVuZHMgV3JpdGFibGUge1xuICAvKipcbiAgICogQ3JlYXRlcyBhIFJlY2VpdmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlclxuICAgKiAgICAgYW55IG9mIHRoZSBgJ21lc3NhZ2UnYCwgYCdwaW5nJ2AsIGFuZCBgJ3BvbmcnYCBldmVudHMgY2FuIGJlIGVtaXR0ZWRcbiAgICogICAgIG11bHRpcGxlIHRpbWVzIGluIHRoZSBzYW1lIHRpY2tcbiAgICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLmJpbmFyeVR5cGU9bm9kZWJ1ZmZlcl0gVGhlIHR5cGUgZm9yIGJpbmFyeSBkYXRhXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5leHRlbnNpb25zXSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgbmVnb3RpYXRlZFxuICAgKiAgICAgZXh0ZW5zaW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmlzU2VydmVyPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciB0byBvcGVyYXRlIGluXG4gICAqICAgICBjbGllbnQgb3Igc2VydmVyIG1vZGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlIGxlbmd0aFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cyA9XG4gICAgICBvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMgIT09IHVuZGVmaW5lZFxuICAgICAgICA/IG9wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50c1xuICAgICAgICA6IHRydWU7XG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IG9wdGlvbnMuYmluYXJ5VHlwZSB8fCBCSU5BUllfVFlQRVNbMF07XG4gICAgdGhpcy5fZXh0ZW5zaW9ucyA9IG9wdGlvbnMuZXh0ZW5zaW9ucyB8fCB7fTtcbiAgICB0aGlzLl9pc1NlcnZlciA9ICEhb3B0aW9ucy5pc1NlcnZlcjtcbiAgICB0aGlzLl9tYXhQYXlsb2FkID0gb3B0aW9ucy5tYXhQYXlsb2FkIHwgMDtcbiAgICB0aGlzLl9za2lwVVRGOFZhbGlkYXRpb24gPSAhIW9wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uO1xuICAgIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzID0gMDtcbiAgICB0aGlzLl9idWZmZXJzID0gW107XG5cbiAgICB0aGlzLl9jb21wcmVzc2VkID0gZmFsc2U7XG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IDA7XG4gICAgdGhpcy5fbWFzayA9IHVuZGVmaW5lZDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9tYXNrZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9maW4gPSBmYWxzZTtcbiAgICB0aGlzLl9vcGNvZGUgPSAwO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIHRoaXMuX2Vycm9yZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgfVxuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRzIGBXcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlKClgLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gY2h1bmsgVGhlIGNodW5rIG9mIGRhdGEgdG8gd3JpdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IGVuY29kaW5nIFRoZSBjaGFyYWN0ZXIgZW5jb2Rpbmcgb2YgYGNodW5rYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX3dyaXRlKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgICBpZiAodGhpcy5fb3Bjb2RlID09PSAweDA4ICYmIHRoaXMuX3N0YXRlID09IEdFVF9JTkZPKSByZXR1cm4gY2IoKTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMuX2J1ZmZlcnMucHVzaChjaHVuayk7XG4gICAgdGhpcy5zdGFydExvb3AoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnN1bWVzIGBuYCBieXRlcyBmcm9tIHRoZSBidWZmZXJlZCBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIGJ5dGVzIHRvIGNvbnN1bWVcbiAgICogQHJldHVybiB7QnVmZmVyfSBUaGUgY29uc3VtZWQgYnl0ZXNcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGNvbnN1bWUobikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gbjtcblxuICAgIGlmIChuID09PSB0aGlzLl9idWZmZXJzWzBdLmxlbmd0aCkgcmV0dXJuIHRoaXMuX2J1ZmZlcnMuc2hpZnQoKTtcblxuICAgIGlmIChuIDwgdGhpcy5fYnVmZmVyc1swXS5sZW5ndGgpIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IHRoaXMuX2J1ZmZlcnNbMF07XG4gICAgICB0aGlzLl9idWZmZXJzWzBdID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgIGJ1Zi5idWZmZXIsXG4gICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcbiAgICAgICAgYnVmLmxlbmd0aCAtIG5cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBuZXcgRmFzdEJ1ZmZlcihidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbik7XG4gICAgfVxuXG4gICAgY29uc3QgZHN0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuXG4gICAgZG8ge1xuICAgICAgY29uc3QgYnVmID0gdGhpcy5fYnVmZmVyc1swXTtcbiAgICAgIGNvbnN0IG9mZnNldCA9IGRzdC5sZW5ndGggLSBuO1xuXG4gICAgICBpZiAobiA+PSBidWYubGVuZ3RoKSB7XG4gICAgICAgIGRzdC5zZXQodGhpcy5fYnVmZmVycy5zaGlmdCgpLCBvZmZzZXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZHN0LnNldChuZXcgVWludDhBcnJheShidWYuYnVmZmVyLCBidWYuYnl0ZU9mZnNldCwgbiksIG9mZnNldCk7XG4gICAgICAgIHRoaXMuX2J1ZmZlcnNbMF0gPSBuZXcgRmFzdEJ1ZmZlcihcbiAgICAgICAgICBidWYuYnVmZmVyLFxuICAgICAgICAgIGJ1Zi5ieXRlT2Zmc2V0ICsgbixcbiAgICAgICAgICBidWYubGVuZ3RoIC0gblxuICAgICAgICApO1xuICAgICAgfVxuXG4gICAgICBuIC09IGJ1Zi5sZW5ndGg7XG4gICAgfSB3aGlsZSAobiA+IDApO1xuXG4gICAgcmV0dXJuIGRzdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydHMgdGhlIHBhcnNpbmcgbG9vcC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHN0YXJ0TG9vcChjYikge1xuICAgIHRoaXMuX2xvb3AgPSB0cnVlO1xuXG4gICAgZG8ge1xuICAgICAgc3dpdGNoICh0aGlzLl9zdGF0ZSkge1xuICAgICAgICBjYXNlIEdFVF9JTkZPOlxuICAgICAgICAgIHRoaXMuZ2V0SW5mbyhjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgR0VUX1BBWUxPQURfTEVOR1RIXzE2OlxuICAgICAgICAgIHRoaXMuZ2V0UGF5bG9hZExlbmd0aDE2KGNiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBHRVRfUEFZTE9BRF9MRU5HVEhfNjQ6XG4gICAgICAgICAgdGhpcy5nZXRQYXlsb2FkTGVuZ3RoNjQoY2IpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9NQVNLOlxuICAgICAgICAgIHRoaXMuZ2V0TWFzaygpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEdFVF9EQVRBOlxuICAgICAgICAgIHRoaXMuZ2V0RGF0YShjYik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgSU5GTEFUSU5HOlxuICAgICAgICBjYXNlIERFRkVSX0VWRU5UOlxuICAgICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSB3aGlsZSAodGhpcy5fbG9vcCk7XG5cbiAgICBpZiAoIXRoaXMuX2Vycm9yZWQpIGNiKCk7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgdGhlIGZpcnN0IHR3byBieXRlcyBvZiBhIGZyYW1lLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0SW5mbyhjYikge1xuICAgIGlmICh0aGlzLl9idWZmZXJlZEJ5dGVzIDwgMikge1xuICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGJ1ZiA9IHRoaXMuY29uc3VtZSgyKTtcblxuICAgIGlmICgoYnVmWzBdICYgMHgzMCkgIT09IDB4MDApIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1JTVjIgYW5kIFJTVjMgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMl8zJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbXByZXNzZWQgPSAoYnVmWzBdICYgMHg0MCkgPT09IDB4NDA7XG5cbiAgICBpZiAoY29tcHJlc3NlZCAmJiAhdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgKTtcblxuICAgICAgY2IoZXJyb3IpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX2ZpbiA9IChidWZbMF0gJiAweDgwKSA9PT0gMHg4MDtcbiAgICB0aGlzLl9vcGNvZGUgPSBidWZbMF0gJiAweDBmO1xuICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPSBidWZbMV0gJiAweDdmO1xuXG4gICAgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMCkge1xuICAgICAgaWYgKGNvbXByZXNzZWQpIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ1JTVjEgbXVzdCBiZSBjbGVhcicsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfVU5FWFBFQ1RFRF9SU1ZfMSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCF0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICdpbnZhbGlkIG9wY29kZSAwJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX09QQ09ERSdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5fb3Bjb2RlID0gdGhpcy5fZnJhZ21lbnRlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA9PT0gMHgwMSB8fCB0aGlzLl9vcGNvZGUgPT09IDB4MDIpIHtcbiAgICAgIGlmICh0aGlzLl9mcmFnbWVudGVkKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgIGBpbnZhbGlkIG9wY29kZSAke3RoaXMuX29wY29kZX1gLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwMixcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfT1BDT0RFJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0aGlzLl9jb21wcmVzc2VkID0gY29tcHJlc3NlZDtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX29wY29kZSA+IDB4MDcgJiYgdGhpcy5fb3Bjb2RlIDwgMHgwYikge1xuICAgICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ0ZJTiBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfRklOJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnUlNWMSBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX1JTVl8xJ1xuICAgICAgICApO1xuXG4gICAgICAgIGNiKGVycm9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX3BheWxvYWRMZW5ndGggPiAweDdkIHx8XG4gICAgICAgICh0aGlzLl9vcGNvZGUgPT09IDB4MDggJiYgdGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMSlcbiAgICAgICkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICBgaW52YWxpZCBwYXlsb2FkIGxlbmd0aCAke3RoaXMuX3BheWxvYWRMZW5ndGh9YCxcbiAgICAgICAgICB0cnVlLFxuICAgICAgICAgIDEwMDIsXG4gICAgICAgICAgJ1dTX0VSUl9JTlZBTElEX0NPTlRST0xfUEFZTE9BRF9MRU5HVEgnXG4gICAgICAgICk7XG5cbiAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgYGludmFsaWQgb3Bjb2RlICR7dGhpcy5fb3Bjb2RlfWAsXG4gICAgICAgIHRydWUsXG4gICAgICAgIDEwMDIsXG4gICAgICAgICdXU19FUlJfSU5WQUxJRF9PUENPREUnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9maW4gJiYgIXRoaXMuX2ZyYWdtZW50ZWQpIHRoaXMuX2ZyYWdtZW50ZWQgPSB0aGlzLl9vcGNvZGU7XG4gICAgdGhpcy5fbWFza2VkID0gKGJ1ZlsxXSAmIDB4ODApID09PSAweDgwO1xuXG4gICAgaWYgKHRoaXMuX2lzU2VydmVyKSB7XG4gICAgICBpZiAoIXRoaXMuX21hc2tlZCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgICAnTUFTSyBtdXN0IGJlIHNldCcsXG4gICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAxMDAyLFxuICAgICAgICAgICdXU19FUlJfRVhQRUNURURfTUFTSydcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHRoaXMuX21hc2tlZCkge1xuICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAnTUFTSyBtdXN0IGJlIGNsZWFyJyxcbiAgICAgICAgdHJ1ZSxcbiAgICAgICAgMTAwMixcbiAgICAgICAgJ1dTX0VSUl9VTkVYUEVDVEVEX01BU0snXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX3BheWxvYWRMZW5ndGggPT09IDEyNikgdGhpcy5fc3RhdGUgPSBHRVRfUEFZTE9BRF9MRU5HVEhfMTY7XG4gICAgZWxzZSBpZiAodGhpcy5fcGF5bG9hZExlbmd0aCA9PT0gMTI3KSB0aGlzLl9zdGF0ZSA9IEdFVF9QQVlMT0FEX0xFTkdUSF82NDtcbiAgICBlbHNlIHRoaXMuaGF2ZUxlbmd0aChjYik7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyBleHRlbmRlZCBwYXlsb2FkIGxlbmd0aCAoNysxNikuXG4gICAqXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNiIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYXlsb2FkTGVuZ3RoMTYoY2IpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDIpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9wYXlsb2FkTGVuZ3RoID0gdGhpcy5jb25zdW1lKDIpLnJlYWRVSW50MTZCRSgwKTtcbiAgICB0aGlzLmhhdmVMZW5ndGgoY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgZXh0ZW5kZWQgcGF5bG9hZCBsZW5ndGggKDcrNjQpLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0UGF5bG9hZExlbmd0aDY0KGNiKSB7XG4gICAgaWYgKHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPCA4KSB7XG4gICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgYnVmID0gdGhpcy5jb25zdW1lKDgpO1xuICAgIGNvbnN0IG51bSA9IGJ1Zi5yZWFkVUludDMyQkUoMCk7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBtYXhpbXVtIHNhZmUgaW50ZWdlciBpbiBKYXZhU2NyaXB0IGlzIDJeNTMgLSAxLiBBbiBlcnJvciBpcyByZXR1cm5lZFxuICAgIC8vIGlmIHBheWxvYWQgbGVuZ3RoIGlzIGdyZWF0ZXIgdGhhbiB0aGlzIG51bWJlci5cbiAgICAvL1xuICAgIGlmIChudW0gPiBNYXRoLnBvdygyLCA1MyAtIDMyKSAtIDEpIHtcbiAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgUmFuZ2VFcnJvcixcbiAgICAgICAgJ1Vuc3VwcG9ydGVkIFdlYlNvY2tldCBmcmFtZTogcGF5bG9hZCBsZW5ndGggPiAyXjUzIC0gMScsXG4gICAgICAgIGZhbHNlLFxuICAgICAgICAxMDA5LFxuICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX0RBVEFfUEFZTE9BRF9MRU5HVEgnXG4gICAgICApO1xuXG4gICAgICBjYihlcnJvcik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF5bG9hZExlbmd0aCA9IG51bSAqIE1hdGgucG93KDIsIDMyKSArIGJ1Zi5yZWFkVUludDMyQkUoNCk7XG4gICAgdGhpcy5oYXZlTGVuZ3RoKGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQYXlsb2FkIGxlbmd0aCBoYXMgYmVlbiByZWFkLlxuICAgKlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGF2ZUxlbmd0aChjYikge1xuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoICYmIHRoaXMuX29wY29kZSA8IDB4MDgpIHtcbiAgICAgIHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCArPSB0aGlzLl9wYXlsb2FkTGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuX3RvdGFsUGF5bG9hZExlbmd0aCA+IHRoaXMuX21heFBheWxvYWQgJiYgdGhpcy5fbWF4UGF5bG9hZCA+IDApIHtcbiAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmNyZWF0ZUVycm9yKFxuICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgJ01heCBwYXlsb2FkIHNpemUgZXhjZWVkZWQnLFxuICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgIDEwMDksXG4gICAgICAgICAgJ1dTX0VSUl9VTlNVUFBPUlRFRF9NRVNTQUdFX0xFTkdUSCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fbWFza2VkKSB0aGlzLl9zdGF0ZSA9IEdFVF9NQVNLO1xuICAgIGVsc2UgdGhpcy5fc3RhdGUgPSBHRVRfREFUQTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZWFkcyBtYXNrIGJ5dGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZ2V0TWFzaygpIHtcbiAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IDQpIHtcbiAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aGlzLl9tYXNrID0gdGhpcy5jb25zdW1lKDQpO1xuICAgIHRoaXMuX3N0YXRlID0gR0VUX0RBVEE7XG4gIH1cblxuICAvKipcbiAgICogUmVhZHMgZGF0YSBieXRlcy5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldERhdGEoY2IpIHtcbiAgICBsZXQgZGF0YSA9IEVNUFRZX0JVRkZFUjtcblxuICAgIGlmICh0aGlzLl9wYXlsb2FkTGVuZ3RoKSB7XG4gICAgICBpZiAodGhpcy5fYnVmZmVyZWRCeXRlcyA8IHRoaXMuX3BheWxvYWRMZW5ndGgpIHtcbiAgICAgICAgdGhpcy5fbG9vcCA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGRhdGEgPSB0aGlzLmNvbnN1bWUodGhpcy5fcGF5bG9hZExlbmd0aCk7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fbWFza2VkICYmXG4gICAgICAgICh0aGlzLl9tYXNrWzBdIHwgdGhpcy5fbWFza1sxXSB8IHRoaXMuX21hc2tbMl0gfCB0aGlzLl9tYXNrWzNdKSAhPT0gMFxuICAgICAgKSB7XG4gICAgICAgIHVubWFzayhkYXRhLCB0aGlzLl9tYXNrKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5fb3Bjb2RlID4gMHgwNykge1xuICAgICAgdGhpcy5jb250cm9sTWVzc2FnZShkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2NvbXByZXNzZWQpIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gSU5GTEFUSU5HO1xuICAgICAgdGhpcy5kZWNvbXByZXNzKGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZGF0YS5sZW5ndGgpIHtcbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIG1lc3NhZ2UgaXMgbm90IGNvbXByZXNzZWQgc28gaXRzIGxlbmd0aCBpcyB0aGUgc3VtIG9mIHRoZSBwYXlsb2FkXG4gICAgICAvLyBsZW5ndGggb2YgYWxsIGZyYWdtZW50cy5cbiAgICAgIC8vXG4gICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoO1xuICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goZGF0YSk7XG4gICAgfVxuXG4gICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XG4gIH1cblxuICAvKipcbiAgICogRGVjb21wcmVzc2VzIGRhdGEuXG4gICAqXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBkYXRhIENvbXByZXNzZWQgZGF0YVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYiBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVjb21wcmVzcyhkYXRhLCBjYikge1xuICAgIGNvbnN0IHBlck1lc3NhZ2VEZWZsYXRlID0gdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXTtcblxuICAgIHBlck1lc3NhZ2VEZWZsYXRlLmRlY29tcHJlc3MoZGF0YSwgdGhpcy5fZmluLCAoZXJyLCBidWYpID0+IHtcbiAgICAgIGlmIChlcnIpIHJldHVybiBjYihlcnIpO1xuXG4gICAgICBpZiAoYnVmLmxlbmd0aCkge1xuICAgICAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoICs9IGJ1Zi5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLl9tZXNzYWdlTGVuZ3RoID4gdGhpcy5fbWF4UGF5bG9hZCAmJiB0aGlzLl9tYXhQYXlsb2FkID4gMCkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIFJhbmdlRXJyb3IsXG4gICAgICAgICAgICAnTWF4IHBheWxvYWQgc2l6ZSBleGNlZWRlZCcsXG4gICAgICAgICAgICBmYWxzZSxcbiAgICAgICAgICAgIDEwMDksXG4gICAgICAgICAgICAnV1NfRVJSX1VOU1VQUE9SVEVEX01FU1NBR0VfTEVOR1RIJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fZnJhZ21lbnRzLnB1c2goYnVmKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kYXRhTWVzc2FnZShjYik7XG4gICAgICBpZiAodGhpcy5fc3RhdGUgPT09IEdFVF9JTkZPKSB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBhIGRhdGEgbWVzc2FnZS5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRhdGFNZXNzYWdlKGNiKSB7XG4gICAgaWYgKCF0aGlzLl9maW4pIHtcbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgbWVzc2FnZUxlbmd0aCA9IHRoaXMuX21lc3NhZ2VMZW5ndGg7XG4gICAgY29uc3QgZnJhZ21lbnRzID0gdGhpcy5fZnJhZ21lbnRzO1xuXG4gICAgdGhpcy5fdG90YWxQYXlsb2FkTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9tZXNzYWdlTGVuZ3RoID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudGVkID0gMDtcbiAgICB0aGlzLl9mcmFnbWVudHMgPSBbXTtcblxuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDIpIHtcbiAgICAgIGxldCBkYXRhO1xuXG4gICAgICBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ25vZGVidWZmZXInKSB7XG4gICAgICAgIGRhdGEgPSBjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmluYXJ5VHlwZSA9PT0gJ2FycmF5YnVmZmVyJykge1xuICAgICAgICBkYXRhID0gdG9BcnJheUJ1ZmZlcihjb25jYXQoZnJhZ21lbnRzLCBtZXNzYWdlTGVuZ3RoKSk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2JpbmFyeVR5cGUgPT09ICdibG9iJykge1xuICAgICAgICBkYXRhID0gbmV3IEJsb2IoZnJhZ21lbnRzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRhdGEgPSBmcmFnbWVudHM7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLl9hbGxvd1N5bmNocm9ub3VzRXZlbnRzKSB7XG4gICAgICAgIHRoaXMuZW1pdCgnbWVzc2FnZScsIGRhdGEsIHRydWUpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgICAgc2V0SW1tZWRpYXRlKCgpID0+IHtcbiAgICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBkYXRhLCB0cnVlKTtcbiAgICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICAgIHRoaXMuc3RhcnRMb29wKGNiKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGJ1ZiA9IGNvbmNhdChmcmFnbWVudHMsIG1lc3NhZ2VMZW5ndGgpO1xuXG4gICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgRXJyb3IsXG4gICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgIHRydWUsXG4gICAgICAgICAgMTAwNyxcbiAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYihlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuX3N0YXRlID09PSBJTkZMQVRJTkcgfHwgdGhpcy5fYWxsb3dTeW5jaHJvbm91c0V2ZW50cykge1xuICAgICAgICB0aGlzLmVtaXQoJ21lc3NhZ2UnLCBidWYsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX3N0YXRlID0gREVGRVJfRVZFTlQ7XG4gICAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0KCdtZXNzYWdlJywgYnVmLCBmYWxzZSk7XG4gICAgICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGVzIGEgY29udHJvbCBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gZGF0YSBEYXRhIHRvIGhhbmRsZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcnx1bmRlZmluZWQpfSBBIHBvc3NpYmxlIGVycm9yXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjb250cm9sTWVzc2FnZShkYXRhLCBjYikge1xuICAgIGlmICh0aGlzLl9vcGNvZGUgPT09IDB4MDgpIHtcbiAgICAgIGlmIChkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB0aGlzLl9sb29wID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZW1pdCgnY29uY2x1ZGUnLCAxMDA1LCBFTVBUWV9CVUZGRVIpO1xuICAgICAgICB0aGlzLmVuZCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGRhdGEucmVhZFVJbnQxNkJFKDApO1xuXG4gICAgICAgIGlmICghaXNWYWxpZFN0YXR1c0NvZGUoY29kZSkpIHtcbiAgICAgICAgICBjb25zdCBlcnJvciA9IHRoaXMuY3JlYXRlRXJyb3IoXG4gICAgICAgICAgICBSYW5nZUVycm9yLFxuICAgICAgICAgICAgYGludmFsaWQgc3RhdHVzIGNvZGUgJHtjb2RlfWAsXG4gICAgICAgICAgICB0cnVlLFxuICAgICAgICAgICAgMTAwMixcbiAgICAgICAgICAgICdXU19FUlJfSU5WQUxJRF9DTE9TRV9DT0RFJ1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBjYihlcnJvcik7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgY29uc3QgYnVmID0gbmV3IEZhc3RCdWZmZXIoXG4gICAgICAgICAgZGF0YS5idWZmZXIsXG4gICAgICAgICAgZGF0YS5ieXRlT2Zmc2V0ICsgMixcbiAgICAgICAgICBkYXRhLmxlbmd0aCAtIDJcbiAgICAgICAgKTtcblxuICAgICAgICBpZiAoIXRoaXMuX3NraXBVVEY4VmFsaWRhdGlvbiAmJiAhaXNWYWxpZFVURjgoYnVmKSkge1xuICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5jcmVhdGVFcnJvcihcbiAgICAgICAgICAgIEVycm9yLFxuICAgICAgICAgICAgJ2ludmFsaWQgVVRGLTggc2VxdWVuY2UnLFxuICAgICAgICAgICAgdHJ1ZSxcbiAgICAgICAgICAgIDEwMDcsXG4gICAgICAgICAgICAnV1NfRVJSX0lOVkFMSURfVVRGOCdcbiAgICAgICAgICApO1xuXG4gICAgICAgICAgY2IoZXJyb3IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25jbHVkZScsIGNvZGUsIGJ1Zik7XG4gICAgICAgIHRoaXMuZW5kKCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX3N0YXRlID0gR0VUX0lORk87XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2FsbG93U3luY2hyb25vdXNFdmVudHMpIHtcbiAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xuICAgICAgdGhpcy5fc3RhdGUgPSBHRVRfSU5GTztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fc3RhdGUgPSBERUZFUl9FVkVOVDtcbiAgICAgIHNldEltbWVkaWF0ZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLl9vcGNvZGUgPT09IDB4MDkgPyAncGluZycgOiAncG9uZycsIGRhdGEpO1xuICAgICAgICB0aGlzLl9zdGF0ZSA9IEdFVF9JTkZPO1xuICAgICAgICB0aGlzLnN0YXJ0TG9vcChjYik7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIGFuIGVycm9yIG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIHtmdW5jdGlvbihuZXc6RXJyb3J8UmFuZ2VFcnJvcil9IEVycm9yQ3RvciBUaGUgZXJyb3IgY29uc3RydWN0b3JcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2VcbiAgICogQHBhcmFtIHtCb29sZWFufSBwcmVmaXggU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIGFkZCBhIGRlZmF1bHQgcHJlZml4IHRvXG4gICAqICAgICBgbWVzc2FnZWBcbiAgICogQHBhcmFtIHtOdW1iZXJ9IHN0YXR1c0NvZGUgVGhlIHN0YXR1cyBjb2RlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBlcnJvckNvZGUgVGhlIGV4cG9zZWQgZXJyb3IgY29kZVxuICAgKiBAcmV0dXJuIHsoRXJyb3J8UmFuZ2VFcnJvcil9IFRoZSBlcnJvclxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY3JlYXRlRXJyb3IoRXJyb3JDdG9yLCBtZXNzYWdlLCBwcmVmaXgsIHN0YXR1c0NvZGUsIGVycm9yQ29kZSkge1xuICAgIHRoaXMuX2xvb3AgPSBmYWxzZTtcbiAgICB0aGlzLl9lcnJvcmVkID0gdHJ1ZTtcblxuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvckN0b3IoXG4gICAgICBwcmVmaXggPyBgSW52YWxpZCBXZWJTb2NrZXQgZnJhbWU6ICR7bWVzc2FnZX1gIDogbWVzc2FnZVxuICAgICk7XG5cbiAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShlcnIsIHRoaXMuY3JlYXRlRXJyb3IpO1xuICAgIGVyci5jb2RlID0gZXJyb3JDb2RlO1xuICAgIGVycltrU3RhdHVzQ29kZV0gPSBzdGF0dXNDb2RlO1xuICAgIHJldHVybiBlcnI7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWNlaXZlcjtcbiJdLCJuYW1lcyI6WyJXcml0YWJsZSIsInJlcXVpcmUiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIkJJTkFSWV9UWVBFUyIsIkVNUFRZX0JVRkZFUiIsImtTdGF0dXNDb2RlIiwia1dlYlNvY2tldCIsImNvbmNhdCIsInRvQXJyYXlCdWZmZXIiLCJ1bm1hc2siLCJpc1ZhbGlkU3RhdHVzQ29kZSIsImlzVmFsaWRVVEY4IiwiRmFzdEJ1ZmZlciIsIkJ1ZmZlciIsIlN5bWJvbCIsInNwZWNpZXMiLCJHRVRfSU5GTyIsIkdFVF9QQVlMT0FEX0xFTkdUSF8xNiIsIkdFVF9QQVlMT0FEX0xFTkdUSF82NCIsIkdFVF9NQVNLIiwiR0VUX0RBVEEiLCJJTkZMQVRJTkciLCJERUZFUl9FVkVOVCIsIlJlY2VpdmVyIiwiY29uc3RydWN0b3IiLCJvcHRpb25zIiwiX2FsbG93U3luY2hyb25vdXNFdmVudHMiLCJhbGxvd1N5bmNocm9ub3VzRXZlbnRzIiwidW5kZWZpbmVkIiwiX2JpbmFyeVR5cGUiLCJiaW5hcnlUeXBlIiwiX2V4dGVuc2lvbnMiLCJleHRlbnNpb25zIiwiX2lzU2VydmVyIiwiaXNTZXJ2ZXIiLCJfbWF4UGF5bG9hZCIsIm1heFBheWxvYWQiLCJfc2tpcFVURjhWYWxpZGF0aW9uIiwic2tpcFVURjhWYWxpZGF0aW9uIiwiX2J1ZmZlcmVkQnl0ZXMiLCJfYnVmZmVycyIsIl9jb21wcmVzc2VkIiwiX3BheWxvYWRMZW5ndGgiLCJfbWFzayIsIl9mcmFnbWVudGVkIiwiX21hc2tlZCIsIl9maW4iLCJfb3Bjb2RlIiwiX3RvdGFsUGF5bG9hZExlbmd0aCIsIl9tZXNzYWdlTGVuZ3RoIiwiX2ZyYWdtZW50cyIsIl9lcnJvcmVkIiwiX2xvb3AiLCJfc3RhdGUiLCJfd3JpdGUiLCJjaHVuayIsImVuY29kaW5nIiwiY2IiLCJsZW5ndGgiLCJwdXNoIiwic3RhcnRMb29wIiwiY29uc3VtZSIsIm4iLCJzaGlmdCIsImJ1ZiIsImJ1ZmZlciIsImJ5dGVPZmZzZXQiLCJkc3QiLCJhbGxvY1Vuc2FmZSIsIm9mZnNldCIsInNldCIsIlVpbnQ4QXJyYXkiLCJnZXRJbmZvIiwiZ2V0UGF5bG9hZExlbmd0aDE2IiwiZ2V0UGF5bG9hZExlbmd0aDY0IiwiZ2V0TWFzayIsImdldERhdGEiLCJlcnJvciIsImNyZWF0ZUVycm9yIiwiUmFuZ2VFcnJvciIsImNvbXByZXNzZWQiLCJleHRlbnNpb25OYW1lIiwiaGF2ZUxlbmd0aCIsInJlYWRVSW50MTZCRSIsIm51bSIsInJlYWRVSW50MzJCRSIsIk1hdGgiLCJwb3ciLCJkYXRhIiwiY29udHJvbE1lc3NhZ2UiLCJkZWNvbXByZXNzIiwiZGF0YU1lc3NhZ2UiLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImVyciIsIm1lc3NhZ2VMZW5ndGgiLCJmcmFnbWVudHMiLCJCbG9iIiwiZW1pdCIsInNldEltbWVkaWF0ZSIsIkVycm9yIiwiZW5kIiwiY29kZSIsIkVycm9yQ3RvciIsIm1lc3NhZ2UiLCJwcmVmaXgiLCJzdGF0dXNDb2RlIiwiZXJyb3JDb2RlIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/receiver.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/sender.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/sender.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex\" }] */ \nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { randomFillSync } = __webpack_require__(/*! crypto */ \"crypto\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js\");\nconst { EMPTY_BUFFER, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\nconst { isBlob, isValidStatusCode } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/validation.js\");\nconst { mask: applyMask, toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js\");\nconst kByteLength = Symbol(\"kByteLength\");\nconst maskBuffer = Buffer.alloc(4);\nconst RANDOM_POOL_SIZE = 8 * 1024;\nlet randomPool;\nlet randomPoolPointer = RANDOM_POOL_SIZE;\nconst DEFAULT = 0;\nconst DEFLATING = 1;\nconst GET_BLOB_DATA = 2;\n/**\n * HyBi Sender implementation.\n */ class Sender {\n    /**\n   * Creates a Sender instance.\n   *\n   * @param {Duplex} socket The connection socket\n   * @param {Object} [extensions] An object containing the negotiated extensions\n   * @param {Function} [generateMask] The function used to generate the masking\n   *     key\n   */ constructor(socket, extensions, generateMask){\n        this._extensions = extensions || {};\n        if (generateMask) {\n            this._generateMask = generateMask;\n            this._maskBuffer = Buffer.alloc(4);\n        }\n        this._socket = socket;\n        this._firstFragment = true;\n        this._compress = false;\n        this._bufferedBytes = 0;\n        this._queue = [];\n        this._state = DEFAULT;\n        this.onerror = NOOP;\n        this[kWebSocket] = undefined;\n    }\n    /**\n   * Frames a piece of data according to the HyBi WebSocket protocol.\n   *\n   * @param {(Buffer|String)} data The data to frame\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @return {(Buffer|String)[]} The framed data\n   * @public\n   */ static frame(data, options) {\n        let mask;\n        let merge = false;\n        let offset = 2;\n        let skipMasking = false;\n        if (options.mask) {\n            mask = options.maskBuffer || maskBuffer;\n            if (options.generateMask) {\n                options.generateMask(mask);\n            } else {\n                if (randomPoolPointer === RANDOM_POOL_SIZE) {\n                    /* istanbul ignore else  */ if (randomPool === undefined) {\n                        //\n                        // This is lazily initialized because server-sent frames must not\n                        // be masked so it may never be used.\n                        //\n                        randomPool = Buffer.alloc(RANDOM_POOL_SIZE);\n                    }\n                    randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);\n                    randomPoolPointer = 0;\n                }\n                mask[0] = randomPool[randomPoolPointer++];\n                mask[1] = randomPool[randomPoolPointer++];\n                mask[2] = randomPool[randomPoolPointer++];\n                mask[3] = randomPool[randomPoolPointer++];\n            }\n            skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;\n            offset = 6;\n        }\n        let dataLength;\n        if (typeof data === \"string\") {\n            if ((!options.mask || skipMasking) && options[kByteLength] !== undefined) {\n                dataLength = options[kByteLength];\n            } else {\n                data = Buffer.from(data);\n                dataLength = data.length;\n            }\n        } else {\n            dataLength = data.length;\n            merge = options.mask && options.readOnly && !skipMasking;\n        }\n        let payloadLength = dataLength;\n        if (dataLength >= 65536) {\n            offset += 8;\n            payloadLength = 127;\n        } else if (dataLength > 125) {\n            offset += 2;\n            payloadLength = 126;\n        }\n        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);\n        target[0] = options.fin ? options.opcode | 0x80 : options.opcode;\n        if (options.rsv1) target[0] |= 0x40;\n        target[1] = payloadLength;\n        if (payloadLength === 126) {\n            target.writeUInt16BE(dataLength, 2);\n        } else if (payloadLength === 127) {\n            target[2] = target[3] = 0;\n            target.writeUIntBE(dataLength, 4, 6);\n        }\n        if (!options.mask) return [\n            target,\n            data\n        ];\n        target[1] |= 0x80;\n        target[offset - 4] = mask[0];\n        target[offset - 3] = mask[1];\n        target[offset - 2] = mask[2];\n        target[offset - 1] = mask[3];\n        if (skipMasking) return [\n            target,\n            data\n        ];\n        if (merge) {\n            applyMask(data, mask, target, offset, dataLength);\n            return [\n                target\n            ];\n        }\n        applyMask(data, mask, data, 0, dataLength);\n        return [\n            target,\n            data\n        ];\n    }\n    /**\n   * Sends a close message to the other peer.\n   *\n   * @param {Number} [code] The status code component of the body\n   * @param {(String|Buffer)} [data] The message component of the body\n   * @param {Boolean} [mask=false] Specifies whether or not to mask the message\n   * @param {Function} [cb] Callback\n   * @public\n   */ close(code, data, mask, cb) {\n        let buf;\n        if (code === undefined) {\n            buf = EMPTY_BUFFER;\n        } else if (typeof code !== \"number\" || !isValidStatusCode(code)) {\n            throw new TypeError(\"First argument must be a valid error code number\");\n        } else if (data === undefined || !data.length) {\n            buf = Buffer.allocUnsafe(2);\n            buf.writeUInt16BE(code, 0);\n        } else {\n            const length = Buffer.byteLength(data);\n            if (length > 123) {\n                throw new RangeError(\"The message must not be greater than 123 bytes\");\n            }\n            buf = Buffer.allocUnsafe(2 + length);\n            buf.writeUInt16BE(code, 0);\n            if (typeof data === \"string\") {\n                buf.write(data, 2);\n            } else {\n                buf.set(data, 2);\n            }\n        }\n        const options = {\n            [kByteLength]: buf.length,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x08,\n            readOnly: false,\n            rsv1: false\n        };\n        if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                buf,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(buf, options), cb);\n        }\n    }\n    /**\n   * Sends a ping message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ ping(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x09,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a pong message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Boolean} [mask=false] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ pong(data, mask, cb) {\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (byteLength > 125) {\n            throw new RangeError(\"The data size must not be greater than 125 bytes\");\n        }\n        const options = {\n            [kByteLength]: byteLength,\n            fin: true,\n            generateMask: this._generateMask,\n            mask,\n            maskBuffer: this._maskBuffer,\n            opcode: 0x0a,\n            readOnly,\n            rsv1: false\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    false,\n                    options,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, false, options, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                false,\n                options,\n                cb\n            ]);\n        } else {\n            this.sendFrame(Sender.frame(data, options), cb);\n        }\n    }\n    /**\n   * Sends a data message to the other peer.\n   *\n   * @param {*} data The message to send\n   * @param {Object} options Options object\n   * @param {Boolean} [options.binary=false] Specifies whether `data` is binary\n   *     or text\n   * @param {Boolean} [options.compress=false] Specifies whether or not to\n   *     compress `data`\n   * @param {Boolean} [options.fin=false] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Function} [cb] Callback\n   * @public\n   */ send(data, options, cb) {\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        let opcode = options.binary ? 2 : 1;\n        let rsv1 = options.compress;\n        let byteLength;\n        let readOnly;\n        if (typeof data === \"string\") {\n            byteLength = Buffer.byteLength(data);\n            readOnly = false;\n        } else if (isBlob(data)) {\n            byteLength = data.size;\n            readOnly = false;\n        } else {\n            data = toBuffer(data);\n            byteLength = data.length;\n            readOnly = toBuffer.readOnly;\n        }\n        if (this._firstFragment) {\n            this._firstFragment = false;\n            if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? \"server_no_context_takeover\" : \"client_no_context_takeover\"]) {\n                rsv1 = byteLength >= perMessageDeflate._threshold;\n            }\n            this._compress = rsv1;\n        } else {\n            rsv1 = false;\n            opcode = 0;\n        }\n        if (options.fin) this._firstFragment = true;\n        const opts = {\n            [kByteLength]: byteLength,\n            fin: options.fin,\n            generateMask: this._generateMask,\n            mask: options.mask,\n            maskBuffer: this._maskBuffer,\n            opcode,\n            readOnly,\n            rsv1\n        };\n        if (isBlob(data)) {\n            if (this._state !== DEFAULT) {\n                this.enqueue([\n                    this.getBlobData,\n                    data,\n                    this._compress,\n                    opts,\n                    cb\n                ]);\n            } else {\n                this.getBlobData(data, this._compress, opts, cb);\n            }\n        } else if (this._state !== DEFAULT) {\n            this.enqueue([\n                this.dispatch,\n                data,\n                this._compress,\n                opts,\n                cb\n            ]);\n        } else {\n            this.dispatch(data, this._compress, opts, cb);\n        }\n    }\n    /**\n   * Gets the contents of a blob as binary data.\n   *\n   * @param {Blob} blob The blob\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     the data\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ getBlobData(blob, compress, options, cb) {\n        this._bufferedBytes += options[kByteLength];\n        this._state = GET_BLOB_DATA;\n        blob.arrayBuffer().then((arrayBuffer)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while the blob was being read\");\n                //\n                // `callCallbacks` is called in the next tick to ensure that errors\n                // that might be thrown in the callbacks behave like errors thrown\n                // outside the promise chain.\n                //\n                process.nextTick(callCallbacks, this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            const data = toBuffer(arrayBuffer);\n            if (!compress) {\n                this._state = DEFAULT;\n                this.sendFrame(Sender.frame(data, options), cb);\n                this.dequeue();\n            } else {\n                this.dispatch(data, compress, options, cb);\n            }\n        }).catch((err)=>{\n            //\n            // `onError` is called in the next tick for the same reason that\n            // `callCallbacks` above is.\n            //\n            process.nextTick(onError, this, err, cb);\n        });\n    }\n    /**\n   * Dispatches a message.\n   *\n   * @param {(Buffer|String)} data The message to send\n   * @param {Boolean} [compress=false] Specifies whether or not to compress\n   *     `data`\n   * @param {Object} options Options object\n   * @param {Boolean} [options.fin=false] Specifies whether or not to set the\n   *     FIN bit\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Boolean} [options.mask=false] Specifies whether or not to mask\n   *     `data`\n   * @param {Buffer} [options.maskBuffer] The buffer used to store the masking\n   *     key\n   * @param {Number} options.opcode The opcode\n   * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be\n   *     modified\n   * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the\n   *     RSV1 bit\n   * @param {Function} [cb] Callback\n   * @private\n   */ dispatch(data, compress, options, cb) {\n        if (!compress) {\n            this.sendFrame(Sender.frame(data, options), cb);\n            return;\n        }\n        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];\n        this._bufferedBytes += options[kByteLength];\n        this._state = DEFLATING;\n        perMessageDeflate.compress(data, options.fin, (_, buf)=>{\n            if (this._socket.destroyed) {\n                const err = new Error(\"The socket was closed while data was being compressed\");\n                callCallbacks(this, err, cb);\n                return;\n            }\n            this._bufferedBytes -= options[kByteLength];\n            this._state = DEFAULT;\n            options.readOnly = false;\n            this.sendFrame(Sender.frame(buf, options), cb);\n            this.dequeue();\n        });\n    }\n    /**\n   * Executes queued send operations.\n   *\n   * @private\n   */ dequeue() {\n        while(this._state === DEFAULT && this._queue.length){\n            const params = this._queue.shift();\n            this._bufferedBytes -= params[3][kByteLength];\n            Reflect.apply(params[0], this, params.slice(1));\n        }\n    }\n    /**\n   * Enqueues a send operation.\n   *\n   * @param {Array} params Send operation parameters.\n   * @private\n   */ enqueue(params) {\n        this._bufferedBytes += params[3][kByteLength];\n        this._queue.push(params);\n    }\n    /**\n   * Sends a frame.\n   *\n   * @param {(Buffer | String)[]} list The frame to send\n   * @param {Function} [cb] Callback\n   * @private\n   */ sendFrame(list, cb) {\n        if (list.length === 2) {\n            this._socket.cork();\n            this._socket.write(list[0]);\n            this._socket.write(list[1], cb);\n            this._socket.uncork();\n        } else {\n            this._socket.write(list[0], cb);\n        }\n    }\n}\nmodule.exports = Sender;\n/**\n * Calls queued callbacks with an error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error to call the callbacks with\n * @param {Function} [cb] The first callback\n * @private\n */ function callCallbacks(sender, err, cb) {\n    if (typeof cb === \"function\") cb(err);\n    for(let i = 0; i < sender._queue.length; i++){\n        const params = sender._queue[i];\n        const callback = params[params.length - 1];\n        if (typeof callback === \"function\") callback(err);\n    }\n}\n/**\n * Handles a `Sender` error.\n *\n * @param {Sender} sender The `Sender` instance\n * @param {Error} err The error\n * @param {Function} [cb] The first pending callback\n * @private\n */ function onError(sender, err, cb) {\n    callCallbacks(sender, err, cb);\n    sender.onerror(err);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9zZW5kZXIuanMiLCJtYXBwaW5ncyI6IkFBQUEsd0VBQXdFLEdBRXhFO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFDM0IsTUFBTSxFQUFFQyxjQUFjLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFbkMsTUFBTUUsb0JBQW9CRixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUVHLFlBQVksRUFBRUMsVUFBVSxFQUFFQyxJQUFJLEVBQUUsR0FBR0wsbUJBQU9BLENBQUM7QUFDbkQsTUFBTSxFQUFFTSxNQUFNLEVBQUVDLGlCQUFpQixFQUFFLEdBQUdQLG1CQUFPQSxDQUFDO0FBQzlDLE1BQU0sRUFBRVEsTUFBTUMsU0FBUyxFQUFFQyxRQUFRLEVBQUUsR0FBR1YsbUJBQU9BLENBQUM7QUFFOUMsTUFBTVcsY0FBY0MsT0FBTztBQUMzQixNQUFNQyxhQUFhQyxPQUFPQyxLQUFLLENBQUM7QUFDaEMsTUFBTUMsbUJBQW1CLElBQUk7QUFDN0IsSUFBSUM7QUFDSixJQUFJQyxvQkFBb0JGO0FBRXhCLE1BQU1HLFVBQVU7QUFDaEIsTUFBTUMsWUFBWTtBQUNsQixNQUFNQyxnQkFBZ0I7QUFFdEI7O0NBRUMsR0FDRCxNQUFNQztJQUNKOzs7Ozs7O0dBT0MsR0FDREMsWUFBWUMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFlBQVksQ0FBRTtRQUM1QyxJQUFJLENBQUNDLFdBQVcsR0FBR0YsY0FBYyxDQUFDO1FBRWxDLElBQUlDLGNBQWM7WUFDaEIsSUFBSSxDQUFDRSxhQUFhLEdBQUdGO1lBQ3JCLElBQUksQ0FBQ0csV0FBVyxHQUFHZixPQUFPQyxLQUFLLENBQUM7UUFDbEM7UUFFQSxJQUFJLENBQUNlLE9BQU8sR0FBR047UUFFZixJQUFJLENBQUNPLGNBQWMsR0FBRztRQUN0QixJQUFJLENBQUNDLFNBQVMsR0FBRztRQUVqQixJQUFJLENB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N0IsTUFBTSxDQUFDQSxPQUFPL0IsTUFBTSxHQUFHLEVBQUU7UUFFMUMsSUFBSSxPQUFPNEQsYUFBYSxZQUFZQSxTQUFTckI7SUFDL0M7QUFDRjtBQUVBOzs7Ozs7O0NBT0MsR0FDRCxTQUFTTyxRQUFRWSxNQUFNLEVBQUVuQixHQUFHLEVBQUUzQixFQUFFO0lBQzlCK0IsY0FBY2UsUUFBUW5CLEtBQUszQjtJQUMzQjhDLE9BQU9wRSxPQUFPLENBQUNpRDtBQUNqQiIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJhZm9ybWF0aW9uLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL25vZGVfbW9kdWxlcy93cy9saWIvc2VuZGVyLmpzPzU0MmQiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4XCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IHJhbmRvbUZpbGxTeW5jIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcblxuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3QgeyBFTVBUWV9CVUZGRVIsIGtXZWJTb2NrZXQsIE5PT1AgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5jb25zdCB7IGlzQmxvYiwgaXNWYWxpZFN0YXR1c0NvZGUgfSA9IHJlcXVpcmUoJy4vdmFsaWRhdGlvbicpO1xuY29uc3QgeyBtYXNrOiBhcHBseU1hc2ssIHRvQnVmZmVyIH0gPSByZXF1aXJlKCcuL2J1ZmZlci11dGlsJyk7XG5cbmNvbnN0IGtCeXRlTGVuZ3RoID0gU3ltYm9sKCdrQnl0ZUxlbmd0aCcpO1xuY29uc3QgbWFza0J1ZmZlciA9IEJ1ZmZlci5hbGxvYyg0KTtcbmNvbnN0IFJBTkRPTV9QT09MX1NJWkUgPSA4ICogMTAyNDtcbmxldCByYW5kb21Qb29sO1xubGV0IHJhbmRvbVBvb2xQb2ludGVyID0gUkFORE9NX1BPT0xfU0laRTtcblxuY29uc3QgREVGQVVMVCA9IDA7XG5jb25zdCBERUZMQVRJTkcgPSAxO1xuY29uc3QgR0VUX0JMT0JfREFUQSA9IDI7XG5cbi8qKlxuICogSHlCaSBTZW5kZXIgaW1wbGVtZW50YXRpb24uXG4gKi9cbmNsYXNzIFNlbmRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgU2VuZGVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBjb25uZWN0aW9uIHNvY2tldFxuICAgKiBAcGFyYW0ge09iamVjdH0gW2V4dGVuc2lvbnNdIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBuZWdvdGlhdGVkIGV4dGVuc2lvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2dlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKi9cbiAgY29uc3RydWN0b3Ioc29ja2V0LCBleHRlbnNpb25zLCBnZW5lcmF0ZU1hc2spIHtcbiAgICB0aGlzLl9leHRlbnNpb25zID0gZXh0ZW5zaW9ucyB8fCB7fTtcblxuICAgIGlmIChnZW5lcmF0ZU1hc2spIHtcbiAgICAgIHRoaXMuX2dlbmVyYXRlTWFzayA9IGdlbmVyYXRlTWFzaztcbiAgICAgIHRoaXMuX21hc2tCdWZmZXIgPSBCdWZmZXIuYWxsb2MoNCk7XG4gICAgfVxuXG4gICAgdGhpcy5fc29ja2V0ID0gc29ja2V0O1xuXG4gICAgdGhpcy5fZmlyc3RGcmFnbWVudCA9IHRydWU7XG4gICAgdGhpcy5fY29tcHJlc3MgPSBmYWxzZTtcblxuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgPSAwO1xuICAgIHRoaXMuX3F1ZXVlID0gW107XG4gICAgdGhpcy5fc3RhdGUgPSBERUZBVUxUO1xuICAgIHRoaXMub25lcnJvciA9IE5PT1A7XG4gICAgdGhpc1trV2ViU29ja2V0XSA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBGcmFtZXMgYSBwaWVjZSBvZiBkYXRhIGFjY29yZGluZyB0byB0aGUgSHlCaSBXZWJTb2NrZXQgcHJvdG9jb2wuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlcnxTdHJpbmcpfSBkYXRhIFRoZSBkYXRhIHRvIGZyYW1lXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgRklOIGJpdFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5nZW5lcmF0ZU1hc2tdIFRoZSBmdW5jdGlvbiB1c2VkIHRvIGdlbmVyYXRlIHRoZVxuICAgKiAgICAgbWFza2luZyBrZXlcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5tYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFza1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7QnVmZmVyfSBbb3B0aW9ucy5tYXNrQnVmZmVyXSBUaGUgYnVmZmVyIHVzZWQgdG8gc3RvcmUgdGhlIG1hc2tpbmdcbiAgICogICAgIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gb3B0aW9ucy5vcGNvZGUgVGhlIG9wY29kZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJlYWRPbmx5PWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgY2FuIGJlXG4gICAqICAgICBtb2RpZmllZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnJzdjE9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBSU1YxIGJpdFxuICAgKiBAcmV0dXJuIHsoQnVmZmVyfFN0cmluZylbXX0gVGhlIGZyYW1lZCBkYXRhXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHN0YXRpYyBmcmFtZShkYXRhLCBvcHRpb25zKSB7XG4gICAgbGV0IG1hc2s7XG4gICAgbGV0IG1lcmdlID0gZmFsc2U7XG4gICAgbGV0IG9mZnNldCA9IDI7XG4gICAgbGV0IHNraXBNYXNraW5nID0gZmFsc2U7XG5cbiAgICBpZiAob3B0aW9ucy5tYXNrKSB7XG4gICAgICBtYXNrID0gb3B0aW9ucy5tYXNrQnVmZmVyIHx8IG1hc2tCdWZmZXI7XG5cbiAgICAgIGlmIChvcHRpb25zLmdlbmVyYXRlTWFzaykge1xuICAgICAgICBvcHRpb25zLmdlbmVyYXRlTWFzayhtYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChyYW5kb21Qb29sUG9pbnRlciA9PT0gUkFORE9NX1BPT0xfU0laRSkge1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICAqL1xuICAgICAgICAgIGlmIChyYW5kb21Qb29sID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAvLyBUaGlzIGlzIGxhemlseSBpbml0aWFsaXplZCBiZWNhdXNlIHNlcnZlci1zZW50IGZyYW1lcyBtdXN0IG5vdFxuICAgICAgICAgICAgLy8gYmUgbWFza2VkIHNvIGl0IG1heSBuZXZlciBiZSB1c2VkLlxuICAgICAgICAgICAgLy9cbiAgICAgICAgICAgIHJhbmRvbVBvb2wgPSBCdWZmZXIuYWxsb2MoUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgcmFuZG9tRmlsbFN5bmMocmFuZG9tUG9vbCwgMCwgUkFORE9NX1BPT0xfU0laRSk7XG4gICAgICAgICAgcmFuZG9tUG9vbFBvaW50ZXIgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgbWFza1swXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICAgIG1hc2tbMV0gPSByYW5kb21Qb29sW3JhbmRvbVBvb2xQb2ludGVyKytdO1xuICAgICAgICBtYXNrWzJdID0gcmFuZG9tUG9vbFtyYW5kb21Qb29sUG9pbnRlcisrXTtcbiAgICAgICAgbWFza1szXSA9IHJhbmRvbVBvb2xbcmFuZG9tUG9vbFBvaW50ZXIrK107XG4gICAgICB9XG5cbiAgICAgIHNraXBNYXNraW5nID0gKG1hc2tbMF0gfCBtYXNrWzFdIHwgbWFza1syXSB8IG1hc2tbM10pID09PSAwO1xuICAgICAgb2Zmc2V0ID0gNjtcbiAgICB9XG5cbiAgICBsZXQgZGF0YUxlbmd0aDtcblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmIChcbiAgICAgICAgKCFvcHRpb25zLm1hc2sgfHwgc2tpcE1hc2tpbmcpICYmXG4gICAgICAgIG9wdGlvbnNba0J5dGVMZW5ndGhdICE9PSB1bmRlZmluZWRcbiAgICAgICkge1xuICAgICAgICBkYXRhTGVuZ3RoID0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkYXRhID0gQnVmZmVyLmZyb20oZGF0YSk7XG4gICAgICAgIGRhdGFMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgbWVyZ2UgPSBvcHRpb25zLm1hc2sgJiYgb3B0aW9ucy5yZWFkT25seSAmJiAhc2tpcE1hc2tpbmc7XG4gICAgfVxuXG4gICAgbGV0IHBheWxvYWRMZW5ndGggPSBkYXRhTGVuZ3RoO1xuXG4gICAgaWYgKGRhdGFMZW5ndGggPj0gNjU1MzYpIHtcbiAgICAgIG9mZnNldCArPSA4O1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNztcbiAgICB9IGVsc2UgaWYgKGRhdGFMZW5ndGggPiAxMjUpIHtcbiAgICAgIG9mZnNldCArPSAyO1xuICAgICAgcGF5bG9hZExlbmd0aCA9IDEyNjtcbiAgICB9XG5cbiAgICBjb25zdCB0YXJnZXQgPSBCdWZmZXIuYWxsb2NVbnNhZmUobWVyZ2UgPyBkYXRhTGVuZ3RoICsgb2Zmc2V0IDogb2Zmc2V0KTtcblxuICAgIHRhcmdldFswXSA9IG9wdGlvbnMuZmluID8gb3B0aW9ucy5vcGNvZGUgfCAweDgwIDogb3B0aW9ucy5vcGNvZGU7XG4gICAgaWYgKG9wdGlvbnMucnN2MSkgdGFyZ2V0WzBdIHw9IDB4NDA7XG5cbiAgICB0YXJnZXRbMV0gPSBwYXlsb2FkTGVuZ3RoO1xuXG4gICAgaWYgKHBheWxvYWRMZW5ndGggPT09IDEyNikge1xuICAgICAgdGFyZ2V0LndyaXRlVUludDE2QkUoZGF0YUxlbmd0aCwgMik7XG4gICAgfSBlbHNlIGlmIChwYXlsb2FkTGVuZ3RoID09PSAxMjcpIHtcbiAgICAgIHRhcmdldFsyXSA9IHRhcmdldFszXSA9IDA7XG4gICAgICB0YXJnZXQud3JpdGVVSW50QkUoZGF0YUxlbmd0aCwgNCwgNik7XG4gICAgfVxuXG4gICAgaWYgKCFvcHRpb25zLm1hc2spIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIHRhcmdldFsxXSB8PSAweDgwO1xuICAgIHRhcmdldFtvZmZzZXQgLSA0XSA9IG1hc2tbMF07XG4gICAgdGFyZ2V0W29mZnNldCAtIDNdID0gbWFza1sxXTtcbiAgICB0YXJnZXRbb2Zmc2V0IC0gMl0gPSBtYXNrWzJdO1xuICAgIHRhcmdldFtvZmZzZXQgLSAxXSA9IG1hc2tbM107XG5cbiAgICBpZiAoc2tpcE1hc2tpbmcpIHJldHVybiBbdGFyZ2V0LCBkYXRhXTtcblxuICAgIGlmIChtZXJnZSkge1xuICAgICAgYXBwbHlNYXNrKGRhdGEsIG1hc2ssIHRhcmdldCwgb2Zmc2V0LCBkYXRhTGVuZ3RoKTtcbiAgICAgIHJldHVybiBbdGFyZ2V0XTtcbiAgICB9XG5cbiAgICBhcHBseU1hc2soZGF0YSwgbWFzaywgZGF0YSwgMCwgZGF0YUxlbmd0aCk7XG4gICAgcmV0dXJuIFt0YXJnZXQsIGRhdGFdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgY2xvc2UgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBUaGUgc3RhdHVzIGNvZGUgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIG1lc3NhZ2UgY29tcG9uZW50IG9mIHRoZSBib2R5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIHRoZSBtZXNzYWdlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnVmO1xuXG4gICAgaWYgKGNvZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgYnVmID0gRU1QVFlfQlVGRkVSO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGNvZGUgIT09ICdudW1iZXInIHx8ICFpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHZhbGlkIGVycm9yIGNvZGUgbnVtYmVyJyk7XG4gICAgfSBlbHNlIGlmIChkYXRhID09PSB1bmRlZmluZWQgfHwgIWRhdGEubGVuZ3RoKSB7XG4gICAgICBidWYgPSBCdWZmZXIuYWxsb2NVbnNhZmUoMik7XG4gICAgICBidWYud3JpdGVVSW50MTZCRShjb2RlLCAwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG5cbiAgICAgIGlmIChsZW5ndGggPiAxMjMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBtZXNzYWdlIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjMgYnl0ZXMnKTtcbiAgICAgIH1cblxuICAgICAgYnVmID0gQnVmZmVyLmFsbG9jVW5zYWZlKDIgKyBsZW5ndGgpO1xuICAgICAgYnVmLndyaXRlVUludDE2QkUoY29kZSwgMCk7XG5cbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgYnVmLndyaXRlKGRhdGEsIDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnVmLnNldChkYXRhLCAyKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnVmLmxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MDgsXG4gICAgICByZWFkT25seTogZmFsc2UsXG4gICAgICByc3YxOiBmYWxzZVxuICAgIH07XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgYnVmLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGJ1Ziwgb3B0aW9ucyksIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogU2VuZHMgYSBwaW5nIG1lc3NhZ2UgdG8gdGhlIG90aGVyIHBlZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW21hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBpbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBsZXQgYnl0ZUxlbmd0aDtcbiAgICBsZXQgcmVhZE9ubHk7XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdzdHJpbmcnKSB7XG4gICAgICBieXRlTGVuZ3RoID0gQnVmZmVyLmJ5dGVMZW5ndGgoZGF0YSk7XG4gICAgICByZWFkT25seSA9IGZhbHNlO1xuICAgIH0gZWxzZSBpZiAoaXNCbG9iKGRhdGEpKSB7XG4gICAgICBieXRlTGVuZ3RoID0gZGF0YS5zaXplO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGF0YSA9IHRvQnVmZmVyKGRhdGEpO1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEubGVuZ3RoO1xuICAgICAgcmVhZE9ubHkgPSB0b0J1ZmZlci5yZWFkT25seTtcbiAgICB9XG5cbiAgICBpZiAoYnl0ZUxlbmd0aCA+IDEyNSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RoZSBkYXRhIHNpemUgbXVzdCBub3QgYmUgZ3JlYXRlciB0aGFuIDEyNSBieXRlcycpO1xuICAgIH1cblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBba0J5dGVMZW5ndGhdOiBieXRlTGVuZ3RoLFxuICAgICAgZmluOiB0cnVlLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrLFxuICAgICAgbWFza0J1ZmZlcjogdGhpcy5fbWFza0J1ZmZlcixcbiAgICAgIG9wY29kZTogMHgwOSxcbiAgICAgIHJlYWRPbmx5LFxuICAgICAgcnN2MTogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgaWYgKHRoaXMuX3N0YXRlICE9PSBERUZBVUxUKSB7XG4gICAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5nZXRCbG9iRGF0YSwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmdldEJsb2JEYXRhKGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYik7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgdGhpcy5lbnF1ZXVlKFt0aGlzLmRpc3BhdGNoLCBkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2JdKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgcG9uZyBtZXNzYWdlIHRvIHRoZSBvdGhlciBwZWVyLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHVibGljXG4gICAqL1xuICBwb25nKGRhdGEsIG1hc2ssIGNiKSB7XG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKGJ5dGVMZW5ndGggPiAxMjUpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdUaGUgZGF0YSBzaXplIG11c3Qgbm90IGJlIGdyZWF0ZXIgdGhhbiAxMjUgYnl0ZXMnKTtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgW2tCeXRlTGVuZ3RoXTogYnl0ZUxlbmd0aCxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIGdlbmVyYXRlTWFzazogdGhpcy5fZ2VuZXJhdGVNYXNrLFxuICAgICAgbWFzayxcbiAgICAgIG1hc2tCdWZmZXI6IHRoaXMuX21hc2tCdWZmZXIsXG4gICAgICBvcGNvZGU6IDB4MGEsXG4gICAgICByZWFkT25seSxcbiAgICAgIHJzdjE6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIGZhbHNlLCBvcHRpb25zLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCBmYWxzZSwgb3B0aW9ucywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgZmFsc2UsIG9wdGlvbnMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuc2VuZEZyYW1lKFNlbmRlci5mcmFtZShkYXRhLCBvcHRpb25zKSwgY2IpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kcyBhIGRhdGEgbWVzc2FnZSB0byB0aGUgb3RoZXIgcGVlci5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXNzYWdlIHRvIHNlbmRcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5iaW5hcnk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBpcyBiaW5hcnlcbiAgICogICAgIG9yIHRleHRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jb21wcmVzcz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBjb21wcmVzcyBgZGF0YWBcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IHRoaXMuX2V4dGVuc2lvbnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV07XG4gICAgbGV0IG9wY29kZSA9IG9wdGlvbnMuYmluYXJ5ID8gMiA6IDE7XG4gICAgbGV0IHJzdjEgPSBvcHRpb25zLmNvbXByZXNzO1xuXG4gICAgbGV0IGJ5dGVMZW5ndGg7XG4gICAgbGV0IHJlYWRPbmx5O1xuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgYnl0ZUxlbmd0aCA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGRhdGEpO1xuICAgICAgcmVhZE9ubHkgPSBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKGlzQmxvYihkYXRhKSkge1xuICAgICAgYnl0ZUxlbmd0aCA9IGRhdGEuc2l6ZTtcbiAgICAgIHJlYWRPbmx5ID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGEgPSB0b0J1ZmZlcihkYXRhKTtcbiAgICAgIGJ5dGVMZW5ndGggPSBkYXRhLmxlbmd0aDtcbiAgICAgIHJlYWRPbmx5ID0gdG9CdWZmZXIucmVhZE9ubHk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2ZpcnN0RnJhZ21lbnQpIHtcbiAgICAgIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSBmYWxzZTtcbiAgICAgIGlmIChcbiAgICAgICAgcnN2MSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5wYXJhbXNbXG4gICAgICAgICAgcGVyTWVzc2FnZURlZmxhdGUuX2lzU2VydmVyXG4gICAgICAgICAgICA/ICdzZXJ2ZXJfbm9fY29udGV4dF90YWtlb3ZlcidcbiAgICAgICAgICAgIDogJ2NsaWVudF9ub19jb250ZXh0X3Rha2VvdmVyJ1xuICAgICAgICBdXG4gICAgICApIHtcbiAgICAgICAgcnN2MSA9IGJ5dGVMZW5ndGggPj0gcGVyTWVzc2FnZURlZmxhdGUuX3RocmVzaG9sZDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NvbXByZXNzID0gcnN2MTtcbiAgICB9IGVsc2Uge1xuICAgICAgcnN2MSA9IGZhbHNlO1xuICAgICAgb3Bjb2RlID0gMDtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5maW4pIHRoaXMuX2ZpcnN0RnJhZ21lbnQgPSB0cnVlO1xuXG4gICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgIFtrQnl0ZUxlbmd0aF06IGJ5dGVMZW5ndGgsXG4gICAgICBmaW46IG9wdGlvbnMuZmluLFxuICAgICAgZ2VuZXJhdGVNYXNrOiB0aGlzLl9nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXNrOiBvcHRpb25zLm1hc2ssXG4gICAgICBtYXNrQnVmZmVyOiB0aGlzLl9tYXNrQnVmZmVyLFxuICAgICAgb3Bjb2RlLFxuICAgICAgcmVhZE9ubHksXG4gICAgICByc3YxXG4gICAgfTtcblxuICAgIGlmIChpc0Jsb2IoZGF0YSkpIHtcbiAgICAgIGlmICh0aGlzLl9zdGF0ZSAhPT0gREVGQVVMVCkge1xuICAgICAgICB0aGlzLmVucXVldWUoW3RoaXMuZ2V0QmxvYkRhdGEsIGRhdGEsIHRoaXMuX2NvbXByZXNzLCBvcHRzLCBjYl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5nZXRCbG9iRGF0YShkYXRhLCB0aGlzLl9jb21wcmVzcywgb3B0cywgY2IpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodGhpcy5fc3RhdGUgIT09IERFRkFVTFQpIHtcbiAgICAgIHRoaXMuZW5xdWV1ZShbdGhpcy5kaXNwYXRjaCwgZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGF0Y2goZGF0YSwgdGhpcy5fY29tcHJlc3MsIG9wdHMsIGNiKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgY29udGVudHMgb2YgYSBibG9iIGFzIGJpbmFyeSBkYXRhLlxuICAgKlxuICAgKiBAcGFyYW0ge0Jsb2J9IGJsb2IgVGhlIGJsb2JcbiAgICogQHBhcmFtIHtCb29sZWFufSBbY29tcHJlc3M9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgdGhlIGRhdGFcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgT3B0aW9ucyBvYmplY3RcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5maW49ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBzZXQgdGhlXG4gICAqICAgICBGSU4gYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLm1hc2s9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBtYXNrXG4gICAqICAgICBgZGF0YWBcbiAgICogQHBhcmFtIHtCdWZmZXJ9IFtvcHRpb25zLm1hc2tCdWZmZXJdIFRoZSBidWZmZXIgdXNlZCB0byBzdG9yZSB0aGUgbWFza2luZ1xuICAgKiAgICAga2V5XG4gICAqIEBwYXJhbSB7TnVtYmVyfSBvcHRpb25zLm9wY29kZSBUaGUgb3Bjb2RlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucmVhZE9ubHk9ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIGBkYXRhYCBjYW4gYmVcbiAgICogICAgIG1vZGlmaWVkXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMucnN2MT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIFJTVjEgYml0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGdldEJsb2JEYXRhKGJsb2IsIGNvbXByZXNzLCBvcHRpb25zLCBjYikge1xuICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgKz0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fc3RhdGUgPSBHRVRfQkxPQl9EQVRBO1xuXG4gICAgYmxvYlxuICAgICAgLmFycmF5QnVmZmVyKClcbiAgICAgIC50aGVuKChhcnJheUJ1ZmZlcikgPT4ge1xuICAgICAgICBpZiAodGhpcy5fc29ja2V0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcbiAgICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgdGhlIGJsb2Igd2FzIGJlaW5nIHJlYWQnXG4gICAgICAgICAgKTtcblxuICAgICAgICAgIC8vXG4gICAgICAgICAgLy8gYGNhbGxDYWxsYmFja3NgIGlzIGNhbGxlZCBpbiB0aGUgbmV4dCB0aWNrIHRvIGVuc3VyZSB0aGF0IGVycm9yc1xuICAgICAgICAgIC8vIHRoYXQgbWlnaHQgYmUgdGhyb3duIGluIHRoZSBjYWxsYmFja3MgYmVoYXZlIGxpa2UgZXJyb3JzIHRocm93blxuICAgICAgICAgIC8vIG91dHNpZGUgdGhlIHByb21pc2UgY2hhaW4uXG4gICAgICAgICAgLy9cbiAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxDYWxsYmFja3MsIHRoaXMsIGVyciwgY2IpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0b0J1ZmZlcihhcnJheUJ1ZmZlcik7XG5cbiAgICAgICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgICAgIHRoaXMuX3N0YXRlID0gREVGQVVMVDtcbiAgICAgICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoZGF0YSwgb3B0aW9ucyksIGNiKTtcbiAgICAgICAgICB0aGlzLmRlcXVldWUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRpc3BhdGNoKGRhdGEsIGNvbXByZXNzLCBvcHRpb25zLCBjYik7XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICAuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAvL1xuICAgICAgICAvLyBgb25FcnJvcmAgaXMgY2FsbGVkIGluIHRoZSBuZXh0IHRpY2sgZm9yIHRoZSBzYW1lIHJlYXNvbiB0aGF0XG4gICAgICAgIC8vIGBjYWxsQ2FsbGJhY2tzYCBhYm92ZSBpcy5cbiAgICAgICAgLy9cbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhvbkVycm9yLCB0aGlzLCBlcnIsIGNiKTtcbiAgICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3BhdGNoZXMgYSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyhCdWZmZXJ8U3RyaW5nKX0gZGF0YSBUaGUgbWVzc2FnZSB0byBzZW5kXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW2NvbXByZXNzPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gY29tcHJlc3NcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBPcHRpb25zIG9iamVjdFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmZpbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIHNldCB0aGVcbiAgICogICAgIEZJTiBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAgICogICAgIG1hc2tpbmcga2V5XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFzaz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2tcbiAgICogICAgIGBkYXRhYFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gW29wdGlvbnMubWFza0J1ZmZlcl0gVGhlIGJ1ZmZlciB1c2VkIHRvIHN0b3JlIHRoZSBtYXNraW5nXG4gICAqICAgICBrZXlcbiAgICogQHBhcmFtIHtOdW1iZXJ9IG9wdGlvbnMub3Bjb2RlIFRoZSBvcGNvZGVcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yZWFkT25seT1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgYGRhdGFgIGNhbiBiZVxuICAgKiAgICAgbW9kaWZpZWRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5yc3YxPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG8gc2V0IHRoZVxuICAgKiAgICAgUlNWMSBiaXRcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFja1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGlzcGF0Y2goZGF0YSwgY29tcHJlc3MsIG9wdGlvbnMsIGNiKSB7XG4gICAgaWYgKCFjb21wcmVzcykge1xuICAgICAgdGhpcy5zZW5kRnJhbWUoU2VuZGVyLmZyYW1lKGRhdGEsIG9wdGlvbnMpLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgcGVyTWVzc2FnZURlZmxhdGUgPSB0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdO1xuXG4gICAgdGhpcy5fYnVmZmVyZWRCeXRlcyArPSBvcHRpb25zW2tCeXRlTGVuZ3RoXTtcbiAgICB0aGlzLl9zdGF0ZSA9IERFRkxBVElORztcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZS5jb21wcmVzcyhkYXRhLCBvcHRpb25zLmZpbiwgKF8sIGJ1ZikgPT4ge1xuICAgICAgaWYgKHRoaXMuX3NvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgICAgICdUaGUgc29ja2V0IHdhcyBjbG9zZWQgd2hpbGUgZGF0YSB3YXMgYmVpbmcgY29tcHJlc3NlZCdcbiAgICAgICAgKTtcblxuICAgICAgICBjYWxsQ2FsbGJhY2tzKHRoaXMsIGVyciwgY2IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2J1ZmZlcmVkQnl0ZXMgLT0gb3B0aW9uc1trQnl0ZUxlbmd0aF07XG4gICAgICB0aGlzLl9zdGF0ZSA9IERFRkFVTFQ7XG4gICAgICBvcHRpb25zLnJlYWRPbmx5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNlbmRGcmFtZShTZW5kZXIuZnJhbWUoYnVmLCBvcHRpb25zKSwgY2IpO1xuICAgICAgdGhpcy5kZXF1ZXVlKCk7XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogRXhlY3V0ZXMgcXVldWVkIHNlbmQgb3BlcmF0aW9ucy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGRlcXVldWUoKSB7XG4gICAgd2hpbGUgKHRoaXMuX3N0YXRlID09PSBERUZBVUxUICYmIHRoaXMuX3F1ZXVlLmxlbmd0aCkge1xuICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcXVldWUuc2hpZnQoKTtcblxuICAgICAgdGhpcy5fYnVmZmVyZWRCeXRlcyAtPSBwYXJhbXNbM11ba0J5dGVMZW5ndGhdO1xuICAgICAgUmVmbGVjdC5hcHBseShwYXJhbXNbMF0sIHRoaXMsIHBhcmFtcy5zbGljZSgxKSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEVucXVldWVzIGEgc2VuZCBvcGVyYXRpb24uXG4gICAqXG4gICAqIEBwYXJhbSB7QXJyYXl9IHBhcmFtcyBTZW5kIG9wZXJhdGlvbiBwYXJhbWV0ZXJzLlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZW5xdWV1ZShwYXJhbXMpIHtcbiAgICB0aGlzLl9idWZmZXJlZEJ5dGVzICs9IHBhcmFtc1szXVtrQnl0ZUxlbmd0aF07XG4gICAgdGhpcy5fcXVldWUucHVzaChwYXJhbXMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlbmRzIGEgZnJhbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7KEJ1ZmZlciB8IFN0cmluZylbXX0gbGlzdCBUaGUgZnJhbWUgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2JdIENhbGxiYWNrXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZW5kRnJhbWUobGlzdCwgY2IpIHtcbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDIpIHtcbiAgICAgIHRoaXMuX3NvY2tldC5jb3JrKCk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSk7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFsxXSwgY2IpO1xuICAgICAgdGhpcy5fc29ja2V0LnVuY29yaygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zb2NrZXQud3JpdGUobGlzdFswXSwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFNlbmRlcjtcblxuLyoqXG4gKiBDYWxscyBxdWV1ZWQgY2FsbGJhY2tzIHdpdGggYW4gZXJyb3IuXG4gKlxuICogQHBhcmFtIHtTZW5kZXJ9IHNlbmRlciBUaGUgYFNlbmRlcmAgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IGVyciBUaGUgZXJyb3IgdG8gY2FsbCB0aGUgY2FsbGJhY2tzIHdpdGhcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gVGhlIGZpcnN0IGNhbGxiYWNrXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBjYWxsQ2FsbGJhY2tzKHNlbmRlciwgZXJyLCBjYikge1xuICBpZiAodHlwZW9mIGNiID09PSAnZnVuY3Rpb24nKSBjYihlcnIpO1xuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc2VuZGVyLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHNlbmRlci5fcXVldWVbaV07XG4gICAgY29uc3QgY2FsbGJhY2sgPSBwYXJhbXNbcGFyYW1zLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykgY2FsbGJhY2soZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIEhhbmRsZXMgYSBgU2VuZGVyYCBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1NlbmRlcn0gc2VuZGVyIFRoZSBgU2VuZGVyYCBpbnN0YW5jZVxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBUaGUgZmlyc3QgcGVuZGluZyBjYWxsYmFja1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gb25FcnJvcihzZW5kZXIsIGVyciwgY2IpIHtcbiAgY2FsbENhbGxiYWNrcyhzZW5kZXIsIGVyciwgY2IpO1xuICBzZW5kZXIub25lcnJvcihlcnIpO1xufVxuIl0sIm5hbWVzIjpbIkR1cGxleCIsInJlcXVpcmUiLCJyYW5kb21GaWxsU3luYyIsIlBlck1lc3NhZ2VEZWZsYXRlIiwiRU1QVFlfQlVGRkVSIiwia1dlYlNvY2tldCIsIk5PT1AiLCJpc0Jsb2IiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsIm1hc2siLCJhcHBseU1hc2siLCJ0b0J1ZmZlciIsImtCeXRlTGVuZ3RoIiwiU3ltYm9sIiwibWFza0J1ZmZlciIsIkJ1ZmZlciIsImFsbG9jIiwiUkFORE9NX1BPT0xfU0laRSIsInJhbmRvbVBvb2wiLCJyYW5kb21Qb29sUG9pbnRlciIsIkRFRkFVTFQiLCJERUZMQVRJTkciLCJHRVRfQkxPQl9EQVRBIiwiU2VuZGVyIiwiY29uc3RydWN0b3IiLCJzb2NrZXQiLCJleHRlbnNpb25zIiwiZ2VuZXJhdGVNYXNrIiwiX2V4dGVuc2lvbnMiLCJfZ2VuZXJhdGVNYXNrIiwiX21hc2tCdWZmZXIiLCJfc29ja2V0IiwiX2ZpcnN0RnJhZ21lbnQiLCJfY29tcHJlc3MiLCJfYnVmZmVyZWRCeXRlcyIsIl9xdWV1ZSIsIl9zdGF0ZSIsIm9uZXJyb3IiLCJ1bmRlZmluZWQiLCJmcmFtZSIsImRhdGEiLCJvcHRpb25zIiwibWVyZ2UiLCJvZmZzZXQiLCJza2lwTWFza2luZyIsImRhdGFMZW5ndGgiLCJmcm9tIiwibGVuZ3RoIiwicmVhZE9ubHkiLCJwYXlsb2FkTGVuZ3RoIiwidGFyZ2V0IiwiYWxsb2NVbnNhZmUiLCJmaW4iLCJvcGNvZGUiLCJyc3YxIiwid3JpdGVVSW50MTZCRSIsIndyaXRlVUludEJFIiwiY2xvc2UiLCJjb2RlIiwiY2IiLCJidWYiLCJUeXBlRXJyb3IiLCJieXRlTGVuZ3RoIiwiUmFuZ2VFcnJvciIsIndyaXRlIiwic2V0IiwiZW5xdWV1ZSIsImRpc3BhdGNoIiwic2VuZEZyYW1lIiwicGluZyIsInNpemUiLCJnZXRCbG9iRGF0YSIsInBvbmciLCJzZW5kIiwicGVyTWVzc2FnZURlZmxhdGUiLCJleHRlbnNpb25OYW1lIiwiYmluYXJ5IiwiY29tcHJlc3MiLCJwYXJhbXMiLCJfaXNTZXJ2ZXIiLCJfdGhyZXNob2xkIiwib3B0cyIsImJsb2IiLCJhcnJheUJ1ZmZlciIsInRoZW4iLCJkZXN0cm95ZWQiLCJlcnIiLCJFcnJvciIsInByb2Nlc3MiLCJuZXh0VGljayIsImNhbGxDYWxsYmFja3MiLCJkZXF1ZXVlIiwiY2F0Y2giLCJvbkVycm9yIiwiXyIsInNoaWZ0IiwiUmVmbGVjdCIsImFwcGx5Iiwic2xpY2UiLCJwdXNoIiwibGlzdCIsImNvcmsiLCJ1bmNvcmsiLCJtb2R1bGUiLCJleHBvcnRzIiwic2VuZGVyIiwiaSIsImNhbGxiYWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/sender.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/stream.js":
/*!*******************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/stream.js ***!
  \*******************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^WebSocket$\" }] */ \nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket.js\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Emits the `'close'` event on a stream.\n *\n * @param {Duplex} stream The stream.\n * @private\n */ function emitClose(stream) {\n    stream.emit(\"close\");\n}\n/**\n * The listener of the `'end'` event.\n *\n * @private\n */ function duplexOnEnd() {\n    if (!this.destroyed && this._writableState.finished) {\n        this.destroy();\n    }\n}\n/**\n * The listener of the `'error'` event.\n *\n * @param {Error} err The error\n * @private\n */ function duplexOnError(err) {\n    this.removeListener(\"error\", duplexOnError);\n    this.destroy();\n    if (this.listenerCount(\"error\") === 0) {\n        // Do not suppress the throwing behavior.\n        this.emit(\"error\", err);\n    }\n}\n/**\n * Wraps a `WebSocket` in a duplex stream.\n *\n * @param {WebSocket} ws The `WebSocket` to wrap\n * @param {Object} [options] The options for the `Duplex` constructor\n * @return {Duplex} The duplex stream\n * @public\n */ function createWebSocketStream(ws, options) {\n    let terminateOnDestroy = true;\n    const duplex = new Duplex({\n        ...options,\n        autoDestroy: false,\n        emitClose: false,\n        objectMode: false,\n        writableObjectMode: false\n    });\n    ws.on(\"message\", function message(msg, isBinary) {\n        const data = !isBinary && duplex._readableState.objectMode ? msg.toString() : msg;\n        if (!duplex.push(data)) ws.pause();\n    });\n    ws.once(\"error\", function error(err) {\n        if (duplex.destroyed) return;\n        // Prevent `ws.terminate()` from being called by `duplex._destroy()`.\n        //\n        // - If the `'error'` event is emitted before the `'open'` event, then\n        //   `ws.terminate()` is a noop as no socket is assigned.\n        // - Otherwise, the error is re-emitted by the listener of the `'error'`\n        //   event of the `Receiver` object. The listener already closes the\n        //   connection by calling `ws.close()`. This allows a close frame to be\n        //   sent to the other peer. If `ws.terminate()` is called right after this,\n        //   then the close frame might not be sent.\n        terminateOnDestroy = false;\n        duplex.destroy(err);\n    });\n    ws.once(\"close\", function close() {\n        if (duplex.destroyed) return;\n        duplex.push(null);\n    });\n    duplex._destroy = function(err, callback) {\n        if (ws.readyState === ws.CLOSED) {\n            callback(err);\n            process.nextTick(emitClose, duplex);\n            return;\n        }\n        let called = false;\n        ws.once(\"error\", function error(err) {\n            called = true;\n            callback(err);\n        });\n        ws.once(\"close\", function close() {\n            if (!called) callback(err);\n            process.nextTick(emitClose, duplex);\n        });\n        if (terminateOnDestroy) ws.terminate();\n    };\n    duplex._final = function(callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._final(callback);\n            });\n            return;\n        }\n        // If the value of the `_socket` property is `null` it means that `ws` is a\n        // client websocket and the handshake failed. In fact, when this happens, a\n        // socket is never assigned to the websocket. Wait for the `'error'` event\n        // that will be emitted by the websocket.\n        if (ws._socket === null) return;\n        if (ws._socket._writableState.finished) {\n            callback();\n            if (duplex._readableState.endEmitted) duplex.destroy();\n        } else {\n            ws._socket.once(\"finish\", function finish() {\n                // `duplex` is not destroyed here because the `'end'` event will be\n                // emitted on `duplex` after this `'finish'` event. The EOF signaling\n                // `null` chunk is, in fact, pushed when the websocket emits `'close'`.\n                callback();\n            });\n            ws.close();\n        }\n    };\n    duplex._read = function() {\n        if (ws.isPaused) ws.resume();\n    };\n    duplex._write = function(chunk, encoding, callback) {\n        if (ws.readyState === ws.CONNECTING) {\n            ws.once(\"open\", function open() {\n                duplex._write(chunk, encoding, callback);\n            });\n            return;\n        }\n        ws.send(chunk, callback);\n    };\n    duplex.on(\"end\", duplexOnEnd);\n    duplex.on(\"error\", duplexOnError);\n    return duplex;\n}\nmodule.exports = createWebSocketStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdHJlYW0uanMiLCJtYXBwaW5ncyI6IkFBQUEsNEVBQTRFLEdBQzVFO0FBRUEsTUFBTUEsWUFBWUMsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFQyxNQUFNLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFM0I7Ozs7O0NBS0MsR0FDRCxTQUFTRSxVQUFVQyxNQUFNO0lBQ3ZCQSxPQUFPQyxJQUFJLENBQUM7QUFDZDtBQUVBOzs7O0NBSUMsR0FDRCxTQUFTQztJQUNQLElBQUksQ0FBQyxJQUFJLENBQUNDLFNBQVMsSUFBSSxJQUFJLENBQUNDLGNBQWMsQ0FBQ0MsUUFBUSxFQUFFO1FBQ25ELElBQUksQ0FBQ0MsT0FBTztJQUNkO0FBQ0Y7QUFFQTs7Ozs7Q0FLQyxHQUNELFNBQVNDLGNBQWNDLEdBQUc7SUFDeEIsSUFBSSxDQUFDQyxjQUFjLENBQUMsU0FBU0Y7SUFDN0IsSUFBSSxDQUFDRCxPQUFPO0lBQ1osSUFBSSxJQUFJLENBQUNJLGFBQWEsQ0FBQyxhQUFhLEdBQUc7UUFDckMseUNBQXlDO1FBQ3pDLElBQUksQ0FBQ1QsSUFBSSxDQUFDLFNBQVNPO0lBQ3JCO0FBQ0Y7QUFFQTs7Ozs7OztDQU9DLEdBQ0QsU0FBU0csc0JBQXNCQyxFQUFFLEVBQUVDLE9BQU87SUFDeEMsSUFBSUMscUJBQXFCO0lBRXpCLE1BQU1DLFNBQVMsSUFBSWpCLE9BQU87UUFDeEIsR0FBR2UsT0FBTztRQUNWRyxhQUFhO1FBQ2JqQixXQUFXO1FBQ1hrQixZQUFZO1FBQ1pDLG9CQUFvQjtJQUN0QjtJQUVBTixHQUFHTyxFQUFFLENBQUMsV0FBVyxTQUFTQyxRQUFRQyxHQUFHLEVBQUVDLFFBQVE7UUFDN0MsTUFBTUMsT0FDSixDQUFDRCxZQUFZUCxPQUFPUyxjQUFjLENBQUNQLFVBQVUsR0FBR0ksSUFBSUksUUFBUSxLQUFLSjtRQUVuRSxJQUFJLENBQUNOLE9BQU9XLElBQUksQ0FBQ0gsT0FBT1gsR0FBR2UsS0FBSztJQUNsQztJQUVBZixHQUFHZ0IsSUFBSSxDQUFDLFNBQVMsU0FBU0MsTUFBTXJCLEdBQUc7UUFDakMsSUFBSU8sT0FBT1osU0FBUyxFQUFFO1FBRXRCLHFFQUFxRTtRQUNyRSxFQUFFO1FBQ0Ysc0VBQXNFO1FBQ3RFLHlEQUF5RDtRQUN6RCx3RUFBd0U7UUFDeEUsb0VBQW9FO1FBQ3BFLHdFQUF3RTtRQUN4RSw0RUFBNEU7UUFDNUUsNENBQTRDO1FBQzVDVyxxQkFBcUI7UUFDckJDLE9BQU9ULE9BQU8sQ0FBQ0U7SUFDakI7SUFFQUksR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNFO1FBQ3hCLElBQUlmLE9BQU9aLFNBQVMsRUFBRTtRQUV0QlksT0FBT1csSUFBSSxDQUFDO0lBQ2Q7SUFFQVgsT0FBT2dCLFFBQVEsR0FBRyxTQUFVdkIsR0FBRyxFQUFFd0IsUUFBUTtRQUN2QyxJQUFJcEIsR0FBR3FCLFVBQVUsS0FBS3JCLEdBQUdzQixNQUFNLEVBQUU7WUFDL0JGLFNBQVN4QjtZQUNUMkIsUUFBUUMsUUFBUSxDQUFDckMsV0FBV2dCO1lBQzVCO1FBQ0Y7UUFFQSxJQUFJc0IsU0FBUztRQUViekIsR0FBR2dCLElBQUksQ0FBQyxTQUFTLFNBQVNDLE1BQU1yQixHQUFHO1lBQ2pDNkIsU0FBUztZQUNUTCxTQUFTeEI7UUFDWDtRQUVBSSxHQUFHZ0IsSUFBSSxDQUFDLFNBQVMsU0FBU0U7WUFDeEIsSUFBSSxDQUFDTyxRQUFRTCxTQUFTeEI7WUFDdEIyQixRQUFRQyxRQUFRLENBQUNyQyxXQUFXZ0I7UUFDOUI7UUFFQSxJQUFJRCxvQkFBb0JGLEdBQUcwQixTQUFTO0lBQ3RDO0lBRUF2QixPQUFPd0IsTUFBTSxHQUFHLFNBQVVQLFFBQVE7UUFDaEMsSUFBSXBCLEdBQUdxQixVQUFVLEtBQUtyQixHQUFHNEIsVUFBVSxFQUFFO1lBQ25DNUIsR0FBR2dCLElBQUksQ0FBQyxRQUFRLFNBQVNhO2dCQUN2QjFCLE9BQU93QixNQUFNLENBQUNQO1lBQ2hCO1lBQ0E7UUFDRjtRQUVBLDJFQUEyRTtRQUMzRSwyRUFBMkU7UUFDM0UsMEVBQTBFO1FBQzFFLHlDQUF5QztRQUN6QyxJQUFJcEIsR0FBRzhCLE9BQU8sS0FBSyxNQUFNO1FBRXpCLElBQUk5QixHQUFHOEIsT0FBTyxDQUFDdEMsY0FBYyxDQUFDQyxRQUFRLEVBQUU7WUFDdEMyQjtZQUNBLElBQUlqQixPQUFPUyxjQUFjLENBQUNtQixVQUFVLEVBQUU1QixPQUFPVCxPQUFPO1FBQ3RELE9BQU87WUFDTE0sR0FBRzhCLE9BQU8sQ0FBQ2QsSUFBSSxDQUFDLFVBQVUsU0FBU2dCO2dCQUNqQyxtRUFBbUU7Z0JBQ25FLHFFQUFxRTtnQkFDckUsdUVBQXVFO2dCQUN2RVo7WUFDRjtZQUNBcEIsR0FBR2tCLEtBQUs7UUFDVjtJQUNGO0lBRUFmLE9BQU84QixLQUFLLEdBQUc7UUFDYixJQUFJakMsR0FBR2tDLFFBQVEsRUFBRWxDLEdBQUdtQyxNQUFNO0lBQzVCO0lBRUFoQyxPQUFPaUMsTUFBTSxHQUFHLFNBQVVDLEtBQUssRUFBRUMsUUFBUSxFQUFFbEIsUUFBUTtRQUNqRCxJQUFJcEIsR0FBR3FCLFVBQVUsS0FBS3JCLEdBQUc0QixVQUFVLEVBQUU7WUFDbkM1QixHQUFHZ0IsSUFBSSxDQUFDLFFBQVEsU0FBU2E7Z0JBQ3ZCMUIsT0FBT2lDLE1BQU0sQ0FBQ0MsT0FBT0MsVUFBVWxCO1lBQ2pDO1lBQ0E7UUFDRjtRQUVBcEIsR0FBR3VDLElBQUksQ0FBQ0YsT0FBT2pCO0lBQ2pCO0lBRUFqQixPQUFPSSxFQUFFLENBQUMsT0FBT2pCO0lBQ2pCYSxPQUFPSSxFQUFFLENBQUMsU0FBU1o7SUFDbkIsT0FBT1E7QUFDVDtBQUVBcUMsT0FBT0MsT0FBTyxHQUFHMUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly90ZXJyYWZvcm1hdGlvbi8uL25vZGVfbW9kdWxlcy9ycGMtd2Vic29ja2V0cy9ub2RlX21vZHVsZXMvd3MvbGliL3N0cmVhbS5qcz85MjcyIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXldlYlNvY2tldCRcIiB9XSAqL1xuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuY29uc3QgeyBEdXBsZXggfSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xuXG4vKipcbiAqIEVtaXRzIHRoZSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYSBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHN0cmVhbSBUaGUgc3RyZWFtLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHN0cmVhbSkge1xuICBzdHJlYW0uZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FbmQoKSB7XG4gIGlmICghdGhpcy5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgIHRoaXMuZGVzdHJveSgpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyIFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZHVwbGV4T25FcnJvcihlcnIpIHtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBkdXBsZXhPbkVycm9yKTtcbiAgdGhpcy5kZXN0cm95KCk7XG4gIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Vycm9yJykgPT09IDApIHtcbiAgICAvLyBEbyBub3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yLlxuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogV3JhcHMgYSBgV2ViU29ja2V0YCBpbiBhIGR1cGxleCBzdHJlYW0uXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdzIFRoZSBgV2ViU29ja2V0YCB0byB3cmFwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIFRoZSBvcHRpb25zIGZvciB0aGUgYER1cGxleGAgY29uc3RydWN0b3JcbiAqIEByZXR1cm4ge0R1cGxleH0gVGhlIGR1cGxleCBzdHJlYW1cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gY3JlYXRlV2ViU29ja2V0U3RyZWFtKHdzLCBvcHRpb25zKSB7XG4gIGxldCB0ZXJtaW5hdGVPbkRlc3Ryb3kgPSB0cnVlO1xuXG4gIGNvbnN0IGR1cGxleCA9IG5ldyBEdXBsZXgoe1xuICAgIC4uLm9wdGlvbnMsXG4gICAgYXV0b0Rlc3Ryb3k6IGZhbHNlLFxuICAgIGVtaXRDbG9zZTogZmFsc2UsXG4gICAgb2JqZWN0TW9kZTogZmFsc2UsXG4gICAgd3JpdGFibGVPYmplY3RNb2RlOiBmYWxzZVxuICB9KTtcblxuICB3cy5vbignbWVzc2FnZScsIGZ1bmN0aW9uIG1lc3NhZ2UobXNnLCBpc0JpbmFyeSkge1xuICAgIGNvbnN0IGRhdGEgPVxuICAgICAgIWlzQmluYXJ5ICYmIGR1cGxleC5fcmVhZGFibGVTdGF0ZS5vYmplY3RNb2RlID8gbXNnLnRvU3RyaW5nKCkgOiBtc2c7XG5cbiAgICBpZiAoIWR1cGxleC5wdXNoKGRhdGEpKSB3cy5wYXVzZSgpO1xuICB9KTtcblxuICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgIGlmIChkdXBsZXguZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAvLyBQcmV2ZW50IGB3cy50ZXJtaW5hdGUoKWAgZnJvbSBiZWluZyBjYWxsZWQgYnkgYGR1cGxleC5fZGVzdHJveSgpYC5cbiAgICAvL1xuICAgIC8vIC0gSWYgdGhlIGAnZXJyb3InYCBldmVudCBpcyBlbWl0dGVkIGJlZm9yZSB0aGUgYCdvcGVuJ2AgZXZlbnQsIHRoZW5cbiAgICAvLyAgIGB3cy50ZXJtaW5hdGUoKWAgaXMgYSBub29wIGFzIG5vIHNvY2tldCBpcyBhc3NpZ25lZC5cbiAgICAvLyAtIE90aGVyd2lzZSwgdGhlIGVycm9yIGlzIHJlLWVtaXR0ZWQgYnkgdGhlIGxpc3RlbmVyIG9mIHRoZSBgJ2Vycm9yJ2BcbiAgICAvLyAgIGV2ZW50IG9mIHRoZSBgUmVjZWl2ZXJgIG9iamVjdC4gVGhlIGxpc3RlbmVyIGFscmVhZHkgY2xvc2VzIHRoZVxuICAgIC8vICAgY29ubmVjdGlvbiBieSBjYWxsaW5nIGB3cy5jbG9zZSgpYC4gVGhpcyBhbGxvd3MgYSBjbG9zZSBmcmFtZSB0byBiZVxuICAgIC8vICAgc2VudCB0byB0aGUgb3RoZXIgcGVlci4gSWYgYHdzLnRlcm1pbmF0ZSgpYCBpcyBjYWxsZWQgcmlnaHQgYWZ0ZXIgdGhpcyxcbiAgICAvLyAgIHRoZW4gdGhlIGNsb3NlIGZyYW1lIG1pZ2h0IG5vdCBiZSBzZW50LlxuICAgIHRlcm1pbmF0ZU9uRGVzdHJveSA9IGZhbHNlO1xuICAgIGR1cGxleC5kZXN0cm95KGVycik7XG4gIH0pO1xuXG4gIHdzLm9uY2UoJ2Nsb3NlJywgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgaWYgKGR1cGxleC5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgIGR1cGxleC5wdXNoKG51bGwpO1xuICB9KTtcblxuICBkdXBsZXguX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DTE9TRUQpIHtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBsZXQgY2FsbGVkID0gZmFsc2U7XG5cbiAgICB3cy5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uIGVycm9yKGVycikge1xuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgfSk7XG5cbiAgICB3cy5vbmNlKCdjbG9zZScsIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgaWYgKCFjYWxsZWQpIGNhbGxiYWNrKGVycik7XG4gICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgZHVwbGV4KTtcbiAgICB9KTtcblxuICAgIGlmICh0ZXJtaW5hdGVPbkRlc3Ryb3kpIHdzLnRlcm1pbmF0ZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fZmluYWwgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICBpZiAod3MucmVhZHlTdGF0ZSA9PT0gd3MuQ09OTkVDVElORykge1xuICAgICAgd3Mub25jZSgnb3BlbicsIGZ1bmN0aW9uIG9wZW4oKSB7XG4gICAgICAgIGR1cGxleC5fZmluYWwoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBgX3NvY2tldGAgcHJvcGVydHkgaXMgYG51bGxgIGl0IG1lYW5zIHRoYXQgYHdzYCBpcyBhXG4gICAgLy8gY2xpZW50IHdlYnNvY2tldCBhbmQgdGhlIGhhbmRzaGFrZSBmYWlsZWQuIEluIGZhY3QsIHdoZW4gdGhpcyBoYXBwZW5zLCBhXG4gICAgLy8gc29ja2V0IGlzIG5ldmVyIGFzc2lnbmVkIHRvIHRoZSB3ZWJzb2NrZXQuIFdhaXQgZm9yIHRoZSBgJ2Vycm9yJ2AgZXZlbnRcbiAgICAvLyB0aGF0IHdpbGwgYmUgZW1pdHRlZCBieSB0aGUgd2Vic29ja2V0LlxuICAgIGlmICh3cy5fc29ja2V0ID09PSBudWxsKSByZXR1cm47XG5cbiAgICBpZiAod3MuX3NvY2tldC5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCkge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICAgIGlmIChkdXBsZXguX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCkgZHVwbGV4LmRlc3Ryb3koKTtcbiAgICB9IGVsc2Uge1xuICAgICAgd3MuX3NvY2tldC5vbmNlKCdmaW5pc2gnLCBmdW5jdGlvbiBmaW5pc2goKSB7XG4gICAgICAgIC8vIGBkdXBsZXhgIGlzIG5vdCBkZXN0cm95ZWQgaGVyZSBiZWNhdXNlIHRoZSBgJ2VuZCdgIGV2ZW50IHdpbGwgYmVcbiAgICAgICAgLy8gZW1pdHRlZCBvbiBgZHVwbGV4YCBhZnRlciB0aGlzIGAnZmluaXNoJ2AgZXZlbnQuIFRoZSBFT0Ygc2lnbmFsaW5nXG4gICAgICAgIC8vIGBudWxsYCBjaHVuayBpcywgaW4gZmFjdCwgcHVzaGVkIHdoZW4gdGhlIHdlYnNvY2tldCBlbWl0cyBgJ2Nsb3NlJ2AuXG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICB9KTtcbiAgICAgIHdzLmNsb3NlKCk7XG4gICAgfVxuICB9O1xuXG4gIGR1cGxleC5fcmVhZCA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAod3MuaXNQYXVzZWQpIHdzLnJlc3VtZSgpO1xuICB9O1xuXG4gIGR1cGxleC5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgIGlmICh3cy5yZWFkeVN0YXRlID09PSB3cy5DT05ORUNUSU5HKSB7XG4gICAgICB3cy5vbmNlKCdvcGVuJywgZnVuY3Rpb24gb3BlbigpIHtcbiAgICAgICAgZHVwbGV4Ll93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHdzLnNlbmQoY2h1bmssIGNhbGxiYWNrKTtcbiAgfTtcblxuICBkdXBsZXgub24oJ2VuZCcsIGR1cGxleE9uRW5kKTtcbiAgZHVwbGV4Lm9uKCdlcnJvcicsIGR1cGxleE9uRXJyb3IpO1xuICByZXR1cm4gZHVwbGV4O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNyZWF0ZVdlYlNvY2tldFN0cmVhbTtcbiJdLCJuYW1lcyI6WyJXZWJTb2NrZXQiLCJyZXF1aXJlIiwiRHVwbGV4IiwiZW1pdENsb3NlIiwic3RyZWFtIiwiZW1pdCIsImR1cGxleE9uRW5kIiwiZGVzdHJveWVkIiwiX3dyaXRhYmxlU3RhdGUiLCJmaW5pc2hlZCIsImRlc3Ryb3kiLCJkdXBsZXhPbkVycm9yIiwiZXJyIiwicmVtb3ZlTGlzdGVuZXIiLCJsaXN0ZW5lckNvdW50IiwiY3JlYXRlV2ViU29ja2V0U3RyZWFtIiwid3MiLCJvcHRpb25zIiwidGVybWluYXRlT25EZXN0cm95IiwiZHVwbGV4IiwiYXV0b0Rlc3Ryb3kiLCJvYmplY3RNb2RlIiwid3JpdGFibGVPYmplY3RNb2RlIiwib24iLCJtZXNzYWdlIiwibXNnIiwiaXNCaW5hcnkiLCJkYXRhIiwiX3JlYWRhYmxlU3RhdGUiLCJ0b1N0cmluZyIsInB1c2giLCJwYXVzZSIsIm9uY2UiLCJlcnJvciIsImNsb3NlIiwiX2Rlc3Ryb3kiLCJjYWxsYmFjayIsInJlYWR5U3RhdGUiLCJDTE9TRUQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJjYWxsZWQiLCJ0ZXJtaW5hdGUiLCJfZmluYWwiLCJDT05ORUNUSU5HIiwib3BlbiIsIl9zb2NrZXQiLCJlbmRFbWl0dGVkIiwiZmluaXNoIiwiX3JlYWQiLCJpc1BhdXNlZCIsInJlc3VtZSIsIl93cml0ZSIsImNodW5rIiwiZW5jb2RpbmciLCJzZW5kIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/stream.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/subprotocol.js":
/*!************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/subprotocol.js ***!
  \************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { tokenChars } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/validation.js\");\n/**\n * Parses the `Sec-WebSocket-Protocol` header into a set of subprotocol names.\n *\n * @param {String} header The field value of the header\n * @return {Set} The subprotocol names\n * @public\n */ function parse(header) {\n    const protocols = new Set();\n    let start = -1;\n    let end = -1;\n    let i = 0;\n    for(i; i < header.length; i++){\n        const code = header.charCodeAt(i);\n        if (end === -1 && tokenChars[code] === 1) {\n            if (start === -1) start = i;\n        } else if (i !== 0 && (code === 0x20 /* ' ' */  || code === 0x09)) {\n            if (end === -1 && start !== -1) end = i;\n        } else if (code === 0x2c /* ',' */ ) {\n            if (start === -1) {\n                throw new SyntaxError(`Unexpected character at index ${i}`);\n            }\n            if (end === -1) end = i;\n            const protocol = header.slice(start, end);\n            if (protocols.has(protocol)) {\n                throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n            }\n            protocols.add(protocol);\n            start = end = -1;\n        } else {\n            throw new SyntaxError(`Unexpected character at index ${i}`);\n        }\n    }\n    if (start === -1 || end !== -1) {\n        throw new SyntaxError(\"Unexpected end of input\");\n    }\n    const protocol = header.slice(start, i);\n    if (protocols.has(protocol)) {\n        throw new SyntaxError(`The \"${protocol}\" subprotocol is duplicated`);\n    }\n    protocols.add(protocol);\n    return protocols;\n}\nmodule.exports = {\n    parse\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi9zdWJwcm90b2NvbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUVBLE1BQU0sRUFBRUEsVUFBVSxFQUFFLEdBQUdDLG1CQUFPQSxDQUFDO0FBRS9COzs7Ozs7Q0FNQyxHQUNELFNBQVNDLE1BQU1DLE1BQU07SUFDbkIsTUFBTUMsWUFBWSxJQUFJQztJQUN0QixJQUFJQyxRQUFRLENBQUM7SUFDYixJQUFJQyxNQUFNLENBQUM7SUFDWCxJQUFJQyxJQUFJO0lBRVIsSUFBS0EsR0FBR0EsSUFBSUwsT0FBT00sTUFBTSxFQUFFRCxJQUFLO1FBQzlCLE1BQU1FLE9BQU9QLE9BQU9RLFVBQVUsQ0FBQ0g7UUFFL0IsSUFBSUQsUUFBUSxDQUFDLEtBQUtQLFVBQVUsQ0FBQ1UsS0FBSyxLQUFLLEdBQUc7WUFDeEMsSUFBSUosVUFBVSxDQUFDLEdBQUdBLFFBQVFFO1FBQzVCLE9BQU8sSUFDTEEsTUFBTSxLQUNMRSxDQUFBQSxTQUFTLEtBQUssT0FBTyxPQUFNQSxTQUFTLElBQUcsR0FDeEM7WUFDQSxJQUFJSCxRQUFRLENBQUMsS0FBS0QsVUFBVSxDQUFDLEdBQUdDLE1BQU1DO1FBQ3hDLE9BQU8sSUFBSUUsU0FBUyxLQUFLLE9BQU8sS0FBSTtZQUNsQyxJQUFJSixVQUFVLENBQUMsR0FBRztnQkFDaEIsTUFBTSxJQUFJTSxZQUFZLENBQUMsOEJBQThCLEVBQUVKLEVBQUUsQ0FBQztZQUM1RDtZQUVBLElBQUlELFFBQVEsQ0FBQyxHQUFHQSxNQUFNQztZQUV0QixNQUFNSyxXQUFXVixPQUFPVyxLQUFLLENBQUNSLE9BQU9DO1lBRXJDLElBQUlILFVBQVVXLEdBQUcsQ0FBQ0YsV0FBVztnQkFDM0IsTUFBTSxJQUFJRCxZQUFZLENBQUMsS0FBSyxFQUFFQyxTQUFTLDJCQUEyQixDQUFDO1lBQ3JFO1lBRUFULFVBQVVZLEdBQUcsQ0FBQ0g7WUFDZFAsUUFBUUMsTUFBTSxDQUFDO1FBQ2pCLE9BQU87WUFDTCxNQUFNLElBQUlLLFlBQVksQ0FBQyw4QkFBOEIsRUFBRUosRUFBRSxDQUFDO1FBQzVEO0lBQ0Y7SUFFQSxJQUFJRixVQUFVLENBQUMsS0FBS0MsUUFBUSxDQUFDLEdBQUc7UUFDOUIsTUFBTSxJQUFJSyxZQUFZO0lBQ3hCO0lBRUEsTUFBTUMsV0FBV1YsT0FBT1csS0FBSyxDQUFDUixPQUFPRTtJQUVyQyxJQUFJSixVQUFVVyxHQUFHLENBQUNGLFdBQVc7UUFDM0IsTUFBTSxJQUFJRCxZQUFZLENBQUMsS0FBSyxFQUFFQyxTQUFTLDJCQUEyQixDQUFDO0lBQ3JFO0lBRUFULFVBQVVZLEdBQUcsQ0FBQ0g7SUFDZCxPQUFPVDtBQUNUO0FBRUFhLE9BQU9DLE9BQU8sR0FBRztJQUFFaEI7QUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJhZm9ybWF0aW9uLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL25vZGVfbW9kdWxlcy93cy9saWIvc3VicHJvdG9jb2wuanM/ODQ2NSJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIHN0cmljdCc7XG5cbmNvbnN0IHsgdG9rZW5DaGFycyB9ID0gcmVxdWlyZSgnLi92YWxpZGF0aW9uJyk7XG5cbi8qKlxuICogUGFyc2VzIHRoZSBgU2VjLVdlYlNvY2tldC1Qcm90b2NvbGAgaGVhZGVyIGludG8gYSBzZXQgb2Ygc3VicHJvdG9jb2wgbmFtZXMuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGhlYWRlciBUaGUgZmllbGQgdmFsdWUgb2YgdGhlIGhlYWRlclxuICogQHJldHVybiB7U2V0fSBUaGUgc3VicHJvdG9jb2wgbmFtZXNcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcGFyc2UoaGVhZGVyKSB7XG4gIGNvbnN0IHByb3RvY29scyA9IG5ldyBTZXQoKTtcbiAgbGV0IHN0YXJ0ID0gLTE7XG4gIGxldCBlbmQgPSAtMTtcbiAgbGV0IGkgPSAwO1xuXG4gIGZvciAoaTsgaSA8IGhlYWRlci5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNvZGUgPSBoZWFkZXIuY2hhckNvZGVBdChpKTtcblxuICAgIGlmIChlbmQgPT09IC0xICYmIHRva2VuQ2hhcnNbY29kZV0gPT09IDEpIHtcbiAgICAgIGlmIChzdGFydCA9PT0gLTEpIHN0YXJ0ID0gaTtcbiAgICB9IGVsc2UgaWYgKFxuICAgICAgaSAhPT0gMCAmJlxuICAgICAgKGNvZGUgPT09IDB4MjAgLyogJyAnICovIHx8IGNvZGUgPT09IDB4MDkpIC8qICdcXHQnICovXG4gICAgKSB7XG4gICAgICBpZiAoZW5kID09PSAtMSAmJiBzdGFydCAhPT0gLTEpIGVuZCA9IGk7XG4gICAgfSBlbHNlIGlmIChjb2RlID09PSAweDJjIC8qICcsJyAqLykge1xuICAgICAgaWYgKHN0YXJ0ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGVuZCA9PT0gLTEpIGVuZCA9IGk7XG5cbiAgICAgIGNvbnN0IHByb3RvY29sID0gaGVhZGVyLnNsaWNlKHN0YXJ0LCBlbmQpO1xuXG4gICAgICBpZiAocHJvdG9jb2xzLmhhcyhwcm90b2NvbCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgICAgIH1cblxuICAgICAgcHJvdG9jb2xzLmFkZChwcm90b2NvbCk7XG4gICAgICBzdGFydCA9IGVuZCA9IC0xO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYFVuZXhwZWN0ZWQgY2hhcmFjdGVyIGF0IGluZGV4ICR7aX1gKTtcbiAgICB9XG4gIH1cblxuICBpZiAoc3RhcnQgPT09IC0xIHx8IGVuZCAhPT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgZW5kIG9mIGlucHV0Jyk7XG4gIH1cblxuICBjb25zdCBwcm90b2NvbCA9IGhlYWRlci5zbGljZShzdGFydCwgaSk7XG5cbiAgaWYgKHByb3RvY29scy5oYXMocHJvdG9jb2wpKSB7XG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKGBUaGUgXCIke3Byb3RvY29sfVwiIHN1YnByb3RvY29sIGlzIGR1cGxpY2F0ZWRgKTtcbiAgfVxuXG4gIHByb3RvY29scy5hZGQocHJvdG9jb2wpO1xuICByZXR1cm4gcHJvdG9jb2xzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHsgcGFyc2UgfTtcbiJdLCJuYW1lcyI6WyJ0b2tlbkNoYXJzIiwicmVxdWlyZSIsInBhcnNlIiwiaGVhZGVyIiwicHJvdG9jb2xzIiwiU2V0Iiwic3RhcnQiLCJlbmQiLCJpIiwibGVuZ3RoIiwiY29kZSIsImNoYXJDb2RlQXQiLCJTeW50YXhFcnJvciIsInByb3RvY29sIiwic2xpY2UiLCJoYXMiLCJhZGQiLCJtb2R1bGUiLCJleHBvcnRzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/subprotocol.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/validation.js":
/*!***********************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/validation.js ***!
  \***********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst { isUtf8 } = __webpack_require__(/*! buffer */ \"buffer\");\nconst { hasBlob } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\n//\n// Allowed token characters:\n//\n// '!', '#', '$', '%', '&', ''', '*', '+', '-',\n// '.', 0-9, A-Z, '^', '_', '`', a-z, '|', '~'\n//\n// tokenChars[32] === 0 // ' '\n// tokenChars[33] === 1 // '!'\n// tokenChars[34] === 0 // '\"'\n// ...\n//\n// prettier-ignore\nconst tokenChars = [\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    0,\n    0,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    1,\n    0,\n    1,\n    0,\n    1,\n    0 // 112 - 127\n];\n/**\n * Checks if a status code is allowed in a close frame.\n *\n * @param {Number} code The status code\n * @return {Boolean} `true` if the status code is valid, else `false`\n * @public\n */ function isValidStatusCode(code) {\n    return code >= 1000 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3000 && code <= 4999;\n}\n/**\n * Checks if a given buffer contains only correct UTF-8.\n * Ported from https://www.cl.cam.ac.uk/%7Emgk25/ucs/utf8_check.c by\n * Markus Kuhn.\n *\n * @param {Buffer} buf The buffer to check\n * @return {Boolean} `true` if `buf` contains only correct UTF-8, else `false`\n * @public\n */ function _isValidUTF8(buf) {\n    const len = buf.length;\n    let i = 0;\n    while(i < len){\n        if ((buf[i] & 0x80) === 0) {\n            // 0xxxxxxx\n            i++;\n        } else if ((buf[i] & 0xe0) === 0xc0) {\n            // 110xxxxx 10xxxxxx\n            if (i + 1 === len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i] & 0xfe) === 0xc0 // Overlong\n            ) {\n                return false;\n            }\n            i += 2;\n        } else if ((buf[i] & 0xf0) === 0xe0) {\n            // 1110xxxx 10xxxxxx 10xxxxxx\n            if (i + 2 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || buf[i] === 0xe0 && (buf[i + 1] & 0xe0) === 0x80 || // Overlong\n            buf[i] === 0xed && (buf[i + 1] & 0xe0) === 0xa0 // Surrogate (U+D800 - U+DFFF)\n            ) {\n                return false;\n            }\n            i += 3;\n        } else if ((buf[i] & 0xf8) === 0xf0) {\n            // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n            if (i + 3 >= len || (buf[i + 1] & 0xc0) !== 0x80 || (buf[i + 2] & 0xc0) !== 0x80 || (buf[i + 3] & 0xc0) !== 0x80 || buf[i] === 0xf0 && (buf[i + 1] & 0xf0) === 0x80 || // Overlong\n            buf[i] === 0xf4 && buf[i + 1] > 0x8f || buf[i] > 0xf4 // > U+10FFFF\n            ) {\n                return false;\n            }\n            i += 4;\n        } else {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Determines whether a value is a `Blob`.\n *\n * @param {*} value The value to be tested\n * @return {Boolean} `true` if `value` is a `Blob`, else `false`\n * @private\n */ function isBlob(value) {\n    return hasBlob && typeof value === \"object\" && typeof value.arrayBuffer === \"function\" && typeof value.type === \"string\" && typeof value.stream === \"function\" && (value[Symbol.toStringTag] === \"Blob\" || value[Symbol.toStringTag] === \"File\");\n}\nmodule.exports = {\n    isBlob,\n    isValidStatusCode,\n    isValidUTF8: _isValidUTF8,\n    tokenChars\n};\nif (isUtf8) {\n    module.exports.isValidUTF8 = function(buf) {\n        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);\n    };\n} else if (!process.env.WS_NO_UTF_8_VALIDATE) {\n    try {\n        const isValidUTF8 = __webpack_require__(/*! utf-8-validate */ \"?80a9\");\n        module.exports.isValidUTF8 = function(buf) {\n            return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);\n        };\n    } catch (e) {\n    // Continue regardless of the error.\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi92YWxpZGF0aW9uLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsTUFBTSxFQUFFQSxNQUFNLEVBQUUsR0FBR0MsbUJBQU9BLENBQUM7QUFFM0IsTUFBTSxFQUFFQyxPQUFPLEVBQUUsR0FBR0QsbUJBQU9BLENBQUM7QUFFNUIsRUFBRTtBQUNGLDRCQUE0QjtBQUM1QixFQUFFO0FBQ0YsK0NBQStDO0FBQy9DLDhDQUE4QztBQUM5QyxFQUFFO0FBQ0YsOEJBQThCO0FBQzlCLDhCQUE4QjtBQUM5Qiw4QkFBOEI7QUFDOUIsTUFBTTtBQUNOLEVBQUU7QUFDRixrQkFBa0I7QUFDbEIsTUFBTUUsYUFBYTtJQUNqQjtJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUM3QztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lBQUc7SUFBRztJQUFHO0lB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R0FBRztJQUNmUjtJQUNBUDtJQUNBZ0IsYUFBYWQ7SUFDYkg7QUFDRjtBQUVBLElBQUlILFFBQVE7SUFDVmtCLDBCQUEwQixHQUFHLFNBQVVYLEdBQUc7UUFDeEMsT0FBT0EsSUFBSUUsTUFBTSxHQUFHLEtBQUtILGFBQWFDLE9BQU9QLE9BQU9PO0lBQ3REO0FBQ0YsT0FBbUMsSUFBSSxDQUFDYyxRQUFRQyxHQUFHLENBQUNDLG9CQUFvQixFQUFFO0lBQ3hFLElBQUk7UUFDRixNQUFNSCxjQUFjbkIsbUJBQU9BLENBQUM7UUFFNUJpQiwwQkFBMEIsR0FBRyxTQUFVWCxHQUFHO1lBQ3hDLE9BQU9BLElBQUlFLE1BQU0sR0FBRyxLQUFLSCxhQUFhQyxPQUFPYSxZQUFZYjtRQUMzRDtJQUNGLEVBQUUsT0FBT2lCLEdBQUc7SUFDVixvQ0FBb0M7SUFDdEM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJhZm9ybWF0aW9uLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL25vZGVfbW9kdWxlcy93cy9saWIvdmFsaWRhdGlvbi5qcz82ZjAzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuY29uc3QgeyBpc1V0ZjggfSA9IHJlcXVpcmUoJ2J1ZmZlcicpO1xuXG5jb25zdCB7IGhhc0Jsb2IgfSA9IHJlcXVpcmUoJy4vY29uc3RhbnRzJyk7XG5cbi8vXG4vLyBBbGxvd2VkIHRva2VuIGNoYXJhY3RlcnM6XG4vL1xuLy8gJyEnLCAnIycsICckJywgJyUnLCAnJicsICcnJywgJyonLCAnKycsICctJyxcbi8vICcuJywgMC05LCBBLVosICdeJywgJ18nLCAnYCcsIGEteiwgJ3wnLCAnfidcbi8vXG4vLyB0b2tlbkNoYXJzWzMyXSA9PT0gMCAvLyAnICdcbi8vIHRva2VuQ2hhcnNbMzNdID09PSAxIC8vICchJ1xuLy8gdG9rZW5DaGFyc1szNF0gPT09IDAgLy8gJ1wiJ1xuLy8gLi4uXG4vL1xuLy8gcHJldHRpZXItaWdub3JlXG5jb25zdCB0b2tlbkNoYXJzID0gW1xuICAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAvLyAwIC0gMTVcbiAgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgMCwgLy8gMTYgLSAzMVxuICAwLCAxLCAwLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAxLCAxLCAwLCAxLCAxLCAwLCAvLyAzMiAtIDQ3XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDAsIDAsIDAsIDAsIDAsIC8vIDQ4IC0gNjNcbiAgMCwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgLy8gNjQgLSA3OVxuICAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAwLCAwLCAwLCAxLCAxLCAvLyA4MCAtIDk1XG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIC8vIDk2IC0gMTExXG4gIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDAsIDEsIDAsIDEsIDAgLy8gMTEyIC0gMTI3XG5dO1xuXG4vKipcbiAqIENoZWNrcyBpZiBhIHN0YXR1cyBjb2RlIGlzIGFsbG93ZWQgaW4gYSBjbG9zZSBmcmFtZS5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gY29kZSBUaGUgc3RhdHVzIGNvZGVcbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgc3RhdHVzIGNvZGUgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBpc1ZhbGlkU3RhdHVzQ29kZShjb2RlKSB7XG4gIHJldHVybiAoXG4gICAgKGNvZGUgPj0gMTAwMCAmJlxuICAgICAgY29kZSA8PSAxMDE0ICYmXG4gICAgICBjb2RlICE9PSAxMDA0ICYmXG4gICAgICBjb2RlICE9PSAxMDA1ICYmXG4gICAgICBjb2RlICE9PSAxMDA2KSB8fFxuICAgIChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KVxuICApO1xufVxuXG4vKipcbiAqIENoZWNrcyBpZiBhIGdpdmVuIGJ1ZmZlciBjb250YWlucyBvbmx5IGNvcnJlY3QgVVRGLTguXG4gKiBQb3J0ZWQgZnJvbSBodHRwczovL3d3dy5jbC5jYW0uYWMudWsvJTdFbWdrMjUvdWNzL3V0ZjhfY2hlY2suYyBieVxuICogTWFya3VzIEt1aG4uXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGJ1ZiBUaGUgYnVmZmVyIHRvIGNoZWNrXG4gKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgYGJ1ZmAgY29udGFpbnMgb25seSBjb3JyZWN0IFVURi04LCBlbHNlIGBmYWxzZWBcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gX2lzVmFsaWRVVEY4KGJ1Zikge1xuICBjb25zdCBsZW4gPSBidWYubGVuZ3RoO1xuICBsZXQgaSA9IDA7XG5cbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICBpZiAoKGJ1ZltpXSAmIDB4ODApID09PSAwKSB7XG4gICAgICAvLyAweHh4eHh4eFxuICAgICAgaSsrO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZTApID09PSAweGMwKSB7XG4gICAgICAvLyAxMTB4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMSA9PT0gbGVuIHx8XG4gICAgICAgIChidWZbaSArIDFdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSAmIDB4ZmUpID09PSAweGMwIC8vIE92ZXJsb25nXG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuXG4gICAgICBpICs9IDI7XG4gICAgfSBlbHNlIGlmICgoYnVmW2ldICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgIC8vIDExMTB4eHh4IDEweHh4eHh4IDEweHh4eHh4XG4gICAgICBpZiAoXG4gICAgICAgIGkgKyAyID49IGxlbiB8fFxuICAgICAgICAoYnVmW2kgKyAxXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDJdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhlMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZTApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGVkICYmIChidWZbaSArIDFdICYgMHhlMCkgPT09IDB4YTApIC8vIFN1cnJvZ2F0ZSAoVStEODAwIC0gVStERkZGKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaSArPSAzO1xuICAgIH0gZWxzZSBpZiAoKGJ1ZltpXSAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAvLyAxMTExMHh4eCAxMHh4eHh4eCAxMHh4eHh4eCAxMHh4eHh4eFxuICAgICAgaWYgKFxuICAgICAgICBpICsgMyA+PSBsZW4gfHxcbiAgICAgICAgKGJ1ZltpICsgMV0gJiAweGMwKSAhPT0gMHg4MCB8fFxuICAgICAgICAoYnVmW2kgKyAyXSAmIDB4YzApICE9PSAweDgwIHx8XG4gICAgICAgIChidWZbaSArIDNdICYgMHhjMCkgIT09IDB4ODAgfHxcbiAgICAgICAgKGJ1ZltpXSA9PT0gMHhmMCAmJiAoYnVmW2kgKyAxXSAmIDB4ZjApID09PSAweDgwKSB8fCAvLyBPdmVybG9uZ1xuICAgICAgICAoYnVmW2ldID09PSAweGY0ICYmIGJ1ZltpICsgMV0gPiAweDhmKSB8fFxuICAgICAgICBidWZbaV0gPiAweGY0IC8vID4gVSsxMEZGRkZcbiAgICAgICkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGkgKz0gNDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciBhIHZhbHVlIGlzIGEgYEJsb2JgLlxuICpcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGJlIHRlc3RlZFxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBgQmxvYmAsIGVsc2UgYGZhbHNlYFxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gaXNCbG9iKHZhbHVlKSB7XG4gIHJldHVybiAoXG4gICAgaGFzQmxvYiAmJlxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2YgdmFsdWUuYXJyYXlCdWZmZXIgPT09ICdmdW5jdGlvbicgJiZcbiAgICB0eXBlb2YgdmFsdWUudHlwZSA9PT0gJ3N0cmluZycgJiZcbiAgICB0eXBlb2YgdmFsdWUuc3RyZWFtID09PSAnZnVuY3Rpb24nICYmXG4gICAgKHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gPT09ICdCbG9iJyB8fFxuICAgICAgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ0ZpbGUnKVxuICApO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNCbG9iLFxuICBpc1ZhbGlkU3RhdHVzQ29kZSxcbiAgaXNWYWxpZFVURjg6IF9pc1ZhbGlkVVRGOCxcbiAgdG9rZW5DaGFyc1xufTtcblxuaWYgKGlzVXRmOCkge1xuICBtb2R1bGUuZXhwb3J0cy5pc1ZhbGlkVVRGOCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgICByZXR1cm4gYnVmLmxlbmd0aCA8IDI0ID8gX2lzVmFsaWRVVEY4KGJ1ZikgOiBpc1V0ZjgoYnVmKTtcbiAgfTtcbn0gLyogaXN0YW5idWwgaWdub3JlIGVsc2UgICovIGVsc2UgaWYgKCFwcm9jZXNzLmVudi5XU19OT19VVEZfOF9WQUxJREFURSkge1xuICB0cnkge1xuICAgIGNvbnN0IGlzVmFsaWRVVEY4ID0gcmVxdWlyZSgndXRmLTgtdmFsaWRhdGUnKTtcblxuICAgIG1vZHVsZS5leHBvcnRzLmlzVmFsaWRVVEY4ID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgICAgcmV0dXJuIGJ1Zi5sZW5ndGggPCAzMiA/IF9pc1ZhbGlkVVRGOChidWYpIDogaXNWYWxpZFVURjgoYnVmKTtcbiAgICB9O1xuICB9IGNhdGNoIChlKSB7XG4gICAgLy8gQ29udGludWUgcmVnYXJkbGVzcyBvZiB0aGUgZXJyb3IuXG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJpc1V0ZjgiLCJyZXF1aXJlIiwiaGFzQmxvYiIsInRva2VuQ2hhcnMiLCJpc1ZhbGlkU3RhdHVzQ29kZSIsImNvZGUiLCJfaXNWYWxpZFVURjgiLCJidWYiLCJsZW4iLCJsZW5ndGgiLCJpIiwiaXNCbG9iIiwidmFsdWUiLCJhcnJheUJ1ZmZlciIsInR5cGUiLCJzdHJlYW0iLCJTeW1ib2wiLCJ0b1N0cmluZ1RhZyIsIm1vZHVsZSIsImV4cG9ydHMiLCJpc1ZhbGlkVVRGOCIsInByb2Nlc3MiLCJlbnYiLCJXU19OT19VVEZfOF9WQUxJREFURSIsImUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/validation.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket-server.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/websocket-server.js ***!
  \*****************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex$\", \"caughtErrors\": \"none\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst { Duplex } = __webpack_require__(/*! stream */ \"stream\");\nconst { createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst extension = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/extension.js\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js\");\nconst subprotocol = __webpack_require__(/*! ./subprotocol */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/subprotocol.js\");\nconst WebSocket = __webpack_require__(/*! ./websocket */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket.js\");\nconst { CLOSE_TIMEOUT, GUID, kWebSocket } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\nconst keyRegex = /^[+/0-9A-Za-z]{22}==$/;\nconst RUNNING = 0;\nconst CLOSING = 1;\nconst CLOSED = 2;\n/**\n * Class representing a WebSocket server.\n *\n * @extends EventEmitter\n */ class WebSocketServer extends EventEmitter {\n    /**\n   * Create a `WebSocketServer` instance.\n   *\n   * @param {Object} options Configuration options\n   * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n   *     automatically send a pong in response to a ping\n   * @param {Number} [options.backlog=511] The maximum length of the queue of\n   *     pending connections\n   * @param {Boolean} [options.clientTracking=true] Specifies whether or not to\n   *     track clients\n   * @param {Number} [options.closeTimeout=30000] Duration in milliseconds to\n   *     wait for the closing handshake to finish after `websocket.close()` is\n   *     called\n   * @param {Function} [options.handleProtocols] A hook to handle protocols\n   * @param {String} [options.host] The hostname where to bind the server\n   * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n   *     size\n   * @param {Boolean} [options.noServer=false] Enable no server mode\n   * @param {String} [options.path] Accept only connections matching this path\n   * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable\n   *     permessage-deflate\n   * @param {Number} [options.port] The port where to bind the server\n   * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S\n   *     server to use\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @param {Function} [options.verifyClient] A hook to reject connections\n   * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`\n   *     class to use. It must be the `WebSocket` class or class that extends it\n   * @param {Function} [callback] A listener for the `listening` event\n   */ constructor(options, callback){\n        super();\n        options = {\n            allowSynchronousEvents: true,\n            autoPong: true,\n            maxPayload: 100 * 1024 * 1024,\n            skipUTF8Validation: false,\n            perMessageDeflate: false,\n            handleProtocols: null,\n            clientTracking: true,\n            closeTimeout: CLOSE_TIMEOUT,\n            verifyClient: null,\n            noServer: false,\n            backlog: null,\n            server: null,\n            host: null,\n            path: null,\n            port: null,\n            WebSocket,\n            ...options\n        };\n        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {\n            throw new TypeError('One and only one of the \"port\", \"server\", or \"noServer\" options ' + \"must be specified\");\n        }\n        if (options.port != null) {\n            this._server = http.createServer((req, res)=>{\n                const body = http.STATUS_CODES[426];\n                res.writeHead(426, {\n                    \"Content-Length\": body.length,\n                    \"Content-Type\": \"text/plain\"\n                });\n                res.end(body);\n            });\n            this._server.listen(options.port, options.host, options.backlog, callback);\n        } else if (options.server) {\n            this._server = options.server;\n        }\n        if (this._server) {\n            const emitConnection = this.emit.bind(this, \"connection\");\n            this._removeListeners = addListeners(this._server, {\n                listening: this.emit.bind(this, \"listening\"),\n                error: this.emit.bind(this, \"error\"),\n                upgrade: (req, socket, head)=>{\n                    this.handleUpgrade(req, socket, head, emitConnection);\n                }\n            });\n        }\n        if (options.perMessageDeflate === true) options.perMessageDeflate = {};\n        if (options.clientTracking) {\n            this.clients = new Set();\n            this._shouldEmitClose = false;\n        }\n        this.options = options;\n        this._state = RUNNING;\n    }\n    /**\n   * Returns the bound address, the address family name, and port of the server\n   * as reported by the operating system if listening on an IP socket.\n   * If the server is listening on a pipe or UNIX domain socket, the name is\n   * returned as a string.\n   *\n   * @return {(Object|String|null)} The address of the server\n   * @public\n   */ address() {\n        if (this.options.noServer) {\n            throw new Error('The server is operating in \"noServer\" mode');\n        }\n        if (!this._server) return null;\n        return this._server.address();\n    }\n    /**\n   * Stop the server from accepting new connections and emit the `'close'` event\n   * when all existing connections are closed.\n   *\n   * @param {Function} [cb] A one-time listener for the `'close'` event\n   * @public\n   */ close(cb) {\n        if (this._state === CLOSED) {\n            if (cb) {\n                this.once(\"close\", ()=>{\n                    cb(new Error(\"The server is not running\"));\n                });\n            }\n            process.nextTick(emitClose, this);\n            return;\n        }\n        if (cb) this.once(\"close\", cb);\n        if (this._state === CLOSING) return;\n        this._state = CLOSING;\n        if (this.options.noServer || this.options.server) {\n            if (this._server) {\n                this._removeListeners();\n                this._removeListeners = this._server = null;\n            }\n            if (this.clients) {\n                if (!this.clients.size) {\n                    process.nextTick(emitClose, this);\n                } else {\n                    this._shouldEmitClose = true;\n                }\n            } else {\n                process.nextTick(emitClose, this);\n            }\n        } else {\n            const server = this._server;\n            this._removeListeners();\n            this._removeListeners = this._server = null;\n            //\n            // The HTTP/S server was created internally. Close it, and rely on its\n            // `'close'` event.\n            //\n            server.close(()=>{\n                emitClose(this);\n            });\n        }\n    }\n    /**\n   * See if a given request should be handled by this server instance.\n   *\n   * @param {http.IncomingMessage} req Request object to inspect\n   * @return {Boolean} `true` if the request is valid, else `false`\n   * @public\n   */ shouldHandle(req) {\n        if (this.options.path) {\n            const index = req.url.indexOf(\"?\");\n            const pathname = index !== -1 ? req.url.slice(0, index) : req.url;\n            if (pathname !== this.options.path) return false;\n        }\n        return true;\n    }\n    /**\n   * Handle a HTTP Upgrade request.\n   *\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @public\n   */ handleUpgrade(req, socket, head, cb) {\n        socket.on(\"error\", socketOnError);\n        const key = req.headers[\"sec-websocket-key\"];\n        const upgrade = req.headers.upgrade;\n        const version = +req.headers[\"sec-websocket-version\"];\n        if (req.method !== \"GET\") {\n            const message = \"Invalid HTTP method\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);\n            return;\n        }\n        if (upgrade === undefined || upgrade.toLowerCase() !== \"websocket\") {\n            const message = \"Invalid Upgrade header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (key === undefined || !keyRegex.test(key)) {\n            const message = \"Missing or invalid Sec-WebSocket-Key header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n            return;\n        }\n        if (version !== 13 && version !== 8) {\n            const message = \"Missing or invalid Sec-WebSocket-Version header\";\n            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message, {\n                \"Sec-WebSocket-Version\": \"13, 8\"\n            });\n            return;\n        }\n        if (!this.shouldHandle(req)) {\n            abortHandshake(socket, 400);\n            return;\n        }\n        const secWebSocketProtocol = req.headers[\"sec-websocket-protocol\"];\n        let protocols = new Set();\n        if (secWebSocketProtocol !== undefined) {\n            try {\n                protocols = subprotocol.parse(secWebSocketProtocol);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Protocol header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n        }\n        const secWebSocketExtensions = req.headers[\"sec-websocket-extensions\"];\n        const extensions = {};\n        if (this.options.perMessageDeflate && secWebSocketExtensions !== undefined) {\n            const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);\n            try {\n                const offers = extension.parse(secWebSocketExtensions);\n                if (offers[PerMessageDeflate.extensionName]) {\n                    perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);\n                    extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n                }\n            } catch (err) {\n                const message = \"Invalid or unacceptable Sec-WebSocket-Extensions header\";\n                abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);\n                return;\n            }\n        }\n        //\n        // Optionally call external client verification handler.\n        //\n        if (this.options.verifyClient) {\n            const info = {\n                origin: req.headers[`${version === 8 ? \"sec-websocket-origin\" : \"origin\"}`],\n                secure: !!(req.socket.authorized || req.socket.encrypted),\n                req\n            };\n            if (this.options.verifyClient.length === 2) {\n                this.options.verifyClient(info, (verified, code, message, headers)=>{\n                    if (!verified) {\n                        return abortHandshake(socket, code || 401, message, headers);\n                    }\n                    this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n                });\n                return;\n            }\n            if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);\n        }\n        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);\n    }\n    /**\n   * Upgrade the connection to WebSocket.\n   *\n   * @param {Object} extensions The accepted extensions\n   * @param {String} key The value of the `Sec-WebSocket-Key` header\n   * @param {Set} protocols The subprotocols\n   * @param {http.IncomingMessage} req The request object\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Function} cb Callback\n   * @throws {Error} If called more than once with the same socket\n   * @private\n   */ completeUpgrade(extensions, key, protocols, req, socket, head, cb) {\n        //\n        // Destroy the socket if the client has already sent a FIN packet.\n        //\n        if (!socket.readable || !socket.writable) return socket.destroy();\n        if (socket[kWebSocket]) {\n            throw new Error(\"server.handleUpgrade() was called more than once with the same \" + \"socket, possibly due to a misconfiguration\");\n        }\n        if (this._state > RUNNING) return abortHandshake(socket, 503);\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        const headers = [\n            \"HTTP/1.1 101 Switching Protocols\",\n            \"Upgrade: websocket\",\n            \"Connection: Upgrade\",\n            `Sec-WebSocket-Accept: ${digest}`\n        ];\n        const ws = new this.options.WebSocket(null, undefined, this.options);\n        if (protocols.size) {\n            //\n            // Optionally call external protocol selection handler.\n            //\n            const protocol = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;\n            if (protocol) {\n                headers.push(`Sec-WebSocket-Protocol: ${protocol}`);\n                ws._protocol = protocol;\n            }\n        }\n        if (extensions[PerMessageDeflate.extensionName]) {\n            const params = extensions[PerMessageDeflate.extensionName].params;\n            const value = extension.format({\n                [PerMessageDeflate.extensionName]: [\n                    params\n                ]\n            });\n            headers.push(`Sec-WebSocket-Extensions: ${value}`);\n            ws._extensions = extensions;\n        }\n        //\n        // Allow external modification/inspection of handshake headers.\n        //\n        this.emit(\"headers\", headers, req);\n        socket.write(headers.concat(\"\\r\\n\").join(\"\\r\\n\"));\n        socket.removeListener(\"error\", socketOnError);\n        ws.setSocket(socket, head, {\n            allowSynchronousEvents: this.options.allowSynchronousEvents,\n            maxPayload: this.options.maxPayload,\n            skipUTF8Validation: this.options.skipUTF8Validation\n        });\n        if (this.clients) {\n            this.clients.add(ws);\n            ws.on(\"close\", ()=>{\n                this.clients.delete(ws);\n                if (this._shouldEmitClose && !this.clients.size) {\n                    process.nextTick(emitClose, this);\n                }\n            });\n        }\n        cb(ws, req);\n    }\n}\nmodule.exports = WebSocketServer;\n/**\n * Add event listeners on an `EventEmitter` using a map of <event, listener>\n * pairs.\n *\n * @param {EventEmitter} server The event emitter\n * @param {Object.<String, Function>} map The listeners to add\n * @return {Function} A function that will remove the added listeners when\n *     called\n * @private\n */ function addListeners(server, map) {\n    for (const event of Object.keys(map))server.on(event, map[event]);\n    return function removeListeners() {\n        for (const event of Object.keys(map)){\n            server.removeListener(event, map[event]);\n        }\n    };\n}\n/**\n * Emit a `'close'` event on an `EventEmitter`.\n *\n * @param {EventEmitter} server The event emitter\n * @private\n */ function emitClose(server) {\n    server._state = CLOSED;\n    server.emit(\"close\");\n}\n/**\n * Handle socket errors.\n *\n * @private\n */ function socketOnError() {\n    this.destroy();\n}\n/**\n * Close the connection when preconditions are not fulfilled.\n *\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} [message] The HTTP response body\n * @param {Object} [headers] Additional HTTP response headers\n * @private\n */ function abortHandshake(socket, code, message, headers) {\n    //\n    // The socket is writable unless the user destroyed or ended it before calling\n    // `server.handleUpgrade()` or in the `verifyClient` function, which is a user\n    // error. Handling this does not make much sense as the worst that can happen\n    // is that some of the data written by the user might be discarded due to the\n    // call to `socket.end()` below, which triggers an `'error'` event that in\n    // turn causes the socket to be destroyed.\n    //\n    message = message || http.STATUS_CODES[code];\n    headers = {\n        Connection: \"close\",\n        \"Content-Type\": \"text/html\",\n        \"Content-Length\": Buffer.byteLength(message),\n        ...headers\n    };\n    socket.once(\"finish\", socket.destroy);\n    socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\\r\\n` + Object.keys(headers).map((h)=>`${h}: ${headers[h]}`).join(\"\\r\\n\") + \"\\r\\n\\r\\n\" + message);\n}\n/**\n * Emit a `'wsClientError'` event on a `WebSocketServer` if there is at least\n * one listener for it, otherwise call `abortHandshake()`.\n *\n * @param {WebSocketServer} server The WebSocket server\n * @param {http.IncomingMessage} req The request object\n * @param {Duplex} socket The socket of the upgrade request\n * @param {Number} code The HTTP response status code\n * @param {String} message The HTTP response body\n * @param {Object} [headers] The HTTP response headers\n * @private\n */ function abortHandshakeOrEmitwsClientError(server, req, socket, code, message, headers) {\n    if (server.listenerCount(\"wsClientError\")) {\n        const err = new Error(message);\n        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);\n        server.emit(\"wsClientError\", err, socket, req);\n    } else {\n        abortHandshake(socket, code, message, headers);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQtc2VydmVyLmpzIiwibWFwcGluZ3MiOiJBQUFBLGlHQUFpRyxHQUVqRztBQUVBLE1BQU1BLGVBQWVDLG1CQUFPQSxDQUFDO0FBQzdCLE1BQU1DLE9BQU9ELG1CQUFPQSxDQUFDO0FBQ3JCLE1BQU0sRUFBRUUsTUFBTSxFQUFFLEdBQUdGLG1CQUFPQSxDQUFDO0FBQzNCLE1BQU0sRUFBRUcsVUFBVSxFQUFFLEdBQUdILG1CQUFPQSxDQUFDO0FBRS9CLE1BQU1JLFlBQVlKLG1CQUFPQSxDQUFDO0FBQzFCLE1BQU1LLG9CQUFvQkwsbUJBQU9BLENBQUM7QUFDbEMsTUFBTU0sY0FBY04sbUJBQU9BLENBQUM7QUFDNUIsTUFBTU8sWUFBWVAsbUJBQU9BLENBQUM7QUFDMUIsTUFBTSxFQUFFUSxhQUFhLEVBQUVDLElBQUksRUFBRUMsVUFBVSxFQUFFLEdBQUdWLG1CQUFPQSxDQUFDO0FBRXBELE1BQU1XLFdBQVc7QUFFakIsTUFBTUMsVUFBVTtBQUNoQixNQUFNQyxVQUFVO0FBQ2hCLE1BQU1DLFNBQVM7QUFFZjs7OztDQUlDLEdBQ0QsTUFBTUMsd0JBQXdCaEI7SUFDNUI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWlDQyxHQUNEaUIsWUFBWUMsT0FBTyxFQUFFQyxRQUFRLENBQUU7UUFDN0IsS0FBSztRQUVMRCxVQUFVO1lBQ1JFLHdCQUF3QjtZQUN4QkMsVUFBVTtZQUNWQyxZQUFZLE1BQU0sT0FBTztZQUN6QkMsb0JBQW9CO1lBQ3BCQyxtQkFBbUI7WUFDbkJDLGlCQUFpQjtZQUNqQkMsZ0JBQWdCO1lBQ2hCQyxjQUFjbEI7WUFDZG1CLGNBQWM7WUFDZEMsVUFBVTtZQUNWQyxTQUFTO1lBQ1RDLFFBQVE7WUFDUkMsTUFBTTtZQUNOQyxNQUFNO1lBQ05DLE1BQU07WUFDTjFCO1lBQ0EsR0FBR1UsT0FBTztRQUNaO1FBRUEsSUFDRSxR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ZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LXNlcnZlci5qcz8zNjdkIl0sInNvdXJjZXNDb250ZW50IjpbIi8qIGVzbGludCBuby11bnVzZWQtdmFyczogW1wiZXJyb3JcIiwgeyBcInZhcnNJZ25vcmVQYXR0ZXJuXCI6IFwiXkR1cGxleCRcIiwgXCJjYXVnaHRFcnJvcnNcIjogXCJub25lXCIgfV0gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IGh0dHAgPSByZXF1aXJlKCdodHRwJyk7XG5jb25zdCB7IER1cGxleCB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IGNyZWF0ZUhhc2ggfSA9IHJlcXVpcmUoJ2NyeXB0bycpO1xuXG5jb25zdCBleHRlbnNpb24gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgUGVyTWVzc2FnZURlZmxhdGUgPSByZXF1aXJlKCcuL3Blcm1lc3NhZ2UtZGVmbGF0ZScpO1xuY29uc3Qgc3VicHJvdG9jb2wgPSByZXF1aXJlKCcuL3N1YnByb3RvY29sJyk7XG5jb25zdCBXZWJTb2NrZXQgPSByZXF1aXJlKCcuL3dlYnNvY2tldCcpO1xuY29uc3QgeyBDTE9TRV9USU1FT1VULCBHVUlELCBrV2ViU29ja2V0IH0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuXG5jb25zdCBrZXlSZWdleCA9IC9eWysvMC05QS1aYS16XXsyMn09PSQvO1xuXG5jb25zdCBSVU5OSU5HID0gMDtcbmNvbnN0IENMT1NJTkcgPSAxO1xuY29uc3QgQ0xPU0VEID0gMjtcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQgc2VydmVyLlxuICpcbiAqIEBleHRlbmRzIEV2ZW50RW1pdHRlclxuICovXG5jbGFzcyBXZWJTb2NrZXRTZXJ2ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICAvKipcbiAgICogQ3JlYXRlIGEgYFdlYlNvY2tldFNlcnZlcmAgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbmZpZ3VyYXRpb24gb3B0aW9uc1xuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHM9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYXV0b1Bvbmc9dHJ1ZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvXG4gICAqICAgICBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwb25nIGluIHJlc3BvbnNlIHRvIGEgcGluZ1xuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMuYmFja2xvZz01MTFdIFRoZSBtYXhpbXVtIGxlbmd0aCBvZiB0aGUgcXVldWUgb2ZcbiAgICogICAgIHBlbmRpbmcgY29ubmVjdGlvbnNcbiAgICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5jbGllbnRUcmFja2luZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAgICogICAgIHRyYWNrIGNsaWVudHNcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsb3NlVGltZW91dD0zMDAwMF0gRHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvXG4gICAqICAgICB3YWl0IGZvciB0aGUgY2xvc2luZyBoYW5kc2hha2UgdG8gZmluaXNoIGFmdGVyIGB3ZWJzb2NrZXQuY2xvc2UoKWAgaXNcbiAgICogICAgIGNhbGxlZFxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5oYW5kbGVQcm90b2NvbHNdIEEgaG9vayB0byBoYW5kbGUgcHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbb3B0aW9ucy5ob3N0XSBUaGUgaG9zdG5hbWUgd2hlcmUgdG8gYmluZCB0aGUgc2VydmVyXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhQYXlsb2FkPTEwNDg1NzYwMF0gVGhlIG1heGltdW0gYWxsb3dlZCBtZXNzYWdlXG4gICAqICAgICBzaXplXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubm9TZXJ2ZXI9ZmFsc2VdIEVuYWJsZSBubyBzZXJ2ZXIgbW9kZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gW29wdGlvbnMucGF0aF0gQWNjZXB0IG9ubHkgY29ubmVjdGlvbnMgbWF0Y2hpbmcgdGhpcyBwYXRoXG4gICAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9ZmFsc2VdIEVuYWJsZS9kaXNhYmxlXG4gICAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLnBvcnRdIFRoZSBwb3J0IHdoZXJlIHRvIGJpbmQgdGhlIHNlcnZlclxuICAgKiBAcGFyYW0geyhodHRwLlNlcnZlcnxodHRwcy5TZXJ2ZXIpfSBbb3B0aW9ucy5zZXJ2ZXJdIEEgcHJlLWNyZWF0ZWQgSFRUUC9TXG4gICAqICAgICBzZXJ2ZXIgdG8gdXNlXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuc2tpcFVURjhWYWxpZGF0aW9uPWZhbHNlXSBTcGVjaWZpZXMgd2hldGhlciBvclxuICAgKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMudmVyaWZ5Q2xpZW50XSBBIGhvb2sgdG8gcmVqZWN0IGNvbm5lY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLldlYlNvY2tldD1XZWJTb2NrZXRdIFNwZWNpZmllcyB0aGUgYFdlYlNvY2tldGBcbiAgICogICAgIGNsYXNzIHRvIHVzZS4gSXQgbXVzdCBiZSB0aGUgYFdlYlNvY2tldGAgY2xhc3Mgb3IgY2xhc3MgdGhhdCBleHRlbmRzIGl0XG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gQSBsaXN0ZW5lciBmb3IgdGhlIGBsaXN0ZW5pbmdgIGV2ZW50XG4gICAqL1xuICBjb25zdHJ1Y3RvcihvcHRpb25zLCBjYWxsYmFjaykge1xuICAgIHN1cGVyKCk7XG5cbiAgICBvcHRpb25zID0ge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdHJ1ZSxcbiAgICAgIGF1dG9Qb25nOiB0cnVlLFxuICAgICAgbWF4UGF5bG9hZDogMTAwICogMTAyNCAqIDEwMjQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgICAgcGVyTWVzc2FnZURlZmxhdGU6IGZhbHNlLFxuICAgICAgaGFuZGxlUHJvdG9jb2xzOiBudWxsLFxuICAgICAgY2xpZW50VHJhY2tpbmc6IHRydWUsXG4gICAgICBjbG9zZVRpbWVvdXQ6IENMT1NFX1RJTUVPVVQsXG4gICAgICB2ZXJpZnlDbGllbnQ6IG51bGwsXG4gICAgICBub1NlcnZlcjogZmFsc2UsXG4gICAgICBiYWNrbG9nOiBudWxsLCAvLyB1c2UgZGVmYXVsdCAoNTExIGFzIGltcGxlbWVudGVkIGluIG5ldC5qcylcbiAgICAgIHNlcnZlcjogbnVsbCxcbiAgICAgIGhvc3Q6IG51bGwsXG4gICAgICBwYXRoOiBudWxsLFxuICAgICAgcG9ydDogbnVsbCxcbiAgICAgIFdlYlNvY2tldCxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKFxuICAgICAgKG9wdGlvbnMucG9ydCA9PSBudWxsICYmICFvcHRpb25zLnNlcnZlciAmJiAhb3B0aW9ucy5ub1NlcnZlcikgfHxcbiAgICAgIChvcHRpb25zLnBvcnQgIT0gbnVsbCAmJiAob3B0aW9ucy5zZXJ2ZXIgfHwgb3B0aW9ucy5ub1NlcnZlcikpIHx8XG4gICAgICAob3B0aW9ucy5zZXJ2ZXIgJiYgb3B0aW9ucy5ub1NlcnZlcilcbiAgICApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICdPbmUgYW5kIG9ubHkgb25lIG9mIHRoZSBcInBvcnRcIiwgXCJzZXJ2ZXJcIiwgb3IgXCJub1NlcnZlclwiIG9wdGlvbnMgJyArXG4gICAgICAgICAgJ211c3QgYmUgc3BlY2lmaWVkJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5wb3J0ICE9IG51bGwpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IGh0dHAuY3JlYXRlU2VydmVyKChyZXEsIHJlcykgPT4ge1xuICAgICAgICBjb25zdCBib2R5ID0gaHR0cC5TVEFUVVNfQ09ERVNbNDI2XTtcblxuICAgICAgICByZXMud3JpdGVIZWFkKDQyNiwge1xuICAgICAgICAgICdDb250ZW50LUxlbmd0aCc6IGJvZHkubGVuZ3RoLFxuICAgICAgICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9wbGFpbidcbiAgICAgICAgfSk7XG4gICAgICAgIHJlcy5lbmQoYm9keSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NlcnZlci5saXN0ZW4oXG4gICAgICAgIG9wdGlvbnMucG9ydCxcbiAgICAgICAgb3B0aW9ucy5ob3N0LFxuICAgICAgICBvcHRpb25zLmJhY2tsb2csXG4gICAgICAgIGNhbGxiYWNrXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAob3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIHRoaXMuX3NlcnZlciA9IG9wdGlvbnMuc2VydmVyO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgIGNvbnN0IGVtaXRDb25uZWN0aW9uID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2Nvbm5lY3Rpb24nKTtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzID0gYWRkTGlzdGVuZXJzKHRoaXMuX3NlcnZlciwge1xuICAgICAgICBsaXN0ZW5pbmc6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdsaXN0ZW5pbmcnKSxcbiAgICAgICAgZXJyb3I6IHRoaXMuZW1pdC5iaW5kKHRoaXMsICdlcnJvcicpLFxuICAgICAgICB1cGdyYWRlOiAocmVxLCBzb2NrZXQsIGhlYWQpID0+IHtcbiAgICAgICAgICB0aGlzLmhhbmRsZVVwZ3JhZGUocmVxLCBzb2NrZXQsIGhlYWQsIGVtaXRDb25uZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPT09IHRydWUpIG9wdGlvbnMucGVyTWVzc2FnZURlZmxhdGUgPSB7fTtcbiAgICBpZiAob3B0aW9ucy5jbGllbnRUcmFja2luZykge1xuICAgICAgdGhpcy5jbGllbnRzID0gbmV3IFNldCgpO1xuICAgICAgdGhpcy5fc2hvdWxkRW1pdENsb3NlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB0aGlzLl9zdGF0ZSA9IFJVTk5JTkc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgYm91bmQgYWRkcmVzcywgdGhlIGFkZHJlc3MgZmFtaWx5IG5hbWUsIGFuZCBwb3J0IG9mIHRoZSBzZXJ2ZXJcbiAgICogYXMgcmVwb3J0ZWQgYnkgdGhlIG9wZXJhdGluZyBzeXN0ZW0gaWYgbGlzdGVuaW5nIG9uIGFuIElQIHNvY2tldC5cbiAgICogSWYgdGhlIHNlcnZlciBpcyBsaXN0ZW5pbmcgb24gYSBwaXBlIG9yIFVOSVggZG9tYWluIHNvY2tldCwgdGhlIG5hbWUgaXNcbiAgICogcmV0dXJuZWQgYXMgYSBzdHJpbmcuXG4gICAqXG4gICAqIEByZXR1cm4geyhPYmplY3R8U3RyaW5nfG51bGwpfSBUaGUgYWRkcmVzcyBvZiB0aGUgc2VydmVyXG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGFkZHJlc3MoKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5ub1NlcnZlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc2VydmVyIGlzIG9wZXJhdGluZyBpbiBcIm5vU2VydmVyXCIgbW9kZScpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fc2VydmVyKSByZXR1cm4gbnVsbDtcbiAgICByZXR1cm4gdGhpcy5fc2VydmVyLmFkZHJlc3MoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdG9wIHRoZSBzZXJ2ZXIgZnJvbSBhY2NlcHRpbmcgbmV3IGNvbm5lY3Rpb25zIGFuZCBlbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnRcbiAgICogd2hlbiBhbGwgZXhpc3RpbmcgY29ubmVjdGlvbnMgYXJlIGNsb3NlZC5cbiAgICpcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBBIG9uZS10aW1lIGxpc3RlbmVyIGZvciB0aGUgYCdjbG9zZSdgIGV2ZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIGNsb3NlKGNiKSB7XG4gICAgaWYgKHRoaXMuX3N0YXRlID09PSBDTE9TRUQpIHtcbiAgICAgIGlmIChjYikge1xuICAgICAgICB0aGlzLm9uY2UoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgIGNiKG5ldyBFcnJvcignVGhlIHNlcnZlciBpcyBub3QgcnVubmluZycpKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoY2IpIHRoaXMub25jZSgnY2xvc2UnLCBjYik7XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPT09IENMT1NJTkcpIHJldHVybjtcbiAgICB0aGlzLl9zdGF0ZSA9IENMT1NJTkc7XG5cbiAgICBpZiAodGhpcy5vcHRpb25zLm5vU2VydmVyIHx8IHRoaXMub3B0aW9ucy5zZXJ2ZXIpIHtcbiAgICAgIGlmICh0aGlzLl9zZXJ2ZXIpIHtcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICAgIHRoaXMuX3JlbW92ZUxpc3RlbmVycyA9IHRoaXMuX3NlcnZlciA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmNsaWVudHMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNsaWVudHMuc2l6ZSkge1xuICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZW1pdENsb3NlLCB0aGlzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl9zaG91bGRFbWl0Q2xvc2UgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGVtaXRDbG9zZSwgdGhpcyk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNlcnZlciA9IHRoaXMuX3NlcnZlcjtcblxuICAgICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXJzKCk7XG4gICAgICB0aGlzLl9yZW1vdmVMaXN0ZW5lcnMgPSB0aGlzLl9zZXJ2ZXIgPSBudWxsO1xuXG4gICAgICAvL1xuICAgICAgLy8gVGhlIEhUVFAvUyBzZXJ2ZXIgd2FzIGNyZWF0ZWQgaW50ZXJuYWxseS4gQ2xvc2UgaXQsIGFuZCByZWx5IG9uIGl0c1xuICAgICAgLy8gYCdjbG9zZSdgIGV2ZW50LlxuICAgICAgLy9cbiAgICAgIHNlcnZlci5jbG9zZSgoKSA9PiB7XG4gICAgICAgIGVtaXRDbG9zZSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZWUgaWYgYSBnaXZlbiByZXF1ZXN0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IHRoaXMgc2VydmVyIGluc3RhbmNlLlxuICAgKlxuICAgKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgUmVxdWVzdCBvYmplY3QgdG8gaW5zcGVjdFxuICAgKiBAcmV0dXJuIHtCb29sZWFufSBgdHJ1ZWAgaWYgdGhlIHJlcXVlc3QgaXMgdmFsaWQsIGVsc2UgYGZhbHNlYFxuICAgKiBAcHVibGljXG4gICAqL1xuICBzaG91bGRIYW5kbGUocmVxKSB7XG4gICAgaWYgKHRoaXMub3B0aW9ucy5wYXRoKSB7XG4gICAgICBjb25zdCBpbmRleCA9IHJlcS51cmwuaW5kZXhPZignPycpO1xuICAgICAgY29uc3QgcGF0aG5hbWUgPSBpbmRleCAhPT0gLTEgPyByZXEudXJsLnNsaWNlKDAsIGluZGV4KSA6IHJlcS51cmw7XG5cbiAgICAgIGlmIChwYXRobmFtZSAhPT0gdGhpcy5vcHRpb25zLnBhdGgpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBIYW5kbGUgYSBIVFRQIFVwZ3JhZGUgcmVxdWVzdC5cbiAgICpcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgaGFuZGxlVXBncmFkZShyZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICBzb2NrZXQub24oJ2Vycm9yJywgc29ja2V0T25FcnJvcik7XG5cbiAgICBjb25zdCBrZXkgPSByZXEuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1rZXknXTtcbiAgICBjb25zdCB1cGdyYWRlID0gcmVxLmhlYWRlcnMudXBncmFkZTtcbiAgICBjb25zdCB2ZXJzaW9uID0gK3JlcS5oZWFkZXJzWydzZWMtd2Vic29ja2V0LXZlcnNpb24nXTtcblxuICAgIGlmIChyZXEubWV0aG9kICE9PSAnR0VUJykge1xuICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIEhUVFAgbWV0aG9kJztcbiAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDA1LCBtZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gdW5kZWZpbmVkIHx8ICFrZXlSZWdleC50ZXN0KGtleSkpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtS2V5IGhlYWRlcic7XG4gICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHZlcnNpb24gIT09IDEzICYmIHZlcnNpb24gIT09IDgpIHtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnTWlzc2luZyBvciBpbnZhbGlkIFNlYy1XZWJTb2NrZXQtVmVyc2lvbiBoZWFkZXInO1xuICAgICAgYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKHRoaXMsIHJlcSwgc29ja2V0LCA0MDAsIG1lc3NhZ2UsIHtcbiAgICAgICAgJ1NlYy1XZWJTb2NrZXQtVmVyc2lvbic6ICcxMywgOCdcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5zaG91bGRIYW5kbGUocmVxKSkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA0MDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlY1dlYlNvY2tldFByb3RvY29sID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtcHJvdG9jb2wnXTtcbiAgICBsZXQgcHJvdG9jb2xzID0gbmV3IFNldCgpO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldFByb3RvY29sICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHByb3RvY29scyA9IHN1YnByb3RvY29sLnBhcnNlKHNlY1dlYlNvY2tldFByb3RvY29sKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1Qcm90b2NvbCBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IodGhpcywgcmVxLCBzb2NrZXQsIDQwMCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVxLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuICAgIGNvbnN0IGV4dGVuc2lvbnMgPSB7fTtcblxuICAgIGlmIChcbiAgICAgIHRoaXMub3B0aW9ucy5wZXJNZXNzYWdlRGVmbGF0ZSAmJlxuICAgICAgc2VjV2ViU29ja2V0RXh0ZW5zaW9ucyAhPT0gdW5kZWZpbmVkXG4gICAgKSB7XG4gICAgICBjb25zdCBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgICAgdGhpcy5vcHRpb25zLnBlck1lc3NhZ2VEZWZsYXRlLFxuICAgICAgICB0cnVlLFxuICAgICAgICB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZFxuICAgICAgKTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgb2ZmZXJzID0gZXh0ZW5zaW9uLnBhcnNlKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMpO1xuXG4gICAgICAgIGlmIChvZmZlcnNbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV0pIHtcbiAgICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQob2ZmZXJzW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKTtcbiAgICAgICAgICBleHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID0gcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnSW52YWxpZCBvciB1bmFjY2VwdGFibGUgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlT3JFbWl0d3NDbGllbnRFcnJvcih0aGlzLCByZXEsIHNvY2tldCwgNDAwLCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vXG4gICAgLy8gT3B0aW9uYWxseSBjYWxsIGV4dGVybmFsIGNsaWVudCB2ZXJpZmljYXRpb24gaGFuZGxlci5cbiAgICAvL1xuICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KSB7XG4gICAgICBjb25zdCBpbmZvID0ge1xuICAgICAgICBvcmlnaW46XG4gICAgICAgICAgcmVxLmhlYWRlcnNbYCR7dmVyc2lvbiA9PT0gOCA/ICdzZWMtd2Vic29ja2V0LW9yaWdpbicgOiAnb3JpZ2luJ31gXSxcbiAgICAgICAgc2VjdXJlOiAhIShyZXEuc29ja2V0LmF1dGhvcml6ZWQgfHwgcmVxLnNvY2tldC5lbmNyeXB0ZWQpLFxuICAgICAgICByZXFcbiAgICAgIH07XG5cbiAgICAgIGlmICh0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50Lmxlbmd0aCA9PT0gMikge1xuICAgICAgICB0aGlzLm9wdGlvbnMudmVyaWZ5Q2xpZW50KGluZm8sICh2ZXJpZmllZCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykgPT4ge1xuICAgICAgICAgIGlmICghdmVyaWZpZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUgfHwgNDAxLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLmNvbXBsZXRlVXBncmFkZShcbiAgICAgICAgICAgIGV4dGVuc2lvbnMsXG4gICAgICAgICAgICBrZXksXG4gICAgICAgICAgICBwcm90b2NvbHMsXG4gICAgICAgICAgICByZXEsXG4gICAgICAgICAgICBzb2NrZXQsXG4gICAgICAgICAgICBoZWFkLFxuICAgICAgICAgICAgY2JcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRoaXMub3B0aW9ucy52ZXJpZnlDbGllbnQoaW5mbykpIHJldHVybiBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIDQwMSk7XG4gICAgfVxuXG4gICAgdGhpcy5jb21wbGV0ZVVwZ3JhZGUoZXh0ZW5zaW9ucywga2V5LCBwcm90b2NvbHMsIHJlcSwgc29ja2V0LCBoZWFkLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogVXBncmFkZSB0aGUgY29ubmVjdGlvbiB0byBXZWJTb2NrZXQuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBleHRlbnNpb25zIFRoZSBhY2NlcHRlZCBleHRlbnNpb25zXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBrZXkgVGhlIHZhbHVlIG9mIHRoZSBgU2VjLVdlYlNvY2tldC1LZXlgIGhlYWRlclxuICAgKiBAcGFyYW0ge1NldH0gcHJvdG9jb2xzIFRoZSBzdWJwcm90b2NvbHNcbiAgICogQHBhcmFtIHtodHRwLkluY29taW5nTWVzc2FnZX0gcmVxIFRoZSByZXF1ZXN0IG9iamVjdFxuICAgKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBuZXR3b3JrIHNvY2tldCBiZXR3ZWVuIHRoZSBzZXJ2ZXIgYW5kIGNsaWVudFxuICAgKiBAcGFyYW0ge0J1ZmZlcn0gaGVhZCBUaGUgZmlyc3QgcGFja2V0IG9mIHRoZSB1cGdyYWRlZCBzdHJlYW1cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2IgQ2FsbGJhY2tcbiAgICogQHRocm93cyB7RXJyb3J9IElmIGNhbGxlZCBtb3JlIHRoYW4gb25jZSB3aXRoIHRoZSBzYW1lIHNvY2tldFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29tcGxldGVVcGdyYWRlKGV4dGVuc2lvbnMsIGtleSwgcHJvdG9jb2xzLCByZXEsIHNvY2tldCwgaGVhZCwgY2IpIHtcbiAgICAvL1xuICAgIC8vIERlc3Ryb3kgdGhlIHNvY2tldCBpZiB0aGUgY2xpZW50IGhhcyBhbHJlYWR5IHNlbnQgYSBGSU4gcGFja2V0LlxuICAgIC8vXG4gICAgaWYgKCFzb2NrZXQucmVhZGFibGUgfHwgIXNvY2tldC53cml0YWJsZSkgcmV0dXJuIHNvY2tldC5kZXN0cm95KCk7XG5cbiAgICBpZiAoc29ja2V0W2tXZWJTb2NrZXRdKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdzZXJ2ZXIuaGFuZGxlVXBncmFkZSgpIHdhcyBjYWxsZWQgbW9yZSB0aGFuIG9uY2Ugd2l0aCB0aGUgc2FtZSAnICtcbiAgICAgICAgICAnc29ja2V0LCBwb3NzaWJseSBkdWUgdG8gYSBtaXNjb25maWd1cmF0aW9uJ1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fc3RhdGUgPiBSVU5OSU5HKSByZXR1cm4gYWJvcnRIYW5kc2hha2Uoc29ja2V0LCA1MDMpO1xuXG4gICAgY29uc3QgZGlnZXN0ID0gY3JlYXRlSGFzaCgnc2hhMScpXG4gICAgICAudXBkYXRlKGtleSArIEdVSUQpXG4gICAgICAuZGlnZXN0KCdiYXNlNjQnKTtcblxuICAgIGNvbnN0IGhlYWRlcnMgPSBbXG4gICAgICAnSFRUUC8xLjEgMTAxIFN3aXRjaGluZyBQcm90b2NvbHMnLFxuICAgICAgJ1VwZ3JhZGU6IHdlYnNvY2tldCcsXG4gICAgICAnQ29ubmVjdGlvbjogVXBncmFkZScsXG4gICAgICBgU2VjLVdlYlNvY2tldC1BY2NlcHQ6ICR7ZGlnZXN0fWBcbiAgICBdO1xuXG4gICAgY29uc3Qgd3MgPSBuZXcgdGhpcy5vcHRpb25zLldlYlNvY2tldChudWxsLCB1bmRlZmluZWQsIHRoaXMub3B0aW9ucyk7XG5cbiAgICBpZiAocHJvdG9jb2xzLnNpemUpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPcHRpb25hbGx5IGNhbGwgZXh0ZXJuYWwgcHJvdG9jb2wgc2VsZWN0aW9uIGhhbmRsZXIuXG4gICAgICAvL1xuICAgICAgY29uc3QgcHJvdG9jb2wgPSB0aGlzLm9wdGlvbnMuaGFuZGxlUHJvdG9jb2xzXG4gICAgICAgID8gdGhpcy5vcHRpb25zLmhhbmRsZVByb3RvY29scyhwcm90b2NvbHMsIHJlcSlcbiAgICAgICAgOiBwcm90b2NvbHMudmFsdWVzKCkubmV4dCgpLnZhbHVlO1xuXG4gICAgICBpZiAocHJvdG9jb2wpIHtcbiAgICAgICAgaGVhZGVycy5wdXNoKGBTZWMtV2ViU29ja2V0LVByb3RvY29sOiAke3Byb3RvY29sfWApO1xuICAgICAgICB3cy5fcHJvdG9jb2wgPSBwcm90b2NvbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgY29uc3QgcGFyYW1zID0gZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5wYXJhbXM7XG4gICAgICBjb25zdCB2YWx1ZSA9IGV4dGVuc2lvbi5mb3JtYXQoe1xuICAgICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IFtwYXJhbXNdXG4gICAgICB9KTtcbiAgICAgIGhlYWRlcnMucHVzaChgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zOiAke3ZhbHVlfWApO1xuICAgICAgd3MuX2V4dGVuc2lvbnMgPSBleHRlbnNpb25zO1xuICAgIH1cblxuICAgIC8vXG4gICAgLy8gQWxsb3cgZXh0ZXJuYWwgbW9kaWZpY2F0aW9uL2luc3BlY3Rpb24gb2YgaGFuZHNoYWtlIGhlYWRlcnMuXG4gICAgLy9cbiAgICB0aGlzLmVtaXQoJ2hlYWRlcnMnLCBoZWFkZXJzLCByZXEpO1xuXG4gICAgc29ja2V0LndyaXRlKGhlYWRlcnMuY29uY2F0KCdcXHJcXG4nKS5qb2luKCdcXHJcXG4nKSk7XG4gICAgc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIHNvY2tldE9uRXJyb3IpO1xuXG4gICAgd3Muc2V0U29ja2V0KHNvY2tldCwgaGVhZCwge1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogdGhpcy5vcHRpb25zLmFsbG93U3luY2hyb25vdXNFdmVudHMsXG4gICAgICBtYXhQYXlsb2FkOiB0aGlzLm9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogdGhpcy5vcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvblxuICAgIH0pO1xuXG4gICAgaWYgKHRoaXMuY2xpZW50cykge1xuICAgICAgdGhpcy5jbGllbnRzLmFkZCh3cyk7XG4gICAgICB3cy5vbignY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgIHRoaXMuY2xpZW50cy5kZWxldGUod3MpO1xuXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRFbWl0Q2xvc2UgJiYgIXRoaXMuY2xpZW50cy5zaXplKSB7XG4gICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0Q2xvc2UsIHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjYih3cywgcmVxKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldFNlcnZlcjtcblxuLyoqXG4gKiBBZGQgZXZlbnQgbGlzdGVuZXJzIG9uIGFuIGBFdmVudEVtaXR0ZXJgIHVzaW5nIGEgbWFwIG9mIDxldmVudCwgbGlzdGVuZXI+XG4gKiBwYWlycy5cbiAqXG4gKiBAcGFyYW0ge0V2ZW50RW1pdHRlcn0gc2VydmVyIFRoZSBldmVudCBlbWl0dGVyXG4gKiBAcGFyYW0ge09iamVjdC48U3RyaW5nLCBGdW5jdGlvbj59IG1hcCBUaGUgbGlzdGVuZXJzIHRvIGFkZFxuICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gdGhhdCB3aWxsIHJlbW92ZSB0aGUgYWRkZWQgbGlzdGVuZXJzIHdoZW5cbiAqICAgICBjYWxsZWRcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFkZExpc3RlbmVycyhzZXJ2ZXIsIG1hcCkge1xuICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHNlcnZlci5vbihldmVudCwgbWFwW2V2ZW50XSk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHJlbW92ZUxpc3RlbmVycygpIHtcbiAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIE9iamVjdC5rZXlzKG1hcCkpIHtcbiAgICAgIHNlcnZlci5yZW1vdmVMaXN0ZW5lcihldmVudCwgbWFwW2V2ZW50XSk7XG4gICAgfVxuICB9O1xufVxuXG4vKipcbiAqIEVtaXQgYSBgJ2Nsb3NlJ2AgZXZlbnQgb24gYW4gYEV2ZW50RW1pdHRlcmAuXG4gKlxuICogQHBhcmFtIHtFdmVudEVtaXR0ZXJ9IHNlcnZlciBUaGUgZXZlbnQgZW1pdHRlclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW1pdENsb3NlKHNlcnZlcikge1xuICBzZXJ2ZXIuX3N0YXRlID0gQ0xPU0VEO1xuICBzZXJ2ZXIuZW1pdCgnY2xvc2UnKTtcbn1cblxuLyoqXG4gKiBIYW5kbGUgc29ja2V0IGVycm9ycy5cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzb2NrZXRPbkVycm9yKCkge1xuICB0aGlzLmRlc3Ryb3koKTtcbn1cblxuLyoqXG4gKiBDbG9zZSB0aGUgY29ubmVjdGlvbiB3aGVuIHByZWNvbmRpdGlvbnMgYXJlIG5vdCBmdWxmaWxsZWQuXG4gKlxuICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgc29ja2V0IG9mIHRoZSB1cGdyYWRlIHJlcXVlc3RcbiAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIFRoZSBIVFRQIHJlc3BvbnNlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge1N0cmluZ30gW21lc3NhZ2VdIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gQWRkaXRpb25hbCBIVFRQIHJlc3BvbnNlIGhlYWRlcnNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGFib3J0SGFuZHNoYWtlKHNvY2tldCwgY29kZSwgbWVzc2FnZSwgaGVhZGVycykge1xuICAvL1xuICAvLyBUaGUgc29ja2V0IGlzIHdyaXRhYmxlIHVubGVzcyB0aGUgdXNlciBkZXN0cm95ZWQgb3IgZW5kZWQgaXQgYmVmb3JlIGNhbGxpbmdcbiAgLy8gYHNlcnZlci5oYW5kbGVVcGdyYWRlKClgIG9yIGluIHRoZSBgdmVyaWZ5Q2xpZW50YCBmdW5jdGlvbiwgd2hpY2ggaXMgYSB1c2VyXG4gIC8vIGVycm9yLiBIYW5kbGluZyB0aGlzIGRvZXMgbm90IG1ha2UgbXVjaCBzZW5zZSBhcyB0aGUgd29yc3QgdGhhdCBjYW4gaGFwcGVuXG4gIC8vIGlzIHRoYXQgc29tZSBvZiB0aGUgZGF0YSB3cml0dGVuIGJ5IHRoZSB1c2VyIG1pZ2h0IGJlIGRpc2NhcmRlZCBkdWUgdG8gdGhlXG4gIC8vIGNhbGwgdG8gYHNvY2tldC5lbmQoKWAgYmVsb3csIHdoaWNoIHRyaWdnZXJzIGFuIGAnZXJyb3InYCBldmVudCB0aGF0IGluXG4gIC8vIHR1cm4gY2F1c2VzIHRoZSBzb2NrZXQgdG8gYmUgZGVzdHJveWVkLlxuICAvL1xuICBtZXNzYWdlID0gbWVzc2FnZSB8fCBodHRwLlNUQVRVU19DT0RFU1tjb2RlXTtcbiAgaGVhZGVycyA9IHtcbiAgICBDb25uZWN0aW9uOiAnY2xvc2UnLFxuICAgICdDb250ZW50LVR5cGUnOiAndGV4dC9odG1sJyxcbiAgICAnQ29udGVudC1MZW5ndGgnOiBCdWZmZXIuYnl0ZUxlbmd0aChtZXNzYWdlKSxcbiAgICAuLi5oZWFkZXJzXG4gIH07XG5cbiAgc29ja2V0Lm9uY2UoJ2ZpbmlzaCcsIHNvY2tldC5kZXN0cm95KTtcblxuICBzb2NrZXQuZW5kKFxuICAgIGBIVFRQLzEuMSAke2NvZGV9ICR7aHR0cC5TVEFUVVNfQ09ERVNbY29kZV19XFxyXFxuYCArXG4gICAgICBPYmplY3Qua2V5cyhoZWFkZXJzKVxuICAgICAgICAubWFwKChoKSA9PiBgJHtofTogJHtoZWFkZXJzW2hdfWApXG4gICAgICAgIC5qb2luKCdcXHJcXG4nKSArXG4gICAgICAnXFxyXFxuXFxyXFxuJyArXG4gICAgICBtZXNzYWdlXG4gICk7XG59XG5cbi8qKlxuICogRW1pdCBhIGAnd3NDbGllbnRFcnJvcidgIGV2ZW50IG9uIGEgYFdlYlNvY2tldFNlcnZlcmAgaWYgdGhlcmUgaXMgYXQgbGVhc3RcbiAqIG9uZSBsaXN0ZW5lciBmb3IgaXQsIG90aGVyd2lzZSBjYWxsIGBhYm9ydEhhbmRzaGFrZSgpYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldFNlcnZlcn0gc2VydmVyIFRoZSBXZWJTb2NrZXQgc2VydmVyXG4gKiBAcGFyYW0ge2h0dHAuSW5jb21pbmdNZXNzYWdlfSByZXEgVGhlIHJlcXVlc3Qgb2JqZWN0XG4gKiBAcGFyYW0ge0R1cGxleH0gc29ja2V0IFRoZSBzb2NrZXQgb2YgdGhlIHVwZ3JhZGUgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIEhUVFAgcmVzcG9uc2Ugc3RhdHVzIGNvZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBIVFRQIHJlc3BvbnNlIGJvZHlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbaGVhZGVyc10gVGhlIEhUVFAgcmVzcG9uc2UgaGVhZGVyc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yKFxuICBzZXJ2ZXIsXG4gIHJlcSxcbiAgc29ja2V0LFxuICBjb2RlLFxuICBtZXNzYWdlLFxuICBoZWFkZXJzXG4pIHtcbiAgaWYgKHNlcnZlci5saXN0ZW5lckNvdW50KCd3c0NsaWVudEVycm9yJykpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoZXJyLCBhYm9ydEhhbmRzaGFrZU9yRW1pdHdzQ2xpZW50RXJyb3IpO1xuXG4gICAgc2VydmVyLmVtaXQoJ3dzQ2xpZW50RXJyb3InLCBlcnIsIHNvY2tldCwgcmVxKTtcbiAgfSBlbHNlIHtcbiAgICBhYm9ydEhhbmRzaGFrZShzb2NrZXQsIGNvZGUsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICB9XG59XG4iXSwibmFtZXMiOlsiRXZlbnRFbWl0dGVyIiwicmVxdWlyZSIsImh0dHAiLCJEdXBsZXgiLCJjcmVhdGVIYXNoIiwiZXh0ZW5zaW9uIiwiUGVyTWVzc2FnZURlZmxhdGUiLCJzdWJwcm90b2NvbCIsIldlYlNvY2tldCIsIkNMT1NFX1RJTUVPVVQiLCJHVUlEIiwia1dlYlNvY2tldCIsImtleVJlZ2V4IiwiUlVOTklORyIsIkNMT1NJTkciLCJDTE9TRUQiLCJXZWJTb2NrZXRTZXJ2ZXIiLCJjb25zdHJ1Y3RvciIsIm9wdGlvbnMiLCJjYWxsYmFjayIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJhdXRvUG9uZyIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJwZXJNZXNzYWdlRGVmbGF0ZSIsImhhbmRsZVByb3RvY29scyIsImNsaWVudFRyYWNraW5nIiwiY2xvc2VUaW1lb3V0IiwidmVyaWZ5Q2xpZW50Iiwibm9TZXJ2ZXIiLCJiYWNrbG9nIiwic2VydmVyIiwiaG9zdCIsInBhdGgiLCJwb3J0IiwiVHlwZUVycm9yIiwiX3NlcnZlciIsImNyZWF0ZVNlcnZlciIsInJlcSIsInJlcyIsImJvZHkiLCJTVEFUVVNfQ09ERVMiLCJ3cml0ZUhlYWQiLCJsZW5ndGgiLCJlbmQiLCJsaXN0ZW4iLCJlbWl0Q29ubmVjdGlvbiIsImVtaXQiLCJiaW5kIiwiX3JlbW92ZUxpc3RlbmVycyIsImFkZExpc3RlbmVycyIsImxpc3RlbmluZyIsImVycm9yIiwidXBncmFkZSIsInNvY2tldCIsImhlYWQiLCJoYW5kbGVVcGdyYWRlIiwiY2xpZW50cyIsIlNldCIsIl9zaG91bGRFbWl0Q2xvc2UiLCJfc3RhdGUiLCJhZGRyZXNzIiwiRXJyb3IiLCJjbG9zZSIsImNiIiwib25jZSIsInByb2Nlc3MiLCJuZXh0VGljayIsImVtaXRDbG9zZSIsInNpemUiLCJzaG91bGRIYW5kbGUiLCJpbmRleCIsInVybCIsImluZGV4T2YiLCJwYXRobmFtZSIsInNsaWNlIiwib24iLCJzb2NrZXRPbkVycm9yIiwia2V5IiwiaGVhZGVycyIsInZlcnNpb24iLCJtZXRob2QiLCJtZXNzYWdlIiwiYWJvcnRIYW5kc2hha2VPckVtaXR3c0NsaWVudEVycm9yIiwidW5kZWZpbmVkIiwidG9Mb3dlckNhc2UiLCJ0ZXN0IiwiYWJvcnRIYW5kc2hha2UiLCJzZWNXZWJTb2NrZXRQcm90b2NvbCIsInByb3RvY29scyIsInBhcnNlIiwiZXJyIiwic2VjV2ViU29ja2V0RXh0ZW5zaW9ucyIsImV4dGVuc2lvbnMiLCJvZmZlcnMiLCJleHRlbnNpb25OYW1lIiwiYWNjZXB0IiwiaW5mbyIsIm9yaWdpbiIsInNlY3VyZSIsImF1dGhvcml6ZWQiLCJlbmNyeXB0ZWQiLCJ2ZXJpZmllZCIsImNvZGUiLCJjb21wbGV0ZVVwZ3JhZGUiLCJyZWFkYWJsZSIsIndyaXRhYmxlIiwiZGVzdHJveSIsImRpZ2VzdCIsInVwZGF0ZSIsIndzIiwicHJvdG9jb2wiLCJ2YWx1ZXMiLCJuZXh0IiwidmFsdWUiLCJwdXNoIiwiX3Byb3RvY29sIiwicGFyYW1zIiwiZm9ybWF0IiwiX2V4dGVuc2lvbnMiLCJ3cml0ZSIsImNvbmNhdCIsImpvaW4iLCJyZW1vdmVMaXN0ZW5lciIsInNldFNvY2tldCIsImFkZCIsImRlbGV0ZSIsIm1vZHVsZSIsImV4cG9ydHMiLCJtYXAiLCJldmVudCIsIk9iamVjdCIsImtleXMiLCJyZW1vdmVMaXN0ZW5lcnMiLCJDb25uZWN0aW9uIiwiQnVmZmVyIiwiYnl0ZUxlbmd0aCIsImgiLCJsaXN0ZW5lckNvdW50IiwiY2FwdHVyZVN0YWNrVHJhY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket-server.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket.js":
/*!**********************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/lib/websocket.js ***!
  \**********************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/* eslint no-unused-vars: [\"error\", { \"varsIgnorePattern\": \"^Duplex|Readable$\", \"caughtErrors\": \"none\" }] */ \nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst net = __webpack_require__(/*! net */ \"net\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst { randomBytes, createHash } = __webpack_require__(/*! crypto */ \"crypto\");\nconst { Duplex, Readable } = __webpack_require__(/*! stream */ \"stream\");\nconst { URL } = __webpack_require__(/*! url */ \"url\");\nconst PerMessageDeflate = __webpack_require__(/*! ./permessage-deflate */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/permessage-deflate.js\");\nconst Receiver = __webpack_require__(/*! ./receiver */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/receiver.js\");\nconst Sender = __webpack_require__(/*! ./sender */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/sender.js\");\nconst { isBlob } = __webpack_require__(/*! ./validation */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/validation.js\");\nconst { BINARY_TYPES, CLOSE_TIMEOUT, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = __webpack_require__(/*! ./constants */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/constants.js\");\nconst { EventTarget: { addEventListener, removeEventListener } } = __webpack_require__(/*! ./event-target */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/event-target.js\");\nconst { format, parse } = __webpack_require__(/*! ./extension */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/extension.js\");\nconst { toBuffer } = __webpack_require__(/*! ./buffer-util */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/buffer-util.js\");\nconst kAborted = Symbol(\"kAborted\");\nconst protocolVersions = [\n    8,\n    13\n];\nconst readyStates = [\n    \"CONNECTING\",\n    \"OPEN\",\n    \"CLOSING\",\n    \"CLOSED\"\n];\nconst subprotocolRegex = /^[!#$%&'*+\\-.0-9A-Z^_`|a-z~]+$/;\n/**\n * Class representing a WebSocket.\n *\n * @extends EventEmitter\n */ class WebSocket extends EventEmitter {\n    /**\n   * Create a new `WebSocket`.\n   *\n   * @param {(String|URL)} address The URL to which to connect\n   * @param {(String|String[])} [protocols] The subprotocols\n   * @param {Object} [options] Connection options\n   */ constructor(address, protocols, options){\n        super();\n        this._binaryType = BINARY_TYPES[0];\n        this._closeCode = 1006;\n        this._closeFrameReceived = false;\n        this._closeFrameSent = false;\n        this._closeMessage = EMPTY_BUFFER;\n        this._closeTimer = null;\n        this._errorEmitted = false;\n        this._extensions = {};\n        this._paused = false;\n        this._protocol = \"\";\n        this._readyState = WebSocket.CONNECTING;\n        this._receiver = null;\n        this._sender = null;\n        this._socket = null;\n        if (address !== null) {\n            this._bufferedAmount = 0;\n            this._isServer = false;\n            this._redirects = 0;\n            if (protocols === undefined) {\n                protocols = [];\n            } else if (!Array.isArray(protocols)) {\n                if (typeof protocols === \"object\" && protocols !== null) {\n                    options = protocols;\n                    protocols = [];\n                } else {\n                    protocols = [\n                        protocols\n                    ];\n                }\n            }\n            initAsClient(this, address, protocols, options);\n        } else {\n            this._autoPong = options.autoPong;\n            this._closeTimeout = options.closeTimeout;\n            this._isServer = true;\n        }\n    }\n    /**\n   * For historical reasons, the custom \"nodebuffer\" type is used by the default\n   * instead of \"blob\".\n   *\n   * @type {String}\n   */ get binaryType() {\n        return this._binaryType;\n    }\n    set binaryType(type) {\n        if (!BINARY_TYPES.includes(type)) return;\n        this._binaryType = type;\n        //\n        // Allow to change `binaryType` on the fly.\n        //\n        if (this._receiver) this._receiver._binaryType = type;\n    }\n    /**\n   * @type {Number}\n   */ get bufferedAmount() {\n        if (!this._socket) return this._bufferedAmount;\n        return this._socket._writableState.length + this._sender._bufferedBytes;\n    }\n    /**\n   * @type {String}\n   */ get extensions() {\n        return Object.keys(this._extensions).join();\n    }\n    /**\n   * @type {Boolean}\n   */ get isPaused() {\n        return this._paused;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onclose() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onerror() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onopen() {\n        return null;\n    }\n    /**\n   * @type {Function}\n   */ /* istanbul ignore next */ get onmessage() {\n        return null;\n    }\n    /**\n   * @type {String}\n   */ get protocol() {\n        return this._protocol;\n    }\n    /**\n   * @type {Number}\n   */ get readyState() {\n        return this._readyState;\n    }\n    /**\n   * @type {String}\n   */ get url() {\n        return this._url;\n    }\n    /**\n   * Set up the socket and the internal resources.\n   *\n   * @param {Duplex} socket The network socket between the server and client\n   * @param {Buffer} head The first packet of the upgraded stream\n   * @param {Object} options Options object\n   * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether\n   *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted\n   *     multiple times in the same tick\n   * @param {Function} [options.generateMask] The function used to generate the\n   *     masking key\n   * @param {Number} [options.maxPayload=0] The maximum allowed message size\n   * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n   *     not to skip UTF-8 validation for text and close messages\n   * @private\n   */ setSocket(socket, head, options) {\n        const receiver = new Receiver({\n            allowSynchronousEvents: options.allowSynchronousEvents,\n            binaryType: this.binaryType,\n            extensions: this._extensions,\n            isServer: this._isServer,\n            maxPayload: options.maxPayload,\n            skipUTF8Validation: options.skipUTF8Validation\n        });\n        const sender = new Sender(socket, this._extensions, options.generateMask);\n        this._receiver = receiver;\n        this._sender = sender;\n        this._socket = socket;\n        receiver[kWebSocket] = this;\n        sender[kWebSocket] = this;\n        socket[kWebSocket] = this;\n        receiver.on(\"conclude\", receiverOnConclude);\n        receiver.on(\"drain\", receiverOnDrain);\n        receiver.on(\"error\", receiverOnError);\n        receiver.on(\"message\", receiverOnMessage);\n        receiver.on(\"ping\", receiverOnPing);\n        receiver.on(\"pong\", receiverOnPong);\n        sender.onerror = senderOnError;\n        //\n        // These methods may not be available if `socket` is just a `Duplex`.\n        //\n        if (socket.setTimeout) socket.setTimeout(0);\n        if (socket.setNoDelay) socket.setNoDelay();\n        if (head.length > 0) socket.unshift(head);\n        socket.on(\"close\", socketOnClose);\n        socket.on(\"data\", socketOnData);\n        socket.on(\"end\", socketOnEnd);\n        socket.on(\"error\", socketOnError);\n        this._readyState = WebSocket.OPEN;\n        this.emit(\"open\");\n    }\n    /**\n   * Emit the `'close'` event.\n   *\n   * @private\n   */ emitClose() {\n        if (!this._socket) {\n            this._readyState = WebSocket.CLOSED;\n            this.emit(\"close\", this._closeCode, this._closeMessage);\n            return;\n        }\n        if (this._extensions[PerMessageDeflate.extensionName]) {\n            this._extensions[PerMessageDeflate.extensionName].cleanup();\n        }\n        this._receiver.removeAllListeners();\n        this._readyState = WebSocket.CLOSED;\n        this.emit(\"close\", this._closeCode, this._closeMessage);\n    }\n    /**\n   * Start a closing handshake.\n   *\n   *          +----------+   +-----------+   +----------+\n   *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -\n   *    |     +----------+   +-----------+   +----------+     |\n   *          +----------+   +-----------+         |\n   * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING\n   *          +----------+   +-----------+   |\n   *    |           |                        |   +---+        |\n   *                +------------------------+-->|fin| - - - -\n   *    |         +---+                      |   +---+\n   *     - - - - -|fin|<---------------------+\n   *              +---+\n   *\n   * @param {Number} [code] Status code explaining why the connection is closing\n   * @param {(String|Buffer)} [data] The reason why the connection is\n   *     closing\n   * @public\n   */ close(code, data) {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            abortHandshake(this, this._req, msg);\n            return;\n        }\n        if (this.readyState === WebSocket.CLOSING) {\n            if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {\n                this._socket.end();\n            }\n            return;\n        }\n        this._readyState = WebSocket.CLOSING;\n        this._sender.close(code, data, !this._isServer, (err)=>{\n            //\n            // This error is handled by the `'error'` listener on the socket. We only\n            // want to know if the close frame has been sent here.\n            //\n            if (err) return;\n            this._closeFrameSent = true;\n            if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {\n                this._socket.end();\n            }\n        });\n        setCloseTimer(this);\n    }\n    /**\n   * Pause the socket.\n   *\n   * @public\n   */ pause() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = true;\n        this._socket.pause();\n    }\n    /**\n   * Send a ping.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the ping is sent\n   * @public\n   */ ping(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.ping(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Send a pong.\n   *\n   * @param {*} [data] The data to send\n   * @param {Boolean} [mask] Indicates whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when the pong is sent\n   * @public\n   */ pong(data, mask, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof data === \"function\") {\n            cb = data;\n            data = mask = undefined;\n        } else if (typeof mask === \"function\") {\n            cb = mask;\n            mask = undefined;\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        if (mask === undefined) mask = !this._isServer;\n        this._sender.pong(data || EMPTY_BUFFER, mask, cb);\n    }\n    /**\n   * Resume the socket.\n   *\n   * @public\n   */ resume() {\n        if (this.readyState === WebSocket.CONNECTING || this.readyState === WebSocket.CLOSED) {\n            return;\n        }\n        this._paused = false;\n        if (!this._receiver._writableState.needDrain) this._socket.resume();\n    }\n    /**\n   * Send a data message.\n   *\n   * @param {*} data The message to send\n   * @param {Object} [options] Options object\n   * @param {Boolean} [options.binary] Specifies whether `data` is binary or\n   *     text\n   * @param {Boolean} [options.compress] Specifies whether or not to compress\n   *     `data`\n   * @param {Boolean} [options.fin=true] Specifies whether the fragment is the\n   *     last one\n   * @param {Boolean} [options.mask] Specifies whether or not to mask `data`\n   * @param {Function} [cb] Callback which is executed when data is written out\n   * @public\n   */ send(data, options, cb) {\n        if (this.readyState === WebSocket.CONNECTING) {\n            throw new Error(\"WebSocket is not open: readyState 0 (CONNECTING)\");\n        }\n        if (typeof options === \"function\") {\n            cb = options;\n            options = {};\n        }\n        if (typeof data === \"number\") data = data.toString();\n        if (this.readyState !== WebSocket.OPEN) {\n            sendAfterClose(this, data, cb);\n            return;\n        }\n        const opts = {\n            binary: typeof data !== \"string\",\n            mask: !this._isServer,\n            compress: true,\n            fin: true,\n            ...options\n        };\n        if (!this._extensions[PerMessageDeflate.extensionName]) {\n            opts.compress = false;\n        }\n        this._sender.send(data || EMPTY_BUFFER, opts, cb);\n    }\n    /**\n   * Forcibly close the connection.\n   *\n   * @public\n   */ terminate() {\n        if (this.readyState === WebSocket.CLOSED) return;\n        if (this.readyState === WebSocket.CONNECTING) {\n            const msg = \"WebSocket was closed before the connection was established\";\n            abortHandshake(this, this._req, msg);\n            return;\n        }\n        if (this._socket) {\n            this._readyState = WebSocket.CLOSING;\n            this._socket.destroy();\n        }\n    }\n}\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} CONNECTING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CONNECTING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CONNECTING\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} OPEN\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"OPEN\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"OPEN\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSING\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSING\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSING\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket\n */ Object.defineProperty(WebSocket, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n/**\n * @constant {Number} CLOSED\n * @memberof WebSocket.prototype\n */ Object.defineProperty(WebSocket.prototype, \"CLOSED\", {\n    enumerable: true,\n    value: readyStates.indexOf(\"CLOSED\")\n});\n[\n    \"binaryType\",\n    \"bufferedAmount\",\n    \"extensions\",\n    \"isPaused\",\n    \"protocol\",\n    \"readyState\",\n    \"url\"\n].forEach((property)=>{\n    Object.defineProperty(WebSocket.prototype, property, {\n        enumerable: true\n    });\n});\n//\n// Add the `onopen`, `onerror`, `onclose`, and `onmessage` attributes.\n// See https://html.spec.whatwg.org/multipage/comms.html#the-websocket-interface\n//\n[\n    \"open\",\n    \"error\",\n    \"close\",\n    \"message\"\n].forEach((method)=>{\n    Object.defineProperty(WebSocket.prototype, `on${method}`, {\n        enumerable: true,\n        get () {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) return listener[kListener];\n            }\n            return null;\n        },\n        set (handler) {\n            for (const listener of this.listeners(method)){\n                if (listener[kForOnEventAttribute]) {\n                    this.removeListener(method, listener);\n                    break;\n                }\n            }\n            if (typeof handler !== \"function\") return;\n            this.addEventListener(method, handler, {\n                [kForOnEventAttribute]: true\n            });\n        }\n    });\n});\nWebSocket.prototype.addEventListener = addEventListener;\nWebSocket.prototype.removeEventListener = removeEventListener;\nmodule.exports = WebSocket;\n/**\n * Initialize a WebSocket client.\n *\n * @param {WebSocket} websocket The client to initialize\n * @param {(String|URL)} address The URL to which to connect\n * @param {Array} protocols The subprotocols\n * @param {Object} [options] Connection options\n * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether any\n *     of the `'message'`, `'ping'`, and `'pong'` events can be emitted multiple\n *     times in the same tick\n * @param {Boolean} [options.autoPong=true] Specifies whether or not to\n *     automatically send a pong in response to a ping\n * @param {Number} [options.closeTimeout=30000] Duration in milliseconds to wait\n *     for the closing handshake to finish after `websocket.close()` is called\n * @param {Function} [options.finishRequest] A function which can be used to\n *     customize the headers of each http request before it is sent\n * @param {Boolean} [options.followRedirects=false] Whether or not to follow\n *     redirects\n * @param {Function} [options.generateMask] The function used to generate the\n *     masking key\n * @param {Number} [options.handshakeTimeout] Timeout in milliseconds for the\n *     handshake request\n * @param {Number} [options.maxPayload=104857600] The maximum allowed message\n *     size\n * @param {Number} [options.maxRedirects=10] The maximum number of redirects\n *     allowed\n * @param {String} [options.origin] Value of the `Origin` or\n *     `Sec-WebSocket-Origin` header\n * @param {(Boolean|Object)} [options.perMessageDeflate=true] Enable/disable\n *     permessage-deflate\n * @param {Number} [options.protocolVersion=13] Value of the\n *     `Sec-WebSocket-Version` header\n * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or\n *     not to skip UTF-8 validation for text and close messages\n * @private\n */ function initAsClient(websocket, address, protocols, options) {\n    const opts = {\n        allowSynchronousEvents: true,\n        autoPong: true,\n        closeTimeout: CLOSE_TIMEOUT,\n        protocolVersion: protocolVersions[1],\n        maxPayload: 100 * 1024 * 1024,\n        skipUTF8Validation: false,\n        perMessageDeflate: true,\n        followRedirects: false,\n        maxRedirects: 10,\n        ...options,\n        socketPath: undefined,\n        hostname: undefined,\n        protocol: undefined,\n        timeout: undefined,\n        method: \"GET\",\n        host: undefined,\n        path: undefined,\n        port: undefined\n    };\n    websocket._autoPong = opts.autoPong;\n    websocket._closeTimeout = opts.closeTimeout;\n    if (!protocolVersions.includes(opts.protocolVersion)) {\n        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} ` + `(supported versions: ${protocolVersions.join(\", \")})`);\n    }\n    let parsedUrl;\n    if (address instanceof URL) {\n        parsedUrl = address;\n    } else {\n        try {\n            parsedUrl = new URL(address);\n        } catch (e) {\n            throw new SyntaxError(`Invalid URL: ${address}`);\n        }\n    }\n    if (parsedUrl.protocol === \"http:\") {\n        parsedUrl.protocol = \"ws:\";\n    } else if (parsedUrl.protocol === \"https:\") {\n        parsedUrl.protocol = \"wss:\";\n    }\n    websocket._url = parsedUrl.href;\n    const isSecure = parsedUrl.protocol === \"wss:\";\n    const isIpcUrl = parsedUrl.protocol === \"ws+unix:\";\n    let invalidUrlMessage;\n    if (parsedUrl.protocol !== \"ws:\" && !isSecure && !isIpcUrl) {\n        invalidUrlMessage = 'The URL\\'s protocol must be one of \"ws:\", \"wss:\", ' + '\"http:\", \"https:\", or \"ws+unix:\"';\n    } else if (isIpcUrl && !parsedUrl.pathname) {\n        invalidUrlMessage = \"The URL's pathname is empty\";\n    } else if (parsedUrl.hash) {\n        invalidUrlMessage = \"The URL contains a fragment identifier\";\n    }\n    if (invalidUrlMessage) {\n        const err = new SyntaxError(invalidUrlMessage);\n        if (websocket._redirects === 0) {\n            throw err;\n        } else {\n            emitErrorAndClose(websocket, err);\n            return;\n        }\n    }\n    const defaultPort = isSecure ? 443 : 80;\n    const key = randomBytes(16).toString(\"base64\");\n    const request = isSecure ? https.request : http.request;\n    const protocolSet = new Set();\n    let perMessageDeflate;\n    opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);\n    opts.defaultPort = opts.defaultPort || defaultPort;\n    opts.port = parsedUrl.port || defaultPort;\n    opts.host = parsedUrl.hostname.startsWith(\"[\") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;\n    opts.headers = {\n        ...opts.headers,\n        \"Sec-WebSocket-Version\": opts.protocolVersion,\n        \"Sec-WebSocket-Key\": key,\n        Connection: \"Upgrade\",\n        Upgrade: \"websocket\"\n    };\n    opts.path = parsedUrl.pathname + parsedUrl.search;\n    opts.timeout = opts.handshakeTimeout;\n    if (opts.perMessageDeflate) {\n        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);\n        opts.headers[\"Sec-WebSocket-Extensions\"] = format({\n            [PerMessageDeflate.extensionName]: perMessageDeflate.offer()\n        });\n    }\n    if (protocols.length) {\n        for (const protocol of protocols){\n            if (typeof protocol !== \"string\" || !subprotocolRegex.test(protocol) || protocolSet.has(protocol)) {\n                throw new SyntaxError(\"An invalid or duplicated subprotocol was specified\");\n            }\n            protocolSet.add(protocol);\n        }\n        opts.headers[\"Sec-WebSocket-Protocol\"] = protocols.join(\",\");\n    }\n    if (opts.origin) {\n        if (opts.protocolVersion < 13) {\n            opts.headers[\"Sec-WebSocket-Origin\"] = opts.origin;\n        } else {\n            opts.headers.Origin = opts.origin;\n        }\n    }\n    if (parsedUrl.username || parsedUrl.password) {\n        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;\n    }\n    if (isIpcUrl) {\n        const parts = opts.path.split(\":\");\n        opts.socketPath = parts[0];\n        opts.path = parts[1];\n    }\n    let req;\n    if (opts.followRedirects) {\n        if (websocket._redirects === 0) {\n            websocket._originalIpc = isIpcUrl;\n            websocket._originalSecure = isSecure;\n            websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;\n            const headers = options && options.headers;\n            //\n            // Shallow copy the user provided options so that headers can be changed\n            // without mutating the original object.\n            //\n            options = {\n                ...options,\n                headers: {}\n            };\n            if (headers) {\n                for (const [key, value] of Object.entries(headers)){\n                    options.headers[key.toLowerCase()] = value;\n                }\n            }\n        } else if (websocket.listenerCount(\"redirect\") === 0) {\n            const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;\n            if (!isSameHost || websocket._originalSecure && !isSecure) {\n                //\n                // Match curl 7.77.0 behavior and drop the following headers. These\n                // headers are also dropped when following a redirect to a subdomain.\n                //\n                delete opts.headers.authorization;\n                delete opts.headers.cookie;\n                if (!isSameHost) delete opts.headers.host;\n                opts.auth = undefined;\n            }\n        }\n        //\n        // Match curl 7.77.0 behavior and make the first `Authorization` header win.\n        // If the `Authorization` header is set, then there is nothing to do as it\n        // will take precedence.\n        //\n        if (opts.auth && !options.headers.authorization) {\n            options.headers.authorization = \"Basic \" + Buffer.from(opts.auth).toString(\"base64\");\n        }\n        req = websocket._req = request(opts);\n        if (websocket._redirects) {\n            //\n            // Unlike what is done for the `'upgrade'` event, no early exit is\n            // triggered here if the user calls `websocket.close()` or\n            // `websocket.terminate()` from a listener of the `'redirect'` event. This\n            // is because the user can also call `request.destroy()` with an error\n            // before calling `websocket.close()` or `websocket.terminate()` and this\n            // would result in an error being emitted on the `request` object with no\n            // `'error'` event listeners attached.\n            //\n            websocket.emit(\"redirect\", websocket.url, req);\n        }\n    } else {\n        req = websocket._req = request(opts);\n    }\n    if (opts.timeout) {\n        req.on(\"timeout\", ()=>{\n            abortHandshake(websocket, req, \"Opening handshake has timed out\");\n        });\n    }\n    req.on(\"error\", (err)=>{\n        if (req === null || req[kAborted]) return;\n        req = websocket._req = null;\n        emitErrorAndClose(websocket, err);\n    });\n    req.on(\"response\", (res)=>{\n        const location = res.headers.location;\n        const statusCode = res.statusCode;\n        if (location && opts.followRedirects && statusCode >= 300 && statusCode < 400) {\n            if (++websocket._redirects > opts.maxRedirects) {\n                abortHandshake(websocket, req, \"Maximum redirects exceeded\");\n                return;\n            }\n            req.abort();\n            let addr;\n            try {\n                addr = new URL(location, address);\n            } catch (e) {\n                const err = new SyntaxError(`Invalid URL: ${location}`);\n                emitErrorAndClose(websocket, err);\n                return;\n            }\n            initAsClient(websocket, addr, protocols, options);\n        } else if (!websocket.emit(\"unexpected-response\", req, res)) {\n            abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);\n        }\n    });\n    req.on(\"upgrade\", (res, socket, head)=>{\n        websocket.emit(\"upgrade\", res);\n        //\n        // The user may have closed the connection from a listener of the\n        // `'upgrade'` event.\n        //\n        if (websocket.readyState !== WebSocket.CONNECTING) return;\n        req = websocket._req = null;\n        const upgrade = res.headers.upgrade;\n        if (upgrade === undefined || upgrade.toLowerCase() !== \"websocket\") {\n            abortHandshake(websocket, socket, \"Invalid Upgrade header\");\n            return;\n        }\n        const digest = createHash(\"sha1\").update(key + GUID).digest(\"base64\");\n        if (res.headers[\"sec-websocket-accept\"] !== digest) {\n            abortHandshake(websocket, socket, \"Invalid Sec-WebSocket-Accept header\");\n            return;\n        }\n        const serverProt = res.headers[\"sec-websocket-protocol\"];\n        let protError;\n        if (serverProt !== undefined) {\n            if (!protocolSet.size) {\n                protError = \"Server sent a subprotocol but none was requested\";\n            } else if (!protocolSet.has(serverProt)) {\n                protError = \"Server sent an invalid subprotocol\";\n            }\n        } else if (protocolSet.size) {\n            protError = \"Server sent no subprotocol\";\n        }\n        if (protError) {\n            abortHandshake(websocket, socket, protError);\n            return;\n        }\n        if (serverProt) websocket._protocol = serverProt;\n        const secWebSocketExtensions = res.headers[\"sec-websocket-extensions\"];\n        if (secWebSocketExtensions !== undefined) {\n            if (!perMessageDeflate) {\n                const message = \"Server sent a Sec-WebSocket-Extensions header but no extension \" + \"was requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            let extensions;\n            try {\n                extensions = parse(secWebSocketExtensions);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            const extensionNames = Object.keys(extensions);\n            if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {\n                const message = \"Server indicated an extension that was not requested\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            try {\n                perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);\n            } catch (err) {\n                const message = \"Invalid Sec-WebSocket-Extensions header\";\n                abortHandshake(websocket, socket, message);\n                return;\n            }\n            websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;\n        }\n        websocket.setSocket(socket, head, {\n            allowSynchronousEvents: opts.allowSynchronousEvents,\n            generateMask: opts.generateMask,\n            maxPayload: opts.maxPayload,\n            skipUTF8Validation: opts.skipUTF8Validation\n        });\n    });\n    if (opts.finishRequest) {\n        opts.finishRequest(req, websocket);\n    } else {\n        req.end();\n    }\n}\n/**\n * Emit the `'error'` and `'close'` events.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {Error} The error to emit\n * @private\n */ function emitErrorAndClose(websocket, err) {\n    websocket._readyState = WebSocket.CLOSING;\n    //\n    // The following assignment is practically useless and is done only for\n    // consistency.\n    //\n    websocket._errorEmitted = true;\n    websocket.emit(\"error\", err);\n    websocket.emitClose();\n}\n/**\n * Create a `net.Socket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {net.Socket} The newly created socket used to start the connection\n * @private\n */ function netConnect(options) {\n    options.path = options.socketPath;\n    return net.connect(options);\n}\n/**\n * Create a `tls.TLSSocket` and initiate a connection.\n *\n * @param {Object} options Connection options\n * @return {tls.TLSSocket} The newly created socket used to start the connection\n * @private\n */ function tlsConnect(options) {\n    options.path = undefined;\n    if (!options.servername && options.servername !== \"\") {\n        options.servername = net.isIP(options.host) ? \"\" : options.host;\n    }\n    return tls.connect(options);\n}\n/**\n * Abort the handshake and emit an error.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {(http.ClientRequest|net.Socket|tls.Socket)} stream The request to\n *     abort or the socket to destroy\n * @param {String} message The error message\n * @private\n */ function abortHandshake(websocket, stream, message) {\n    websocket._readyState = WebSocket.CLOSING;\n    const err = new Error(message);\n    Error.captureStackTrace(err, abortHandshake);\n    if (stream.setHeader) {\n        stream[kAborted] = true;\n        stream.abort();\n        if (stream.socket && !stream.socket.destroyed) {\n            //\n            // On Node.js >= 14.3.0 `request.abort()` does not destroy the socket if\n            // called after the request completed. See\n            // https://github.com/websockets/ws/issues/1869.\n            //\n            stream.socket.destroy();\n        }\n        process.nextTick(emitErrorAndClose, websocket, err);\n    } else {\n        stream.destroy(err);\n        stream.once(\"error\", websocket.emit.bind(websocket, \"error\"));\n        stream.once(\"close\", websocket.emitClose.bind(websocket));\n    }\n}\n/**\n * Handle cases where the `ping()`, `pong()`, or `send()` methods are called\n * when the `readyState` attribute is `CLOSING` or `CLOSED`.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @param {*} [data] The data to send\n * @param {Function} [cb] Callback\n * @private\n */ function sendAfterClose(websocket, data, cb) {\n    if (data) {\n        const length = isBlob(data) ? data.size : toBuffer(data).length;\n        //\n        // The `_bufferedAmount` property is used only when the peer is a client and\n        // the opening handshake fails. Under these circumstances, in fact, the\n        // `setSocket()` method is not called, so the `_socket` and `_sender`\n        // properties are set to `null`.\n        //\n        if (websocket._socket) websocket._sender._bufferedBytes += length;\n        else websocket._bufferedAmount += length;\n    }\n    if (cb) {\n        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} ` + `(${readyStates[websocket.readyState]})`);\n        process.nextTick(cb, err);\n    }\n}\n/**\n * The listener of the `Receiver` `'conclude'` event.\n *\n * @param {Number} code The status code\n * @param {Buffer} reason The reason for closing\n * @private\n */ function receiverOnConclude(code, reason) {\n    const websocket = this[kWebSocket];\n    websocket._closeFrameReceived = true;\n    websocket._closeMessage = reason;\n    websocket._closeCode = code;\n    if (websocket._socket[kWebSocket] === undefined) return;\n    websocket._socket.removeListener(\"data\", socketOnData);\n    process.nextTick(resume, websocket._socket);\n    if (code === 1005) websocket.close();\n    else websocket.close(code, reason);\n}\n/**\n * The listener of the `Receiver` `'drain'` event.\n *\n * @private\n */ function receiverOnDrain() {\n    const websocket = this[kWebSocket];\n    if (!websocket.isPaused) websocket._socket.resume();\n}\n/**\n * The listener of the `Receiver` `'error'` event.\n *\n * @param {(RangeError|Error)} err The emitted error\n * @private\n */ function receiverOnError(err) {\n    const websocket = this[kWebSocket];\n    if (websocket._socket[kWebSocket] !== undefined) {\n        websocket._socket.removeListener(\"data\", socketOnData);\n        //\n        // On Node.js < 14.0.0 the `'error'` event is emitted synchronously. See\n        // https://github.com/websockets/ws/issues/1940.\n        //\n        process.nextTick(resume, websocket._socket);\n        websocket.close(err[kStatusCode]);\n    }\n    if (!websocket._errorEmitted) {\n        websocket._errorEmitted = true;\n        websocket.emit(\"error\", err);\n    }\n}\n/**\n * The listener of the `Receiver` `'finish'` event.\n *\n * @private\n */ function receiverOnFinish() {\n    this[kWebSocket].emitClose();\n}\n/**\n * The listener of the `Receiver` `'message'` event.\n *\n * @param {Buffer|ArrayBuffer|Buffer[])} data The message\n * @param {Boolean} isBinary Specifies whether the message is binary or not\n * @private\n */ function receiverOnMessage(data, isBinary) {\n    this[kWebSocket].emit(\"message\", data, isBinary);\n}\n/**\n * The listener of the `Receiver` `'ping'` event.\n *\n * @param {Buffer} data The data included in the ping frame\n * @private\n */ function receiverOnPing(data) {\n    const websocket = this[kWebSocket];\n    if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);\n    websocket.emit(\"ping\", data);\n}\n/**\n * The listener of the `Receiver` `'pong'` event.\n *\n * @param {Buffer} data The data included in the pong frame\n * @private\n */ function receiverOnPong(data) {\n    this[kWebSocket].emit(\"pong\", data);\n}\n/**\n * Resume a readable stream\n *\n * @param {Readable} stream The readable stream\n * @private\n */ function resume(stream) {\n    stream.resume();\n}\n/**\n * The `Sender` error event handler.\n *\n * @param {Error} The error\n * @private\n */ function senderOnError(err) {\n    const websocket = this[kWebSocket];\n    if (websocket.readyState === WebSocket.CLOSED) return;\n    if (websocket.readyState === WebSocket.OPEN) {\n        websocket._readyState = WebSocket.CLOSING;\n        setCloseTimer(websocket);\n    }\n    //\n    // `socket.end()` is used instead of `socket.destroy()` to allow the other\n    // peer to finish sending queued data. There is no need to set a timer here\n    // because `CLOSING` means that it is already set or not needed.\n    //\n    this._socket.end();\n    if (!websocket._errorEmitted) {\n        websocket._errorEmitted = true;\n        websocket.emit(\"error\", err);\n    }\n}\n/**\n * Set a timer to destroy the underlying raw socket of a WebSocket.\n *\n * @param {WebSocket} websocket The WebSocket instance\n * @private\n */ function setCloseTimer(websocket) {\n    websocket._closeTimer = setTimeout(websocket._socket.destroy.bind(websocket._socket), websocket._closeTimeout);\n}\n/**\n * The listener of the socket `'close'` event.\n *\n * @private\n */ function socketOnClose() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"close\", socketOnClose);\n    this.removeListener(\"data\", socketOnData);\n    this.removeListener(\"end\", socketOnEnd);\n    websocket._readyState = WebSocket.CLOSING;\n    //\n    // The close frame might not have been received or the `'end'` event emitted,\n    // for example, if the socket was destroyed due to an error. Ensure that the\n    // `receiver` stream is closed after writing any remaining buffered data to\n    // it. If the readable side of the socket is in flowing mode then there is no\n    // buffered data as everything has been already written. If instead, the\n    // socket is paused, any possible buffered data will be read as a single\n    // chunk.\n    //\n    if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && this._readableState.length !== 0) {\n        const chunk = this.read(this._readableState.length);\n        websocket._receiver.write(chunk);\n    }\n    websocket._receiver.end();\n    this[kWebSocket] = undefined;\n    clearTimeout(websocket._closeTimer);\n    if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {\n        websocket.emitClose();\n    } else {\n        websocket._receiver.on(\"error\", receiverOnFinish);\n        websocket._receiver.on(\"finish\", receiverOnFinish);\n    }\n}\n/**\n * The listener of the socket `'data'` event.\n *\n * @param {Buffer} chunk A chunk of data\n * @private\n */ function socketOnData(chunk) {\n    if (!this[kWebSocket]._receiver.write(chunk)) {\n        this.pause();\n    }\n}\n/**\n * The listener of the socket `'end'` event.\n *\n * @private\n */ function socketOnEnd() {\n    const websocket = this[kWebSocket];\n    websocket._readyState = WebSocket.CLOSING;\n    websocket._receiver.end();\n    this.end();\n}\n/**\n * The listener of the socket `'error'` event.\n *\n * @private\n */ function socketOnError() {\n    const websocket = this[kWebSocket];\n    this.removeListener(\"error\", socketOnError);\n    this.on(\"error\", NOOP);\n    if (websocket) {\n        websocket._readyState = WebSocket.CLOSING;\n        this.destroy();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL2xpYi93ZWJzb2NrZXQuanMiLCJtYXBwaW5ncyI6IkFBQUEsMEdBQTBHLEdBRTFHO0FBRUEsTUFBTUEsZUFBZUMsbUJBQU9BLENBQUM7QUFDN0IsTUFBTUMsUUFBUUQsbUJBQU9BLENBQUM7QUFDdEIsTUFBTUUsT0FBT0YsbUJBQU9BLENBQUM7QUFDckIsTUFBTUcsTUFBTUgsbUJBQU9BLENBQUM7QUFDcEIsTUFBTUksTUFBTUosbUJBQU9BLENBQUM7QUFDcEIsTUFBTSxFQUFFSyxXQUFXLEVBQUVDLFVBQVUsRUFBRSxHQUFHTixtQkFBT0EsQ0FBQztBQUM1QyxNQUFNLEVBQUVPLE1BQU0sRUFBRUMsUUFBUSxFQUFFLEdBQUdSLG1CQUFPQSxDQUFDO0FBQ3JDLE1BQU0sRUFBRVMsR0FBRyxFQUFFLEdBQUdULG1CQUFPQSxDQUFDO0FBRXhCLE1BQU1VLG9CQUFvQlYsbUJBQU9BLENBQUM7QUFDbEMsTUFBTVcsV0FBV1gsbUJBQU9BLENBQUM7QUFDekIsTUFBTVksU0FBU1osbUJBQU9BLENBQUM7QUFDdkIsTUFBTSxFQUFFYSxNQUFNLEVBQUUsR0FBR2IsbUJBQU9BLENBQUM7QUFFM0IsTUFBTSxFQUNKYyxZQUFZLEVBQ1pDLGFBQWEsRUFDYkMsWUFBWSxFQUNaQyxJQUFJLEVBQ0pDLG9CQUFvQixFQUNwQkMsU0FBUyxFQUNUQyxXQUFXLEVBQ1hDLFVBQVUsRUFDVkMsSUFBSSxFQUNMLEdBQUd0QixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFDSnVCLGFBQWEsRUFBRUMsZ0JBQWdCLEVBQUVDLG1CQUFtQixFQUFFLEVBQ3ZELEdBQUd6QixtQkFBT0EsQ0FBQztBQUNaLE1BQU0sRUFBRTBCLE1BQU0sRUFBRUMsS0FBSyxFQUFFLEdBQUczQixtQkFBT0EsQ0FBQztBQUNsQyxNQUFNLEVBQUU0QixRQUFRLEVBQUUsR0FBRzVCLG1CQUFPQSxDQUFDO0FBRTdCLE1BQU02QixXQUFX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SSxDQUFDNUksV0FBVztJQUVsQyxJQUFJLENBQUN5SSxjQUFjLENBQUMsU0FBU2pEO0lBQzdCLElBQUksQ0FBQ2QsRUFBRSxDQUFDLFNBQVN6RTtJQUVqQixJQUFJMkksV0FBVztRQUNiQSxVQUFVaEgsV0FBVyxHQUFHZixVQUFVeUYsT0FBTztRQUN6QyxJQUFJLENBQUNxQixPQUFPO0lBQ2Q7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJhZm9ybWF0aW9uLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL25vZGVfbW9kdWxlcy93cy9saWIvd2Vic29ja2V0LmpzPzE2NDgiXSwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbXCJlcnJvclwiLCB7IFwidmFyc0lnbm9yZVBhdHRlcm5cIjogXCJeRHVwbGV4fFJlYWRhYmxlJFwiLCBcImNhdWdodEVycm9yc1wiOiBcIm5vbmVcIiB9XSAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmNvbnN0IEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgaHR0cHMgPSByZXF1aXJlKCdodHRwcycpO1xuY29uc3QgaHR0cCA9IHJlcXVpcmUoJ2h0dHAnKTtcbmNvbnN0IG5ldCA9IHJlcXVpcmUoJ25ldCcpO1xuY29uc3QgdGxzID0gcmVxdWlyZSgndGxzJyk7XG5jb25zdCB7IHJhbmRvbUJ5dGVzLCBjcmVhdGVIYXNoIH0gPSByZXF1aXJlKCdjcnlwdG8nKTtcbmNvbnN0IHsgRHVwbGV4LCBSZWFkYWJsZSB9ID0gcmVxdWlyZSgnc3RyZWFtJyk7XG5jb25zdCB7IFVSTCB9ID0gcmVxdWlyZSgndXJsJyk7XG5cbmNvbnN0IFBlck1lc3NhZ2VEZWZsYXRlID0gcmVxdWlyZSgnLi9wZXJtZXNzYWdlLWRlZmxhdGUnKTtcbmNvbnN0IFJlY2VpdmVyID0gcmVxdWlyZSgnLi9yZWNlaXZlcicpO1xuY29uc3QgU2VuZGVyID0gcmVxdWlyZSgnLi9zZW5kZXInKTtcbmNvbnN0IHsgaXNCbG9iIH0gPSByZXF1aXJlKCcuL3ZhbGlkYXRpb24nKTtcblxuY29uc3Qge1xuICBCSU5BUllfVFlQRVMsXG4gIENMT1NFX1RJTUVPVVQsXG4gIEVNUFRZX0JVRkZFUixcbiAgR1VJRCxcbiAga0Zvck9uRXZlbnRBdHRyaWJ1dGUsXG4gIGtMaXN0ZW5lcixcbiAga1N0YXR1c0NvZGUsXG4gIGtXZWJTb2NrZXQsXG4gIE5PT1Bcbn0gPSByZXF1aXJlKCcuL2NvbnN0YW50cycpO1xuY29uc3Qge1xuICBFdmVudFRhcmdldDogeyBhZGRFdmVudExpc3RlbmVyLCByZW1vdmVFdmVudExpc3RlbmVyIH1cbn0gPSByZXF1aXJlKCcuL2V2ZW50LXRhcmdldCcpO1xuY29uc3QgeyBmb3JtYXQsIHBhcnNlIH0gPSByZXF1aXJlKCcuL2V4dGVuc2lvbicpO1xuY29uc3QgeyB0b0J1ZmZlciB9ID0gcmVxdWlyZSgnLi9idWZmZXItdXRpbCcpO1xuXG5jb25zdCBrQWJvcnRlZCA9IFN5bWJvbCgna0Fib3J0ZWQnKTtcbmNvbnN0IHByb3RvY29sVmVyc2lvbnMgPSBbOCwgMTNdO1xuY29uc3QgcmVhZHlTdGF0ZXMgPSBbJ0NPTk5FQ1RJTkcnLCAnT1BFTicsICdDTE9TSU5HJywgJ0NMT1NFRCddO1xuY29uc3Qgc3VicHJvdG9jb2xSZWdleCA9IC9eWyEjJCUmJyorXFwtLjAtOUEtWl5fYHxhLXp+XSskLztcblxuLyoqXG4gKiBDbGFzcyByZXByZXNlbnRpbmcgYSBXZWJTb2NrZXQuXG4gKlxuICogQGV4dGVuZHMgRXZlbnRFbWl0dGVyXG4gKi9cbmNsYXNzIFdlYlNvY2tldCBleHRlbmRzIEV2ZW50RW1pdHRlciB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgYFdlYlNvY2tldGAuXG4gICAqXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xVUkwpfSBhZGRyZXNzIFRoZSBVUkwgdG8gd2hpY2ggdG8gY29ubmVjdFxuICAgKiBAcGFyYW0geyhTdHJpbmd8U3RyaW5nW10pfSBbcHJvdG9jb2xzXSBUaGUgc3VicHJvdG9jb2xzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gQ29ubmVjdGlvbiBvcHRpb25zXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBwcm90b2NvbHMsIG9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdGhpcy5fYmluYXJ5VHlwZSA9IEJJTkFSWV9UWVBFU1swXTtcbiAgICB0aGlzLl9jbG9zZUNvZGUgPSAxMDA2O1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ID0gZmFsc2U7XG4gICAgdGhpcy5fY2xvc2VNZXNzYWdlID0gRU1QVFlfQlVGRkVSO1xuICAgIHRoaXMuX2Nsb3NlVGltZXIgPSBudWxsO1xuICAgIHRoaXMuX2Vycm9yRW1pdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX2V4dGVuc2lvbnMgPSB7fTtcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9wcm90b2NvbCA9ICcnO1xuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ09OTkVDVElORztcbiAgICB0aGlzLl9yZWNlaXZlciA9IG51bGw7XG4gICAgdGhpcy5fc2VuZGVyID0gbnVsbDtcbiAgICB0aGlzLl9zb2NrZXQgPSBudWxsO1xuXG4gICAgaWYgKGFkZHJlc3MgIT09IG51bGwpIHtcbiAgICAgIHRoaXMuX2J1ZmZlcmVkQW1vdW50ID0gMDtcbiAgICAgIHRoaXMuX2lzU2VydmVyID0gZmFsc2U7XG4gICAgICB0aGlzLl9yZWRpcmVjdHMgPSAwO1xuXG4gICAgICBpZiAocHJvdG9jb2xzID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KHByb3RvY29scykpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBwcm90b2NvbHMgPT09ICdvYmplY3QnICYmIHByb3RvY29scyAhPT0gbnVsbCkge1xuICAgICAgICAgIG9wdGlvbnMgPSBwcm90b2NvbHM7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcHJvdG9jb2xzID0gW3Byb3RvY29sc107XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaW5pdEFzQ2xpZW50KHRoaXMsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX2F1dG9Qb25nID0gb3B0aW9ucy5hdXRvUG9uZztcbiAgICAgIHRoaXMuX2Nsb3NlVGltZW91dCA9IG9wdGlvbnMuY2xvc2VUaW1lb3V0O1xuICAgICAgdGhpcy5faXNTZXJ2ZXIgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBGb3IgaGlzdG9yaWNhbCByZWFzb25zLCB0aGUgY3VzdG9tIFwibm9kZWJ1ZmZlclwiIHR5cGUgaXMgdXNlZCBieSB0aGUgZGVmYXVsdFxuICAgKiBpbnN0ZWFkIG9mIFwiYmxvYlwiLlxuICAgKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGJpbmFyeVR5cGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2JpbmFyeVR5cGU7XG4gIH1cblxuICBzZXQgYmluYXJ5VHlwZSh0eXBlKSB7XG4gICAgaWYgKCFCSU5BUllfVFlQRVMuaW5jbHVkZXModHlwZSkpIHJldHVybjtcblxuICAgIHRoaXMuX2JpbmFyeVR5cGUgPSB0eXBlO1xuXG4gICAgLy9cbiAgICAvLyBBbGxvdyB0byBjaGFuZ2UgYGJpbmFyeVR5cGVgIG9uIHRoZSBmbHkuXG4gICAgLy9cbiAgICBpZiAodGhpcy5fcmVjZWl2ZXIpIHRoaXMuX3JlY2VpdmVyLl9iaW5hcnlUeXBlID0gdHlwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IGJ1ZmZlcmVkQW1vdW50KCkge1xuICAgIGlmICghdGhpcy5fc29ja2V0KSByZXR1cm4gdGhpcy5fYnVmZmVyZWRBbW91bnQ7XG5cbiAgICByZXR1cm4gdGhpcy5fc29ja2V0Ll93cml0YWJsZVN0YXRlLmxlbmd0aCArIHRoaXMuX3NlbmRlci5fYnVmZmVyZWRCeXRlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IGV4dGVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX2V4dGVuc2lvbnMpLmpvaW4oKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7Qm9vbGVhbn1cbiAgICovXG4gIGdldCBpc1BhdXNlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmNsb3NlKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbmVycm9yKCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICovXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIGdldCBvbm9wZW4oKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge0Z1bmN0aW9ufVxuICAgKi9cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgZ2V0IG9ubWVzc2FnZSgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7U3RyaW5nfVxuICAgKi9cbiAgZ2V0IHByb3RvY29sKCkge1xuICAgIHJldHVybiB0aGlzLl9wcm90b2NvbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAdHlwZSB7TnVtYmVyfVxuICAgKi9cbiAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3JlYWR5U3RhdGU7XG4gIH1cblxuICAvKipcbiAgICogQHR5cGUge1N0cmluZ31cbiAgICovXG4gIGdldCB1cmwoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VybDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXAgdGhlIHNvY2tldCBhbmQgdGhlIGludGVybmFsIHJlc291cmNlcy5cbiAgICpcbiAgICogQHBhcmFtIHtEdXBsZXh9IHNvY2tldCBUaGUgbmV0d29yayBzb2NrZXQgYmV0d2VlbiB0aGUgc2VydmVyIGFuZCBjbGllbnRcbiAgICogQHBhcmFtIHtCdWZmZXJ9IGhlYWQgVGhlIGZpcnN0IHBhY2tldCBvZiB0aGUgdXBncmFkZWQgc3RyZWFtXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXJcbiAgICogICAgIGFueSBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkXG4gICAqICAgICBtdWx0aXBsZSB0aW1lcyBpbiB0aGUgc2FtZSB0aWNrXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLmdlbmVyYXRlTWFza10gVGhlIGZ1bmN0aW9uIHVzZWQgdG8gZ2VuZXJhdGUgdGhlXG4gICAqICAgICBtYXNraW5nIGtleVxuICAgKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UGF5bG9hZD0wXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2Ugc2l6ZVxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFtvcHRpb25zLnNraXBVVEY4VmFsaWRhdGlvbj1mYWxzZV0gU3BlY2lmaWVzIHdoZXRoZXIgb3JcbiAgICogICAgIG5vdCB0byBza2lwIFVURi04IHZhbGlkYXRpb24gZm9yIHRleHQgYW5kIGNsb3NlIG1lc3NhZ2VzXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRTb2NrZXQoc29ja2V0LCBoZWFkLCBvcHRpb25zKSB7XG4gICAgY29uc3QgcmVjZWl2ZXIgPSBuZXcgUmVjZWl2ZXIoe1xuICAgICAgYWxsb3dTeW5jaHJvbm91c0V2ZW50czogb3B0aW9ucy5hbGxvd1N5bmNocm9ub3VzRXZlbnRzLFxuICAgICAgYmluYXJ5VHlwZTogdGhpcy5iaW5hcnlUeXBlLFxuICAgICAgZXh0ZW5zaW9uczogdGhpcy5fZXh0ZW5zaW9ucyxcbiAgICAgIGlzU2VydmVyOiB0aGlzLl9pc1NlcnZlcixcbiAgICAgIG1heFBheWxvYWQ6IG9wdGlvbnMubWF4UGF5bG9hZCxcbiAgICAgIHNraXBVVEY4VmFsaWRhdGlvbjogb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb25cbiAgICB9KTtcblxuICAgIGNvbnN0IHNlbmRlciA9IG5ldyBTZW5kZXIoc29ja2V0LCB0aGlzLl9leHRlbnNpb25zLCBvcHRpb25zLmdlbmVyYXRlTWFzayk7XG5cbiAgICB0aGlzLl9yZWNlaXZlciA9IHJlY2VpdmVyO1xuICAgIHRoaXMuX3NlbmRlciA9IHNlbmRlcjtcbiAgICB0aGlzLl9zb2NrZXQgPSBzb2NrZXQ7XG5cbiAgICByZWNlaXZlcltrV2ViU29ja2V0XSA9IHRoaXM7XG4gICAgc2VuZGVyW2tXZWJTb2NrZXRdID0gdGhpcztcbiAgICBzb2NrZXRba1dlYlNvY2tldF0gPSB0aGlzO1xuXG4gICAgcmVjZWl2ZXIub24oJ2NvbmNsdWRlJywgcmVjZWl2ZXJPbkNvbmNsdWRlKTtcbiAgICByZWNlaXZlci5vbignZHJhaW4nLCByZWNlaXZlck9uRHJhaW4pO1xuICAgIHJlY2VpdmVyLm9uKCdlcnJvcicsIHJlY2VpdmVyT25FcnJvcik7XG4gICAgcmVjZWl2ZXIub24oJ21lc3NhZ2UnLCByZWNlaXZlck9uTWVzc2FnZSk7XG4gICAgcmVjZWl2ZXIub24oJ3BpbmcnLCByZWNlaXZlck9uUGluZyk7XG4gICAgcmVjZWl2ZXIub24oJ3BvbmcnLCByZWNlaXZlck9uUG9uZyk7XG5cbiAgICBzZW5kZXIub25lcnJvciA9IHNlbmRlck9uRXJyb3I7XG5cbiAgICAvL1xuICAgIC8vIFRoZXNlIG1ldGhvZHMgbWF5IG5vdCBiZSBhdmFpbGFibGUgaWYgYHNvY2tldGAgaXMganVzdCBhIGBEdXBsZXhgLlxuICAgIC8vXG4gICAgaWYgKHNvY2tldC5zZXRUaW1lb3V0KSBzb2NrZXQuc2V0VGltZW91dCgwKTtcbiAgICBpZiAoc29ja2V0LnNldE5vRGVsYXkpIHNvY2tldC5zZXROb0RlbGF5KCk7XG5cbiAgICBpZiAoaGVhZC5sZW5ndGggPiAwKSBzb2NrZXQudW5zaGlmdChoZWFkKTtcblxuICAgIHNvY2tldC5vbignY2xvc2UnLCBzb2NrZXRPbkNsb3NlKTtcbiAgICBzb2NrZXQub24oJ2RhdGEnLCBzb2NrZXRPbkRhdGEpO1xuICAgIHNvY2tldC5vbignZW5kJywgc29ja2V0T25FbmQpO1xuICAgIHNvY2tldC5vbignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuT1BFTjtcbiAgICB0aGlzLmVtaXQoJ29wZW4nKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbWl0IHRoZSBgJ2Nsb3NlJ2AgZXZlbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBlbWl0Q2xvc2UoKSB7XG4gICAgaWYgKCF0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0VEO1xuICAgICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSkge1xuICAgICAgdGhpcy5fZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXS5jbGVhbnVwKCk7XG4gICAgfVxuXG4gICAgdGhpcy5fcmVjZWl2ZXIucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgdGhpcy5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TRUQ7XG4gICAgdGhpcy5lbWl0KCdjbG9zZScsIHRoaXMuX2Nsb3NlQ29kZSwgdGhpcy5fY2xvc2VNZXNzYWdlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTdGFydCBhIGNsb3NpbmcgaGFuZHNoYWtlLlxuICAgKlxuICAgKiAgICAgICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rXG4gICAqICAgICAtIC0gLXx3cy5jbG9zZSgpfC0tPnxjbG9zZSBmcmFtZXwtLT58d3MuY2xvc2UoKXwtIC0gLVxuICAgKiAgICB8ICAgICArLS0tLS0tLS0tLSsgICArLS0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0rICAgICB8XG4gICAqICAgICAgICAgICstLS0tLS0tLS0tKyAgICstLS0tLS0tLS0tLSsgICAgICAgICB8XG4gICAqIENMT1NJTkcgIHx3cy5jbG9zZSgpfDwtLXxjbG9zZSBmcmFtZXw8LS0rLS0tLS0rICAgICAgIENMT1NJTkdcbiAgICogICAgICAgICAgKy0tLS0tLS0tLS0rICAgKy0tLS0tLS0tLS0tKyAgIHxcbiAgICogICAgfCAgICAgICAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tKyAgICAgICAgfFxuICAgKiAgICAgICAgICAgICAgICArLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKy0tPnxmaW58IC0gLSAtIC1cbiAgICogICAgfCAgICAgICAgICstLS0rICAgICAgICAgICAgICAgICAgICAgIHwgICArLS0tK1xuICAgKiAgICAgLSAtIC0gLSAtfGZpbnw8LS0tLS0tLS0tLS0tLS0tLS0tLS0tK1xuICAgKiAgICAgICAgICAgICAgKy0tLStcbiAgICpcbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtjb2RlXSBTdGF0dXMgY29kZSBleHBsYWluaW5nIHdoeSB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nXG4gICAqIEBwYXJhbSB7KFN0cmluZ3xCdWZmZXIpfSBbZGF0YV0gVGhlIHJlYXNvbiB3aHkgdGhlIGNvbm5lY3Rpb24gaXNcbiAgICogICAgIGNsb3NpbmdcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgY2xvc2UoY29kZSwgZGF0YSkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TSU5HKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRoaXMuX2Nsb3NlRnJhbWVTZW50ICYmXG4gICAgICAgICh0aGlzLl9jbG9zZUZyYW1lUmVjZWl2ZWQgfHwgdGhpcy5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKVxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICB0aGlzLl9zZW5kZXIuY2xvc2UoY29kZSwgZGF0YSwgIXRoaXMuX2lzU2VydmVyLCAoZXJyKSA9PiB7XG4gICAgICAvL1xuICAgICAgLy8gVGhpcyBlcnJvciBpcyBoYW5kbGVkIGJ5IHRoZSBgJ2Vycm9yJ2AgbGlzdGVuZXIgb24gdGhlIHNvY2tldC4gV2Ugb25seVxuICAgICAgLy8gd2FudCB0byBrbm93IGlmIHRoZSBjbG9zZSBmcmFtZSBoYXMgYmVlbiBzZW50IGhlcmUuXG4gICAgICAvL1xuICAgICAgaWYgKGVycikgcmV0dXJuO1xuXG4gICAgICB0aGlzLl9jbG9zZUZyYW1lU2VudCA9IHRydWU7XG5cbiAgICAgIGlmIChcbiAgICAgICAgdGhpcy5fY2xvc2VGcmFtZVJlY2VpdmVkIHx8XG4gICAgICAgIHRoaXMuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICAgICAgKSB7XG4gICAgICAgIHRoaXMuX3NvY2tldC5lbmQoKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIHNldENsb3NlVGltZXIodGhpcyk7XG4gIH1cblxuICAvKipcbiAgICogUGF1c2UgdGhlIHNvY2tldC5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGF1c2UoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcbiAgICB0aGlzLl9zb2NrZXQucGF1c2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgcGluZy5cbiAgICpcbiAgICogQHBhcmFtIHsqfSBbZGF0YV0gVGhlIGRhdGEgdG8gc2VuZFxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IFttYXNrXSBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdG8gbWFzayBgZGF0YWBcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NiXSBDYWxsYmFjayB3aGljaCBpcyBleGVjdXRlZCB3aGVuIHRoZSBwaW5nIGlzIHNlbnRcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgcGluZyhkYXRhLCBtYXNrLCBjYikge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DT05ORUNUSU5HKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1dlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAwIChDT05ORUNUSU5HKScpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBkYXRhO1xuICAgICAgZGF0YSA9IG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbWFzayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY2IgPSBtYXNrO1xuICAgICAgbWFzayA9IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAobWFzayA9PT0gdW5kZWZpbmVkKSBtYXNrID0gIXRoaXMuX2lzU2VydmVyO1xuICAgIHRoaXMuX3NlbmRlci5waW5nKGRhdGEgfHwgRU1QVFlfQlVGRkVSLCBtYXNrLCBjYik7XG4gIH1cblxuICAvKipcbiAgICogU2VuZCBhIHBvbmcuXG4gICAqXG4gICAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAgICogQHBhcmFtIHtCb29sZWFufSBbbWFza10gSW5kaWNhdGVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiB0aGUgcG9uZyBpcyBzZW50XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHBvbmcoZGF0YSwgbWFzaywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gZGF0YTtcbiAgICAgIGRhdGEgPSBtYXNrID0gdW5kZWZpbmVkO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hc2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gbWFzaztcbiAgICAgIG1hc2sgPSB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnbnVtYmVyJykgZGF0YSA9IGRhdGEudG9TdHJpbmcoKTtcblxuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgIT09IFdlYlNvY2tldC5PUEVOKSB7XG4gICAgICBzZW5kQWZ0ZXJDbG9zZSh0aGlzLCBkYXRhLCBjYik7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKG1hc2sgPT09IHVuZGVmaW5lZCkgbWFzayA9ICF0aGlzLl9pc1NlcnZlcjtcbiAgICB0aGlzLl9zZW5kZXIucG9uZyhkYXRhIHx8IEVNUFRZX0JVRkZFUiwgbWFzaywgY2IpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc3VtZSB0aGUgc29ja2V0LlxuICAgKlxuICAgKiBAcHVibGljXG4gICAqL1xuICByZXN1bWUoKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORyB8fFxuICAgICAgdGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ0xPU0VEXG4gICAgKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLl9yZWNlaXZlci5fd3JpdGFibGVTdGF0ZS5uZWVkRHJhaW4pIHRoaXMuX3NvY2tldC5yZXN1bWUoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZW5kIGEgZGF0YSBtZXNzYWdlLlxuICAgKlxuICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1lc3NhZ2UgdG8gc2VuZFxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIE9wdGlvbnMgb2JqZWN0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYmluYXJ5XSBTcGVjaWZpZXMgd2hldGhlciBgZGF0YWAgaXMgYmluYXJ5IG9yXG4gICAqICAgICB0ZXh0XG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuY29tcHJlc3NdIFNwZWNpZmllcyB3aGV0aGVyIG9yIG5vdCB0byBjb21wcmVzc1xuICAgKiAgICAgYGRhdGFgXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuZmluPXRydWVdIFNwZWNpZmllcyB3aGV0aGVyIHRoZSBmcmFnbWVudCBpcyB0aGVcbiAgICogICAgIGxhc3Qgb25lXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMubWFza10gU3BlY2lmaWVzIHdoZXRoZXIgb3Igbm90IHRvIG1hc2sgYGRhdGFgXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2sgd2hpY2ggaXMgZXhlY3V0ZWQgd2hlbiBkYXRhIGlzIHdyaXR0ZW4gb3V0XG4gICAqIEBwdWJsaWNcbiAgICovXG4gIHNlbmQoZGF0YSwgb3B0aW9ucywgY2IpIHtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdXZWJTb2NrZXQgaXMgbm90IG9wZW46IHJlYWR5U3RhdGUgMCAoQ09OTkVDVElORyknKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNiID0gb3B0aW9ucztcbiAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdudW1iZXInKSBkYXRhID0gZGF0YS50b1N0cmluZygpO1xuXG4gICAgaWYgKHRoaXMucmVhZHlTdGF0ZSAhPT0gV2ViU29ja2V0Lk9QRU4pIHtcbiAgICAgIHNlbmRBZnRlckNsb3NlKHRoaXMsIGRhdGEsIGNiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBvcHRzID0ge1xuICAgICAgYmluYXJ5OiB0eXBlb2YgZGF0YSAhPT0gJ3N0cmluZycsXG4gICAgICBtYXNrOiAhdGhpcy5faXNTZXJ2ZXIsXG4gICAgICBjb21wcmVzczogdHJ1ZSxcbiAgICAgIGZpbjogdHJ1ZSxcbiAgICAgIC4uLm9wdGlvbnNcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLl9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdKSB7XG4gICAgICBvcHRzLmNvbXByZXNzID0gZmFsc2U7XG4gICAgfVxuXG4gICAgdGhpcy5fc2VuZGVyLnNlbmQoZGF0YSB8fCBFTVBUWV9CVUZGRVIsIG9wdHMsIGNiKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBGb3JjaWJseSBjbG9zZSB0aGUgY29ubmVjdGlvbi5cbiAgICpcbiAgICogQHB1YmxpY1xuICAgKi9cbiAgdGVybWluYXRlKCkge1xuICAgIGlmICh0aGlzLnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgICBpZiAodGhpcy5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuQ09OTkVDVElORykge1xuICAgICAgY29uc3QgbXNnID0gJ1dlYlNvY2tldCB3YXMgY2xvc2VkIGJlZm9yZSB0aGUgY29ubmVjdGlvbiB3YXMgZXN0YWJsaXNoZWQnO1xuICAgICAgYWJvcnRIYW5kc2hha2UodGhpcywgdGhpcy5fcmVxLCBtc2cpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9zb2NrZXQpIHtcbiAgICAgIHRoaXMuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgICAgIHRoaXMuX3NvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENPTk5FQ1RJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXRcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldCwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDT05ORUNUSU5HXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0LnByb3RvdHlwZVxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LnByb3RvdHlwZSwgJ0NPTk5FQ1RJTkcnLCB7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIHZhbHVlOiByZWFkeVN0YXRlcy5pbmRleE9mKCdDT05ORUNUSU5HJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBPUEVOXG4gKiBAbWVtYmVyb2YgV2ViU29ja2V0XG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gT1BFTlxuICogQG1lbWJlcm9mIFdlYlNvY2tldC5wcm90b3R5cGVcbiAqL1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdlYlNvY2tldC5wcm90b3R5cGUsICdPUEVOJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignT1BFTicpXG59KTtcblxuLyoqXG4gKiBAY29uc3RhbnQge051bWJlcn0gQ0xPU0lOR1xuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NJTkdcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0lORycsIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdmFsdWU6IHJlYWR5U3RhdGVzLmluZGV4T2YoJ0NMT1NJTkcnKVxufSk7XG5cbi8qKlxuICogQGNvbnN0YW50IHtOdW1iZXJ9IENMT1NFRFxuICogQG1lbWJlcm9mIFdlYlNvY2tldFxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoV2ViU29ja2V0LCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG4vKipcbiAqIEBjb25zdGFudCB7TnVtYmVyfSBDTE9TRURcbiAqIEBtZW1iZXJvZiBXZWJTb2NrZXQucHJvdG90eXBlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCAnQ0xPU0VEJywge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogcmVhZHlTdGF0ZXMuaW5kZXhPZignQ0xPU0VEJylcbn0pO1xuXG5bXG4gICdiaW5hcnlUeXBlJyxcbiAgJ2J1ZmZlcmVkQW1vdW50JyxcbiAgJ2V4dGVuc2lvbnMnLFxuICAnaXNQYXVzZWQnLFxuICAncHJvdG9jb2wnLFxuICAncmVhZHlTdGF0ZScsXG4gICd1cmwnXG5dLmZvckVhY2goKHByb3BlcnR5KSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBwcm9wZXJ0eSwgeyBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufSk7XG5cbi8vXG4vLyBBZGQgdGhlIGBvbm9wZW5gLCBgb25lcnJvcmAsIGBvbmNsb3NlYCwgYW5kIGBvbm1lc3NhZ2VgIGF0dHJpYnV0ZXMuXG4vLyBTZWUgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvY29tbXMuaHRtbCN0aGUtd2Vic29ja2V0LWludGVyZmFjZVxuLy9cblsnb3BlbicsICdlcnJvcicsICdjbG9zZScsICdtZXNzYWdlJ10uZm9yRWFjaCgobWV0aG9kKSA9PiB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXZWJTb2NrZXQucHJvdG90eXBlLCBgb24ke21ldGhvZH1gLCB7XG4gICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICBnZXQoKSB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMubGlzdGVuZXJzKG1ldGhvZCkpIHtcbiAgICAgICAgaWYgKGxpc3RlbmVyW2tGb3JPbkV2ZW50QXR0cmlidXRlXSkgcmV0dXJuIGxpc3RlbmVyW2tMaXN0ZW5lcl07XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgc2V0KGhhbmRsZXIpIHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5saXN0ZW5lcnMobWV0aG9kKSkge1xuICAgICAgICBpZiAobGlzdGVuZXJba0Zvck9uRXZlbnRBdHRyaWJ1dGVdKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihtZXRob2QsIGxpc3RlbmVyKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGhhbmRsZXIgIT09ICdmdW5jdGlvbicpIHJldHVybjtcblxuICAgICAgdGhpcy5hZGRFdmVudExpc3RlbmVyKG1ldGhvZCwgaGFuZGxlciwge1xuICAgICAgICBba0Zvck9uRXZlbnRBdHRyaWJ1dGVdOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufSk7XG5cbldlYlNvY2tldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGFkZEV2ZW50TGlzdGVuZXI7XG5XZWJTb2NrZXQucHJvdG90eXBlLnJlbW92ZUV2ZW50TGlzdGVuZXIgPSByZW1vdmVFdmVudExpc3RlbmVyO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdlYlNvY2tldDtcblxuLyoqXG4gKiBJbml0aWFsaXplIGEgV2ViU29ja2V0IGNsaWVudC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBjbGllbnQgdG8gaW5pdGlhbGl6ZVxuICogQHBhcmFtIHsoU3RyaW5nfFVSTCl9IGFkZHJlc3MgVGhlIFVSTCB0byB3aGljaCB0byBjb25uZWN0XG4gKiBAcGFyYW0ge0FycmF5fSBwcm90b2NvbHMgVGhlIHN1YnByb3RvY29sc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gW29wdGlvbnMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBhbnlcbiAqICAgICBvZiB0aGUgYCdtZXNzYWdlJ2AsIGAncGluZydgLCBhbmQgYCdwb25nJ2AgZXZlbnRzIGNhbiBiZSBlbWl0dGVkIG11bHRpcGxlXG4gKiAgICAgdGltZXMgaW4gdGhlIHNhbWUgdGlja1xuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5hdXRvUG9uZz10cnVlXSBTcGVjaWZpZXMgd2hldGhlciBvciBub3QgdG9cbiAqICAgICBhdXRvbWF0aWNhbGx5IHNlbmQgYSBwb25nIGluIHJlc3BvbnNlIHRvIGEgcGluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmNsb3NlVGltZW91dD0zMDAwMF0gRHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzIHRvIHdhaXRcbiAqICAgICBmb3IgdGhlIGNsb3NpbmcgaGFuZHNoYWtlIHRvIGZpbmlzaCBhZnRlciBgd2Vic29ja2V0LmNsb3NlKClgIGlzIGNhbGxlZFxuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZmluaXNoUmVxdWVzdF0gQSBmdW5jdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB0b1xuICogICAgIGN1c3RvbWl6ZSB0aGUgaGVhZGVycyBvZiBlYWNoIGh0dHAgcmVxdWVzdCBiZWZvcmUgaXQgaXMgc2VudFxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5mb2xsb3dSZWRpcmVjdHM9ZmFsc2VdIFdoZXRoZXIgb3Igbm90IHRvIGZvbGxvd1xuICogICAgIHJlZGlyZWN0c1xuICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdGlvbnMuZ2VuZXJhdGVNYXNrXSBUaGUgZnVuY3Rpb24gdXNlZCB0byBnZW5lcmF0ZSB0aGVcbiAqICAgICBtYXNraW5nIGtleVxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLmhhbmRzaGFrZVRpbWVvdXRdIFRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzIGZvciB0aGVcbiAqICAgICBoYW5kc2hha2UgcmVxdWVzdFxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heFBheWxvYWQ9MTA0ODU3NjAwXSBUaGUgbWF4aW11bSBhbGxvd2VkIG1lc3NhZ2VcbiAqICAgICBzaXplXG4gKiBAcGFyYW0ge051bWJlcn0gW29wdGlvbnMubWF4UmVkaXJlY3RzPTEwXSBUaGUgbWF4aW11bSBudW1iZXIgb2YgcmVkaXJlY3RzXG4gKiAgICAgYWxsb3dlZFxuICogQHBhcmFtIHtTdHJpbmd9IFtvcHRpb25zLm9yaWdpbl0gVmFsdWUgb2YgdGhlIGBPcmlnaW5gIG9yXG4gKiAgICAgYFNlYy1XZWJTb2NrZXQtT3JpZ2luYCBoZWFkZXJcbiAqIEBwYXJhbSB7KEJvb2xlYW58T2JqZWN0KX0gW29wdGlvbnMucGVyTWVzc2FnZURlZmxhdGU9dHJ1ZV0gRW5hYmxlL2Rpc2FibGVcbiAqICAgICBwZXJtZXNzYWdlLWRlZmxhdGVcbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5wcm90b2NvbFZlcnNpb249MTNdIFZhbHVlIG9mIHRoZVxuICogICAgIGBTZWMtV2ViU29ja2V0LVZlcnNpb25gIGhlYWRlclxuICogQHBhcmFtIHtCb29sZWFufSBbb3B0aW9ucy5za2lwVVRGOFZhbGlkYXRpb249ZmFsc2VdIFNwZWNpZmllcyB3aGV0aGVyIG9yXG4gKiAgICAgbm90IHRvIHNraXAgVVRGLTggdmFsaWRhdGlvbiBmb3IgdGV4dCBhbmQgY2xvc2UgbWVzc2FnZXNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIGluaXRBc0NsaWVudCh3ZWJzb2NrZXQsIGFkZHJlc3MsIHByb3RvY29scywgb3B0aW9ucykge1xuICBjb25zdCBvcHRzID0ge1xuICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IHRydWUsXG4gICAgYXV0b1Bvbmc6IHRydWUsXG4gICAgY2xvc2VUaW1lb3V0OiBDTE9TRV9USU1FT1VULFxuICAgIHByb3RvY29sVmVyc2lvbjogcHJvdG9jb2xWZXJzaW9uc1sxXSxcbiAgICBtYXhQYXlsb2FkOiAxMDAgKiAxMDI0ICogMTAyNCxcbiAgICBza2lwVVRGOFZhbGlkYXRpb246IGZhbHNlLFxuICAgIHBlck1lc3NhZ2VEZWZsYXRlOiB0cnVlLFxuICAgIGZvbGxvd1JlZGlyZWN0czogZmFsc2UsXG4gICAgbWF4UmVkaXJlY3RzOiAxMCxcbiAgICAuLi5vcHRpb25zLFxuICAgIHNvY2tldFBhdGg6IHVuZGVmaW5lZCxcbiAgICBob3N0bmFtZTogdW5kZWZpbmVkLFxuICAgIHByb3RvY29sOiB1bmRlZmluZWQsXG4gICAgdGltZW91dDogdW5kZWZpbmVkLFxuICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgaG9zdDogdW5kZWZpbmVkLFxuICAgIHBhdGg6IHVuZGVmaW5lZCxcbiAgICBwb3J0OiB1bmRlZmluZWRcbiAgfTtcblxuICB3ZWJzb2NrZXQuX2F1dG9Qb25nID0gb3B0cy5hdXRvUG9uZztcbiAgd2Vic29ja2V0Ll9jbG9zZVRpbWVvdXQgPSBvcHRzLmNsb3NlVGltZW91dDtcblxuICBpZiAoIXByb3RvY29sVmVyc2lvbnMuaW5jbHVkZXMob3B0cy5wcm90b2NvbFZlcnNpb24pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXG4gICAgICBgVW5zdXBwb3J0ZWQgcHJvdG9jb2wgdmVyc2lvbjogJHtvcHRzLnByb3RvY29sVmVyc2lvbn0gYCArXG4gICAgICAgIGAoc3VwcG9ydGVkIHZlcnNpb25zOiAke3Byb3RvY29sVmVyc2lvbnMuam9pbignLCAnKX0pYFxuICAgICk7XG4gIH1cblxuICBsZXQgcGFyc2VkVXJsO1xuXG4gIGlmIChhZGRyZXNzIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcGFyc2VkVXJsID0gYWRkcmVzcztcbiAgfSBlbHNlIHtcbiAgICB0cnkge1xuICAgICAgcGFyc2VkVXJsID0gbmV3IFVSTChhZGRyZXNzKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoYEludmFsaWQgVVJMOiAke2FkZHJlc3N9YCk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHA6Jykge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9ICd3czonO1xuICB9IGVsc2UgaWYgKHBhcnNlZFVybC5wcm90b2NvbCA9PT0gJ2h0dHBzOicpIHtcbiAgICBwYXJzZWRVcmwucHJvdG9jb2wgPSAnd3NzOic7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3VybCA9IHBhcnNlZFVybC5ocmVmO1xuXG4gIGNvbnN0IGlzU2VjdXJlID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3NzOic7XG4gIGNvbnN0IGlzSXBjVXJsID0gcGFyc2VkVXJsLnByb3RvY29sID09PSAnd3MrdW5peDonO1xuICBsZXQgaW52YWxpZFVybE1lc3NhZ2U7XG5cbiAgaWYgKHBhcnNlZFVybC5wcm90b2NvbCAhPT0gJ3dzOicgJiYgIWlzU2VjdXJlICYmICFpc0lwY1VybCkge1xuICAgIGludmFsaWRVcmxNZXNzYWdlID1cbiAgICAgICdUaGUgVVJMXFwncyBwcm90b2NvbCBtdXN0IGJlIG9uZSBvZiBcIndzOlwiLCBcIndzczpcIiwgJyArXG4gICAgICAnXCJodHRwOlwiLCBcImh0dHBzOlwiLCBvciBcIndzK3VuaXg6XCInO1xuICB9IGVsc2UgaWYgKGlzSXBjVXJsICYmICFwYXJzZWRVcmwucGF0aG5hbWUpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9IFwiVGhlIFVSTCdzIHBhdGhuYW1lIGlzIGVtcHR5XCI7XG4gIH0gZWxzZSBpZiAocGFyc2VkVXJsLmhhc2gpIHtcbiAgICBpbnZhbGlkVXJsTWVzc2FnZSA9ICdUaGUgVVJMIGNvbnRhaW5zIGEgZnJhZ21lbnQgaWRlbnRpZmllcic7XG4gIH1cblxuICBpZiAoaW52YWxpZFVybE1lc3NhZ2UpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgU3ludGF4RXJyb3IoaW52YWxpZFVybE1lc3NhZ2UpO1xuXG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cblxuICBjb25zdCBkZWZhdWx0UG9ydCA9IGlzU2VjdXJlID8gNDQzIDogODA7XG4gIGNvbnN0IGtleSA9IHJhbmRvbUJ5dGVzKDE2KS50b1N0cmluZygnYmFzZTY0Jyk7XG4gIGNvbnN0IHJlcXVlc3QgPSBpc1NlY3VyZSA/IGh0dHBzLnJlcXVlc3QgOiBodHRwLnJlcXVlc3Q7XG4gIGNvbnN0IHByb3RvY29sU2V0ID0gbmV3IFNldCgpO1xuICBsZXQgcGVyTWVzc2FnZURlZmxhdGU7XG5cbiAgb3B0cy5jcmVhdGVDb25uZWN0aW9uID1cbiAgICBvcHRzLmNyZWF0ZUNvbm5lY3Rpb24gfHwgKGlzU2VjdXJlID8gdGxzQ29ubmVjdCA6IG5ldENvbm5lY3QpO1xuICBvcHRzLmRlZmF1bHRQb3J0ID0gb3B0cy5kZWZhdWx0UG9ydCB8fCBkZWZhdWx0UG9ydDtcbiAgb3B0cy5wb3J0ID0gcGFyc2VkVXJsLnBvcnQgfHwgZGVmYXVsdFBvcnQ7XG4gIG9wdHMuaG9zdCA9IHBhcnNlZFVybC5ob3N0bmFtZS5zdGFydHNXaXRoKCdbJylcbiAgICA/IHBhcnNlZFVybC5ob3N0bmFtZS5zbGljZSgxLCAtMSlcbiAgICA6IHBhcnNlZFVybC5ob3N0bmFtZTtcbiAgb3B0cy5oZWFkZXJzID0ge1xuICAgIC4uLm9wdHMuaGVhZGVycyxcbiAgICAnU2VjLVdlYlNvY2tldC1WZXJzaW9uJzogb3B0cy5wcm90b2NvbFZlcnNpb24sXG4gICAgJ1NlYy1XZWJTb2NrZXQtS2V5Jzoga2V5LFxuICAgIENvbm5lY3Rpb246ICdVcGdyYWRlJyxcbiAgICBVcGdyYWRlOiAnd2Vic29ja2V0J1xuICB9O1xuICBvcHRzLnBhdGggPSBwYXJzZWRVcmwucGF0aG5hbWUgKyBwYXJzZWRVcmwuc2VhcmNoO1xuICBvcHRzLnRpbWVvdXQgPSBvcHRzLmhhbmRzaGFrZVRpbWVvdXQ7XG5cbiAgaWYgKG9wdHMucGVyTWVzc2FnZURlZmxhdGUpIHtcbiAgICBwZXJNZXNzYWdlRGVmbGF0ZSA9IG5ldyBQZXJNZXNzYWdlRGVmbGF0ZShcbiAgICAgIG9wdHMucGVyTWVzc2FnZURlZmxhdGUgIT09IHRydWUgPyBvcHRzLnBlck1lc3NhZ2VEZWZsYXRlIDoge30sXG4gICAgICBmYWxzZSxcbiAgICAgIG9wdHMubWF4UGF5bG9hZFxuICAgICk7XG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMnXSA9IGZvcm1hdCh7XG4gICAgICBbUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZV06IHBlck1lc3NhZ2VEZWZsYXRlLm9mZmVyKClcbiAgICB9KTtcbiAgfVxuICBpZiAocHJvdG9jb2xzLmxlbmd0aCkge1xuICAgIGZvciAoY29uc3QgcHJvdG9jb2wgb2YgcHJvdG9jb2xzKSB7XG4gICAgICBpZiAoXG4gICAgICAgIHR5cGVvZiBwcm90b2NvbCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgIXN1YnByb3RvY29sUmVnZXgudGVzdChwcm90b2NvbCkgfHxcbiAgICAgICAgcHJvdG9jb2xTZXQuaGFzKHByb3RvY29sKVxuICAgICAgKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICAnQW4gaW52YWxpZCBvciBkdXBsaWNhdGVkIHN1YnByb3RvY29sIHdhcyBzcGVjaWZpZWQnXG4gICAgICAgICk7XG4gICAgICB9XG5cbiAgICAgIHByb3RvY29sU2V0LmFkZChwcm90b2NvbCk7XG4gICAgfVxuXG4gICAgb3B0cy5oZWFkZXJzWydTZWMtV2ViU29ja2V0LVByb3RvY29sJ10gPSBwcm90b2NvbHMuam9pbignLCcpO1xuICB9XG4gIGlmIChvcHRzLm9yaWdpbikge1xuICAgIGlmIChvcHRzLnByb3RvY29sVmVyc2lvbiA8IDEzKSB7XG4gICAgICBvcHRzLmhlYWRlcnNbJ1NlYy1XZWJTb2NrZXQtT3JpZ2luJ10gPSBvcHRzLm9yaWdpbjtcbiAgICB9IGVsc2Uge1xuICAgICAgb3B0cy5oZWFkZXJzLk9yaWdpbiA9IG9wdHMub3JpZ2luO1xuICAgIH1cbiAgfVxuICBpZiAocGFyc2VkVXJsLnVzZXJuYW1lIHx8IHBhcnNlZFVybC5wYXNzd29yZCkge1xuICAgIG9wdHMuYXV0aCA9IGAke3BhcnNlZFVybC51c2VybmFtZX06JHtwYXJzZWRVcmwucGFzc3dvcmR9YDtcbiAgfVxuXG4gIGlmIChpc0lwY1VybCkge1xuICAgIGNvbnN0IHBhcnRzID0gb3B0cy5wYXRoLnNwbGl0KCc6Jyk7XG5cbiAgICBvcHRzLnNvY2tldFBhdGggPSBwYXJ0c1swXTtcbiAgICBvcHRzLnBhdGggPSBwYXJ0c1sxXTtcbiAgfVxuXG4gIGxldCByZXE7XG5cbiAgaWYgKG9wdHMuZm9sbG93UmVkaXJlY3RzKSB7XG4gICAgaWYgKHdlYnNvY2tldC5fcmVkaXJlY3RzID09PSAwKSB7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjID0gaXNJcGNVcmw7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsU2VjdXJlID0gaXNTZWN1cmU7XG4gICAgICB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aCA9IGlzSXBjVXJsXG4gICAgICAgID8gb3B0cy5zb2NrZXRQYXRoXG4gICAgICAgIDogcGFyc2VkVXJsLmhvc3Q7XG5cbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBvcHRpb25zICYmIG9wdGlvbnMuaGVhZGVycztcblxuICAgICAgLy9cbiAgICAgIC8vIFNoYWxsb3cgY29weSB0aGUgdXNlciBwcm92aWRlZCBvcHRpb25zIHNvIHRoYXQgaGVhZGVycyBjYW4gYmUgY2hhbmdlZFxuICAgICAgLy8gd2l0aG91dCBtdXRhdGluZyB0aGUgb3JpZ2luYWwgb2JqZWN0LlxuICAgICAgLy9cbiAgICAgIG9wdGlvbnMgPSB7IC4uLm9wdGlvbnMsIGhlYWRlcnM6IHt9IH07XG5cbiAgICAgIGlmIChoZWFkZXJzKSB7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGhlYWRlcnMpKSB7XG4gICAgICAgICAgb3B0aW9ucy5oZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh3ZWJzb2NrZXQubGlzdGVuZXJDb3VudCgncmVkaXJlY3QnKSA9PT0gMCkge1xuICAgICAgY29uc3QgaXNTYW1lSG9zdCA9IGlzSXBjVXJsXG4gICAgICAgID8gd2Vic29ja2V0Ll9vcmlnaW5hbElwY1xuICAgICAgICAgID8gb3B0cy5zb2NrZXRQYXRoID09PSB3ZWJzb2NrZXQuX29yaWdpbmFsSG9zdE9yU29ja2V0UGF0aFxuICAgICAgICAgIDogZmFsc2VcbiAgICAgICAgOiB3ZWJzb2NrZXQuX29yaWdpbmFsSXBjXG4gICAgICAgICAgPyBmYWxzZVxuICAgICAgICAgIDogcGFyc2VkVXJsLmhvc3QgPT09IHdlYnNvY2tldC5fb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoO1xuXG4gICAgICBpZiAoIWlzU2FtZUhvc3QgfHwgKHdlYnNvY2tldC5fb3JpZ2luYWxTZWN1cmUgJiYgIWlzU2VjdXJlKSkge1xuICAgICAgICAvL1xuICAgICAgICAvLyBNYXRjaCBjdXJsIDcuNzcuMCBiZWhhdmlvciBhbmQgZHJvcCB0aGUgZm9sbG93aW5nIGhlYWRlcnMuIFRoZXNlXG4gICAgICAgIC8vIGhlYWRlcnMgYXJlIGFsc28gZHJvcHBlZCB3aGVuIGZvbGxvd2luZyBhIHJlZGlyZWN0IHRvIGEgc3ViZG9tYWluLlxuICAgICAgICAvL1xuICAgICAgICBkZWxldGUgb3B0cy5oZWFkZXJzLmF1dGhvcml6YXRpb247XG4gICAgICAgIGRlbGV0ZSBvcHRzLmhlYWRlcnMuY29va2llO1xuXG4gICAgICAgIGlmICghaXNTYW1lSG9zdCkgZGVsZXRlIG9wdHMuaGVhZGVycy5ob3N0O1xuXG4gICAgICAgIG9wdHMuYXV0aCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvL1xuICAgIC8vIE1hdGNoIGN1cmwgNy43Ny4wIGJlaGF2aW9yIGFuZCBtYWtlIHRoZSBmaXJzdCBgQXV0aG9yaXphdGlvbmAgaGVhZGVyIHdpbi5cbiAgICAvLyBJZiB0aGUgYEF1dGhvcml6YXRpb25gIGhlYWRlciBpcyBzZXQsIHRoZW4gdGhlcmUgaXMgbm90aGluZyB0byBkbyBhcyBpdFxuICAgIC8vIHdpbGwgdGFrZSBwcmVjZWRlbmNlLlxuICAgIC8vXG4gICAgaWYgKG9wdHMuYXV0aCAmJiAhb3B0aW9ucy5oZWFkZXJzLmF1dGhvcml6YXRpb24pIHtcbiAgICAgIG9wdGlvbnMuaGVhZGVycy5hdXRob3JpemF0aW9uID1cbiAgICAgICAgJ0Jhc2ljICcgKyBCdWZmZXIuZnJvbShvcHRzLmF1dGgpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgICB9XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IHJlcXVlc3Qob3B0cyk7XG5cbiAgICBpZiAod2Vic29ja2V0Ll9yZWRpcmVjdHMpIHtcbiAgICAgIC8vXG4gICAgICAvLyBVbmxpa2Ugd2hhdCBpcyBkb25lIGZvciB0aGUgYCd1cGdyYWRlJ2AgZXZlbnQsIG5vIGVhcmx5IGV4aXQgaXNcbiAgICAgIC8vIHRyaWdnZXJlZCBoZXJlIGlmIHRoZSB1c2VyIGNhbGxzIGB3ZWJzb2NrZXQuY2xvc2UoKWAgb3JcbiAgICAgIC8vIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGZyb20gYSBsaXN0ZW5lciBvZiB0aGUgYCdyZWRpcmVjdCdgIGV2ZW50LiBUaGlzXG4gICAgICAvLyBpcyBiZWNhdXNlIHRoZSB1c2VyIGNhbiBhbHNvIGNhbGwgYHJlcXVlc3QuZGVzdHJveSgpYCB3aXRoIGFuIGVycm9yXG4gICAgICAvLyBiZWZvcmUgY2FsbGluZyBgd2Vic29ja2V0LmNsb3NlKClgIG9yIGB3ZWJzb2NrZXQudGVybWluYXRlKClgIGFuZCB0aGlzXG4gICAgICAvLyB3b3VsZCByZXN1bHQgaW4gYW4gZXJyb3IgYmVpbmcgZW1pdHRlZCBvbiB0aGUgYHJlcXVlc3RgIG9iamVjdCB3aXRoIG5vXG4gICAgICAvLyBgJ2Vycm9yJ2AgZXZlbnQgbGlzdGVuZXJzIGF0dGFjaGVkLlxuICAgICAgLy9cbiAgICAgIHdlYnNvY2tldC5lbWl0KCdyZWRpcmVjdCcsIHdlYnNvY2tldC51cmwsIHJlcSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJlcSA9IHdlYnNvY2tldC5fcmVxID0gcmVxdWVzdChvcHRzKTtcbiAgfVxuXG4gIGlmIChvcHRzLnRpbWVvdXQpIHtcbiAgICByZXEub24oJ3RpbWVvdXQnLCAoKSA9PiB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ09wZW5pbmcgaGFuZHNoYWtlIGhhcyB0aW1lZCBvdXQnKTtcbiAgICB9KTtcbiAgfVxuXG4gIHJlcS5vbignZXJyb3InLCAoZXJyKSA9PiB7XG4gICAgaWYgKHJlcSA9PT0gbnVsbCB8fCByZXFba0Fib3J0ZWRdKSByZXR1cm47XG5cbiAgICByZXEgPSB3ZWJzb2NrZXQuX3JlcSA9IG51bGw7XG4gICAgZW1pdEVycm9yQW5kQ2xvc2Uod2Vic29ja2V0LCBlcnIpO1xuICB9KTtcblxuICByZXEub24oJ3Jlc3BvbnNlJywgKHJlcykgPT4ge1xuICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzLmhlYWRlcnMubG9jYXRpb247XG4gICAgY29uc3Qgc3RhdHVzQ29kZSA9IHJlcy5zdGF0dXNDb2RlO1xuXG4gICAgaWYgKFxuICAgICAgbG9jYXRpb24gJiZcbiAgICAgIG9wdHMuZm9sbG93UmVkaXJlY3RzICYmXG4gICAgICBzdGF0dXNDb2RlID49IDMwMCAmJlxuICAgICAgc3RhdHVzQ29kZSA8IDQwMFxuICAgICkge1xuICAgICAgaWYgKCsrd2Vic29ja2V0Ll9yZWRpcmVjdHMgPiBvcHRzLm1heFJlZGlyZWN0cykge1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHJlcSwgJ01heGltdW0gcmVkaXJlY3RzIGV4Y2VlZGVkJyk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgcmVxLmFib3J0KCk7XG5cbiAgICAgIGxldCBhZGRyO1xuXG4gICAgICB0cnkge1xuICAgICAgICBhZGRyID0gbmV3IFVSTChsb2NhdGlvbiwgYWRkcmVzcyk7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVyciA9IG5ldyBTeW50YXhFcnJvcihgSW52YWxpZCBVUkw6ICR7bG9jYXRpb259YCk7XG4gICAgICAgIGVtaXRFcnJvckFuZENsb3NlKHdlYnNvY2tldCwgZXJyKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpbml0QXNDbGllbnQod2Vic29ja2V0LCBhZGRyLCBwcm90b2NvbHMsIG9wdGlvbnMpO1xuICAgIH0gZWxzZSBpZiAoIXdlYnNvY2tldC5lbWl0KCd1bmV4cGVjdGVkLXJlc3BvbnNlJywgcmVxLCByZXMpKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZShcbiAgICAgICAgd2Vic29ja2V0LFxuICAgICAgICByZXEsXG4gICAgICAgIGBVbmV4cGVjdGVkIHNlcnZlciByZXNwb25zZTogJHtyZXMuc3RhdHVzQ29kZX1gXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgcmVxLm9uKCd1cGdyYWRlJywgKHJlcywgc29ja2V0LCBoZWFkKSA9PiB7XG4gICAgd2Vic29ja2V0LmVtaXQoJ3VwZ3JhZGUnLCByZXMpO1xuXG4gICAgLy9cbiAgICAvLyBUaGUgdXNlciBtYXkgaGF2ZSBjbG9zZWQgdGhlIGNvbm5lY3Rpb24gZnJvbSBhIGxpc3RlbmVyIG9mIHRoZVxuICAgIC8vIGAndXBncmFkZSdgIGV2ZW50LlxuICAgIC8vXG4gICAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuQ09OTkVDVElORykgcmV0dXJuO1xuXG4gICAgcmVxID0gd2Vic29ja2V0Ll9yZXEgPSBudWxsO1xuXG4gICAgY29uc3QgdXBncmFkZSA9IHJlcy5oZWFkZXJzLnVwZ3JhZGU7XG5cbiAgICBpZiAodXBncmFkZSA9PT0gdW5kZWZpbmVkIHx8IHVwZ3JhZGUudG9Mb3dlckNhc2UoKSAhPT0gJ3dlYnNvY2tldCcpIHtcbiAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCAnSW52YWxpZCBVcGdyYWRlIGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGRpZ2VzdCA9IGNyZWF0ZUhhc2goJ3NoYTEnKVxuICAgICAgLnVwZGF0ZShrZXkgKyBHVUlEKVxuICAgICAgLmRpZ2VzdCgnYmFzZTY0Jyk7XG5cbiAgICBpZiAocmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtYWNjZXB0J10gIT09IGRpZ2VzdCkge1xuICAgICAgYWJvcnRIYW5kc2hha2Uod2Vic29ja2V0LCBzb2NrZXQsICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtQWNjZXB0IGhlYWRlcicpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNlcnZlclByb3QgPSByZXMuaGVhZGVyc1snc2VjLXdlYnNvY2tldC1wcm90b2NvbCddO1xuICAgIGxldCBwcm90RXJyb3I7XG5cbiAgICBpZiAoc2VydmVyUHJvdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoIXByb3RvY29sU2V0LnNpemUpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGEgc3VicHJvdG9jb2wgYnV0IG5vbmUgd2FzIHJlcXVlc3RlZCc7XG4gICAgICB9IGVsc2UgaWYgKCFwcm90b2NvbFNldC5oYXMoc2VydmVyUHJvdCkpIHtcbiAgICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IGFuIGludmFsaWQgc3VicHJvdG9jb2wnO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAocHJvdG9jb2xTZXQuc2l6ZSkge1xuICAgICAgcHJvdEVycm9yID0gJ1NlcnZlciBzZW50IG5vIHN1YnByb3RvY29sJztcbiAgICB9XG5cbiAgICBpZiAocHJvdEVycm9yKSB7XG4gICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgcHJvdEVycm9yKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoc2VydmVyUHJvdCkgd2Vic29ja2V0Ll9wcm90b2NvbCA9IHNlcnZlclByb3Q7XG5cbiAgICBjb25zdCBzZWNXZWJTb2NrZXRFeHRlbnNpb25zID0gcmVzLmhlYWRlcnNbJ3NlYy13ZWJzb2NrZXQtZXh0ZW5zaW9ucyddO1xuXG4gICAgaWYgKHNlY1dlYlNvY2tldEV4dGVuc2lvbnMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKCFwZXJNZXNzYWdlRGVmbGF0ZSkge1xuICAgICAgICBjb25zdCBtZXNzYWdlID1cbiAgICAgICAgICAnU2VydmVyIHNlbnQgYSBTZWMtV2ViU29ja2V0LUV4dGVuc2lvbnMgaGVhZGVyIGJ1dCBubyBleHRlbnNpb24gJyArXG4gICAgICAgICAgJ3dhcyByZXF1ZXN0ZWQnO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgbGV0IGV4dGVuc2lvbnM7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGV4dGVuc2lvbnMgPSBwYXJzZShzZWNXZWJTb2NrZXRFeHRlbnNpb25zKTtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zdCBtZXNzYWdlID0gJ0ludmFsaWQgU2VjLVdlYlNvY2tldC1FeHRlbnNpb25zIGhlYWRlcic7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBleHRlbnNpb25OYW1lcyA9IE9iamVjdC5rZXlzKGV4dGVuc2lvbnMpO1xuXG4gICAgICBpZiAoXG4gICAgICAgIGV4dGVuc2lvbk5hbWVzLmxlbmd0aCAhPT0gMSB8fFxuICAgICAgICBleHRlbnNpb25OYW1lc1swXSAhPT0gUGVyTWVzc2FnZURlZmxhdGUuZXh0ZW5zaW9uTmFtZVxuICAgICAgKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSAnU2VydmVyIGluZGljYXRlZCBhbiBleHRlbnNpb24gdGhhdCB3YXMgbm90IHJlcXVlc3RlZCc7XG4gICAgICAgIGFib3J0SGFuZHNoYWtlKHdlYnNvY2tldCwgc29ja2V0LCBtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBwZXJNZXNzYWdlRGVmbGF0ZS5hY2NlcHQoZXh0ZW5zaW9uc1tQZXJNZXNzYWdlRGVmbGF0ZS5leHRlbnNpb25OYW1lXSk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9ICdJbnZhbGlkIFNlYy1XZWJTb2NrZXQtRXh0ZW5zaW9ucyBoZWFkZXInO1xuICAgICAgICBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHNvY2tldCwgbWVzc2FnZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgd2Vic29ja2V0Ll9leHRlbnNpb25zW1Blck1lc3NhZ2VEZWZsYXRlLmV4dGVuc2lvbk5hbWVdID1cbiAgICAgICAgcGVyTWVzc2FnZURlZmxhdGU7XG4gICAgfVxuXG4gICAgd2Vic29ja2V0LnNldFNvY2tldChzb2NrZXQsIGhlYWQsIHtcbiAgICAgIGFsbG93U3luY2hyb25vdXNFdmVudHM6IG9wdHMuYWxsb3dTeW5jaHJvbm91c0V2ZW50cyxcbiAgICAgIGdlbmVyYXRlTWFzazogb3B0cy5nZW5lcmF0ZU1hc2ssXG4gICAgICBtYXhQYXlsb2FkOiBvcHRzLm1heFBheWxvYWQsXG4gICAgICBza2lwVVRGOFZhbGlkYXRpb246IG9wdHMuc2tpcFVURjhWYWxpZGF0aW9uXG4gICAgfSk7XG4gIH0pO1xuXG4gIGlmIChvcHRzLmZpbmlzaFJlcXVlc3QpIHtcbiAgICBvcHRzLmZpbmlzaFJlcXVlc3QocmVxLCB3ZWJzb2NrZXQpO1xuICB9IGVsc2Uge1xuICAgIHJlcS5lbmQoKTtcbiAgfVxufVxuXG4vKipcbiAqIEVtaXQgdGhlIGAnZXJyb3InYCBhbmQgYCdjbG9zZSdgIGV2ZW50cy5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvciB0byBlbWl0XG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBlbWl0RXJyb3JBbmRDbG9zZSh3ZWJzb2NrZXQsIGVycikge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBhc3NpZ25tZW50IGlzIHByYWN0aWNhbGx5IHVzZWxlc3MgYW5kIGlzIGRvbmUgb25seSBmb3JcbiAgLy8gY29uc2lzdGVuY3kuXG4gIC8vXG4gIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgd2Vic29ja2V0LmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgd2Vic29ja2V0LmVtaXRDbG9zZSgpO1xufVxuXG4vKipcbiAqIENyZWF0ZSBhIGBuZXQuU29ja2V0YCBhbmQgaW5pdGlhdGUgYSBjb25uZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIENvbm5lY3Rpb24gb3B0aW9uc1xuICogQHJldHVybiB7bmV0LlNvY2tldH0gVGhlIG5ld2x5IGNyZWF0ZWQgc29ja2V0IHVzZWQgdG8gc3RhcnQgdGhlIGNvbm5lY3Rpb25cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIG5ldENvbm5lY3Qob3B0aW9ucykge1xuICBvcHRpb25zLnBhdGggPSBvcHRpb25zLnNvY2tldFBhdGg7XG4gIHJldHVybiBuZXQuY29ubmVjdChvcHRpb25zKTtcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBgdGxzLlRMU1NvY2tldGAgYW5kIGluaXRpYXRlIGEgY29ubmVjdGlvbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyBDb25uZWN0aW9uIG9wdGlvbnNcbiAqIEByZXR1cm4ge3Rscy5UTFNTb2NrZXR9IFRoZSBuZXdseSBjcmVhdGVkIHNvY2tldCB1c2VkIHRvIHN0YXJ0IHRoZSBjb25uZWN0aW9uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiB0bHNDb25uZWN0KG9wdGlvbnMpIHtcbiAgb3B0aW9ucy5wYXRoID0gdW5kZWZpbmVkO1xuXG4gIGlmICghb3B0aW9ucy5zZXJ2ZXJuYW1lICYmIG9wdGlvbnMuc2VydmVybmFtZSAhPT0gJycpIHtcbiAgICBvcHRpb25zLnNlcnZlcm5hbWUgPSBuZXQuaXNJUChvcHRpb25zLmhvc3QpID8gJycgOiBvcHRpb25zLmhvc3Q7XG4gIH1cblxuICByZXR1cm4gdGxzLmNvbm5lY3Qob3B0aW9ucyk7XG59XG5cbi8qKlxuICogQWJvcnQgdGhlIGhhbmRzaGFrZSBhbmQgZW1pdCBhbiBlcnJvci5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7KGh0dHAuQ2xpZW50UmVxdWVzdHxuZXQuU29ja2V0fHRscy5Tb2NrZXQpfSBzdHJlYW0gVGhlIHJlcXVlc3QgdG9cbiAqICAgICBhYm9ydCBvciB0aGUgc29ja2V0IHRvIGRlc3Ryb3lcbiAqIEBwYXJhbSB7U3RyaW5nfSBtZXNzYWdlIFRoZSBlcnJvciBtZXNzYWdlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBhYm9ydEhhbmRzaGFrZSh3ZWJzb2NrZXQsIHN0cmVhbSwgbWVzc2FnZSkge1xuICB3ZWJzb2NrZXQuX3JlYWR5U3RhdGUgPSBXZWJTb2NrZXQuQ0xPU0lORztcblxuICBjb25zdCBlcnIgPSBuZXcgRXJyb3IobWVzc2FnZSk7XG4gIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKGVyciwgYWJvcnRIYW5kc2hha2UpO1xuXG4gIGlmIChzdHJlYW0uc2V0SGVhZGVyKSB7XG4gICAgc3RyZWFtW2tBYm9ydGVkXSA9IHRydWU7XG4gICAgc3RyZWFtLmFib3J0KCk7XG5cbiAgICBpZiAoc3RyZWFtLnNvY2tldCAmJiAhc3RyZWFtLnNvY2tldC5kZXN0cm95ZWQpIHtcbiAgICAgIC8vXG4gICAgICAvLyBPbiBOb2RlLmpzID49IDE0LjMuMCBgcmVxdWVzdC5hYm9ydCgpYCBkb2VzIG5vdCBkZXN0cm95IHRoZSBzb2NrZXQgaWZcbiAgICAgIC8vIGNhbGxlZCBhZnRlciB0aGUgcmVxdWVzdCBjb21wbGV0ZWQuIFNlZVxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE4NjkuXG4gICAgICAvL1xuICAgICAgc3RyZWFtLnNvY2tldC5kZXN0cm95KCk7XG4gICAgfVxuXG4gICAgcHJvY2Vzcy5uZXh0VGljayhlbWl0RXJyb3JBbmRDbG9zZSwgd2Vic29ja2V0LCBlcnIpO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbS5kZXN0cm95KGVycik7XG4gICAgc3RyZWFtLm9uY2UoJ2Vycm9yJywgd2Vic29ja2V0LmVtaXQuYmluZCh3ZWJzb2NrZXQsICdlcnJvcicpKTtcbiAgICBzdHJlYW0ub25jZSgnY2xvc2UnLCB3ZWJzb2NrZXQuZW1pdENsb3NlLmJpbmQod2Vic29ja2V0KSk7XG4gIH1cbn1cblxuLyoqXG4gKiBIYW5kbGUgY2FzZXMgd2hlcmUgdGhlIGBwaW5nKClgLCBgcG9uZygpYCwgb3IgYHNlbmQoKWAgbWV0aG9kcyBhcmUgY2FsbGVkXG4gKiB3aGVuIHRoZSBgcmVhZHlTdGF0ZWAgYXR0cmlidXRlIGlzIGBDTE9TSU5HYCBvciBgQ0xPU0VEYC5cbiAqXG4gKiBAcGFyYW0ge1dlYlNvY2tldH0gd2Vic29ja2V0IFRoZSBXZWJTb2NrZXQgaW5zdGFuY2VcbiAqIEBwYXJhbSB7Kn0gW2RhdGFdIFRoZSBkYXRhIHRvIHNlbmRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYl0gQ2FsbGJhY2tcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNlbmRBZnRlckNsb3NlKHdlYnNvY2tldCwgZGF0YSwgY2IpIHtcbiAgaWYgKGRhdGEpIHtcbiAgICBjb25zdCBsZW5ndGggPSBpc0Jsb2IoZGF0YSkgPyBkYXRhLnNpemUgOiB0b0J1ZmZlcihkYXRhKS5sZW5ndGg7XG5cbiAgICAvL1xuICAgIC8vIFRoZSBgX2J1ZmZlcmVkQW1vdW50YCBwcm9wZXJ0eSBpcyB1c2VkIG9ubHkgd2hlbiB0aGUgcGVlciBpcyBhIGNsaWVudCBhbmRcbiAgICAvLyB0aGUgb3BlbmluZyBoYW5kc2hha2UgZmFpbHMuIFVuZGVyIHRoZXNlIGNpcmN1bXN0YW5jZXMsIGluIGZhY3QsIHRoZVxuICAgIC8vIGBzZXRTb2NrZXQoKWAgbWV0aG9kIGlzIG5vdCBjYWxsZWQsIHNvIHRoZSBgX3NvY2tldGAgYW5kIGBfc2VuZGVyYFxuICAgIC8vIHByb3BlcnRpZXMgYXJlIHNldCB0byBgbnVsbGAuXG4gICAgLy9cbiAgICBpZiAod2Vic29ja2V0Ll9zb2NrZXQpIHdlYnNvY2tldC5fc2VuZGVyLl9idWZmZXJlZEJ5dGVzICs9IGxlbmd0aDtcbiAgICBlbHNlIHdlYnNvY2tldC5fYnVmZmVyZWRBbW91bnQgKz0gbGVuZ3RoO1xuICB9XG5cbiAgaWYgKGNiKSB7XG4gICAgY29uc3QgZXJyID0gbmV3IEVycm9yKFxuICAgICAgYFdlYlNvY2tldCBpcyBub3Qgb3BlbjogcmVhZHlTdGF0ZSAke3dlYnNvY2tldC5yZWFkeVN0YXRlfSBgICtcbiAgICAgICAgYCgke3JlYWR5U3RhdGVzW3dlYnNvY2tldC5yZWFkeVN0YXRlXX0pYFxuICAgICk7XG4gICAgcHJvY2Vzcy5uZXh0VGljayhjYiwgZXJyKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2NvbmNsdWRlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgVGhlIHN0YXR1cyBjb2RlXG4gKiBAcGFyYW0ge0J1ZmZlcn0gcmVhc29uIFRoZSByZWFzb24gZm9yIGNsb3NpbmdcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Db25jbHVkZShjb2RlLCByZWFzb24pIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB3ZWJzb2NrZXQuX2Nsb3NlRnJhbWVSZWNlaXZlZCA9IHRydWU7XG4gIHdlYnNvY2tldC5fY2xvc2VNZXNzYWdlID0gcmVhc29uO1xuICB3ZWJzb2NrZXQuX2Nsb3NlQ29kZSA9IGNvZGU7XG5cbiAgaWYgKHdlYnNvY2tldC5fc29ja2V0W2tXZWJTb2NrZXRdID09PSB1bmRlZmluZWQpIHJldHVybjtcblxuICB3ZWJzb2NrZXQuX3NvY2tldC5yZW1vdmVMaXN0ZW5lcignZGF0YScsIHNvY2tldE9uRGF0YSk7XG4gIHByb2Nlc3MubmV4dFRpY2socmVzdW1lLCB3ZWJzb2NrZXQuX3NvY2tldCk7XG5cbiAgaWYgKGNvZGUgPT09IDEwMDUpIHdlYnNvY2tldC5jbG9zZSgpO1xuICBlbHNlIHdlYnNvY2tldC5jbG9zZShjb2RlLCByZWFzb24pO1xufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgYFJlY2VpdmVyYCBgJ2RyYWluJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkRyYWluKCkge1xuICBjb25zdCB3ZWJzb2NrZXQgPSB0aGlzW2tXZWJTb2NrZXRdO1xuXG4gIGlmICghd2Vic29ja2V0LmlzUGF1c2VkKSB3ZWJzb2NrZXQuX3NvY2tldC5yZXN1bWUoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7KFJhbmdlRXJyb3J8RXJyb3IpfSBlcnIgVGhlIGVtaXR0ZWQgZXJyb3JcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9zb2NrZXRba1dlYlNvY2tldF0gIT09IHVuZGVmaW5lZCkge1xuICAgIHdlYnNvY2tldC5fc29ja2V0LnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcblxuICAgIC8vXG4gICAgLy8gT24gTm9kZS5qcyA8IDE0LjAuMCB0aGUgYCdlcnJvcidgIGV2ZW50IGlzIGVtaXR0ZWQgc3luY2hyb25vdXNseS4gU2VlXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3dlYnNvY2tldHMvd3MvaXNzdWVzLzE5NDAuXG4gICAgLy9cbiAgICBwcm9jZXNzLm5leHRUaWNrKHJlc3VtZSwgd2Vic29ja2V0Ll9zb2NrZXQpO1xuXG4gICAgd2Vic29ja2V0LmNsb3NlKGVycltrU3RhdHVzQ29kZV0pO1xuICB9XG5cbiAgaWYgKCF3ZWJzb2NrZXQuX2Vycm9yRW1pdHRlZCkge1xuICAgIHdlYnNvY2tldC5fZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICB3ZWJzb2NrZXQuZW1pdCgnZXJyb3InLCBlcnIpO1xuICB9XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBgUmVjZWl2ZXJgIGAnZmluaXNoJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVjZWl2ZXJPbkZpbmlzaCgpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0Q2xvc2UoKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdtZXNzYWdlJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ8QXJyYXlCdWZmZXJ8QnVmZmVyW10pfSBkYXRhIFRoZSBtZXNzYWdlXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGlzQmluYXJ5IFNwZWNpZmllcyB3aGV0aGVyIHRoZSBtZXNzYWdlIGlzIGJpbmFyeSBvciBub3RcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25NZXNzYWdlKGRhdGEsIGlzQmluYXJ5KSB7XG4gIHRoaXNba1dlYlNvY2tldF0uZW1pdCgnbWVzc2FnZScsIGRhdGEsIGlzQmluYXJ5KTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwaW5nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBpbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25QaW5nKGRhdGEpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0Ll9hdXRvUG9uZykgd2Vic29ja2V0LnBvbmcoZGF0YSwgIXRoaXMuX2lzU2VydmVyLCBOT09QKTtcbiAgd2Vic29ja2V0LmVtaXQoJ3BpbmcnLCBkYXRhKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIGBSZWNlaXZlcmAgYCdwb25nJ2AgZXZlbnQuXG4gKlxuICogQHBhcmFtIHtCdWZmZXJ9IGRhdGEgVGhlIGRhdGEgaW5jbHVkZWQgaW4gdGhlIHBvbmcgZnJhbWVcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlY2VpdmVyT25Qb25nKGRhdGEpIHtcbiAgdGhpc1trV2ViU29ja2V0XS5lbWl0KCdwb25nJywgZGF0YSk7XG59XG5cbi8qKlxuICogUmVzdW1lIGEgcmVhZGFibGUgc3RyZWFtXG4gKlxuICogQHBhcmFtIHtSZWFkYWJsZX0gc3RyZWFtIFRoZSByZWFkYWJsZSBzdHJlYW1cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHJlc3VtZShzdHJlYW0pIHtcbiAgc3RyZWFtLnJlc3VtZSgpO1xufVxuXG4vKipcbiAqIFRoZSBgU2VuZGVyYCBlcnJvciBldmVudCBoYW5kbGVyLlxuICpcbiAqIEBwYXJhbSB7RXJyb3J9IFRoZSBlcnJvclxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc2VuZGVyT25FcnJvcihlcnIpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICBpZiAod2Vic29ja2V0LnJlYWR5U3RhdGUgPT09IFdlYlNvY2tldC5DTE9TRUQpIHJldHVybjtcbiAgaWYgKHdlYnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuICAgIHNldENsb3NlVGltZXIod2Vic29ja2V0KTtcbiAgfVxuXG4gIC8vXG4gIC8vIGBzb2NrZXQuZW5kKClgIGlzIHVzZWQgaW5zdGVhZCBvZiBgc29ja2V0LmRlc3Ryb3koKWAgdG8gYWxsb3cgdGhlIG90aGVyXG4gIC8vIHBlZXIgdG8gZmluaXNoIHNlbmRpbmcgcXVldWVkIGRhdGEuIFRoZXJlIGlzIG5vIG5lZWQgdG8gc2V0IGEgdGltZXIgaGVyZVxuICAvLyBiZWNhdXNlIGBDTE9TSU5HYCBtZWFucyB0aGF0IGl0IGlzIGFscmVhZHkgc2V0IG9yIG5vdCBuZWVkZWQuXG4gIC8vXG4gIHRoaXMuX3NvY2tldC5lbmQoKTtcblxuICBpZiAoIXdlYnNvY2tldC5fZXJyb3JFbWl0dGVkKSB7XG4gICAgd2Vic29ja2V0Ll9lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHdlYnNvY2tldC5lbWl0KCdlcnJvcicsIGVycik7XG4gIH1cbn1cblxuLyoqXG4gKiBTZXQgYSB0aW1lciB0byBkZXN0cm95IHRoZSB1bmRlcmx5aW5nIHJhdyBzb2NrZXQgb2YgYSBXZWJTb2NrZXQuXG4gKlxuICogQHBhcmFtIHtXZWJTb2NrZXR9IHdlYnNvY2tldCBUaGUgV2ViU29ja2V0IGluc3RhbmNlXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzZXRDbG9zZVRpbWVyKHdlYnNvY2tldCkge1xuICB3ZWJzb2NrZXQuX2Nsb3NlVGltZXIgPSBzZXRUaW1lb3V0KFxuICAgIHdlYnNvY2tldC5fc29ja2V0LmRlc3Ryb3kuYmluZCh3ZWJzb2NrZXQuX3NvY2tldCksXG4gICAgd2Vic29ja2V0Ll9jbG9zZVRpbWVvdXRcbiAgKTtcbn1cblxuLyoqXG4gKiBUaGUgbGlzdGVuZXIgb2YgdGhlIHNvY2tldCBgJ2Nsb3NlJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25DbG9zZSgpIHtcbiAgY29uc3Qgd2Vic29ja2V0ID0gdGhpc1trV2ViU29ja2V0XTtcblxuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIHNvY2tldE9uQ2xvc2UpO1xuICB0aGlzLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgc29ja2V0T25EYXRhKTtcbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZW5kJywgc29ja2V0T25FbmQpO1xuXG4gIHdlYnNvY2tldC5fcmVhZHlTdGF0ZSA9IFdlYlNvY2tldC5DTE9TSU5HO1xuXG4gIC8vXG4gIC8vIFRoZSBjbG9zZSBmcmFtZSBtaWdodCBub3QgaGF2ZSBiZWVuIHJlY2VpdmVkIG9yIHRoZSBgJ2VuZCdgIGV2ZW50IGVtaXR0ZWQsXG4gIC8vIGZvciBleGFtcGxlLCBpZiB0aGUgc29ja2V0IHdhcyBkZXN0cm95ZWQgZHVlIHRvIGFuIGVycm9yLiBFbnN1cmUgdGhhdCB0aGVcbiAgLy8gYHJlY2VpdmVyYCBzdHJlYW0gaXMgY2xvc2VkIGFmdGVyIHdyaXRpbmcgYW55IHJlbWFpbmluZyBidWZmZXJlZCBkYXRhIHRvXG4gIC8vIGl0LiBJZiB0aGUgcmVhZGFibGUgc2lkZSBvZiB0aGUgc29ja2V0IGlzIGluIGZsb3dpbmcgbW9kZSB0aGVuIHRoZXJlIGlzIG5vXG4gIC8vIGJ1ZmZlcmVkIGRhdGEgYXMgZXZlcnl0aGluZyBoYXMgYmVlbiBhbHJlYWR5IHdyaXR0ZW4uIElmIGluc3RlYWQsIHRoZVxuICAvLyBzb2NrZXQgaXMgcGF1c2VkLCBhbnkgcG9zc2libGUgYnVmZmVyZWQgZGF0YSB3aWxsIGJlIHJlYWQgYXMgYSBzaW5nbGVcbiAgLy8gY2h1bmsuXG4gIC8vXG4gIGlmIChcbiAgICAhdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRFbWl0dGVkICYmXG4gICAgIXdlYnNvY2tldC5fY2xvc2VGcmFtZVJlY2VpdmVkICYmXG4gICAgIXdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkICYmXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGggIT09IDBcbiAgKSB7XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLnJlYWQodGhpcy5fcmVhZGFibGVTdGF0ZS5sZW5ndGgpO1xuXG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci53cml0ZShjaHVuayk7XG4gIH1cblxuICB3ZWJzb2NrZXQuX3JlY2VpdmVyLmVuZCgpO1xuXG4gIHRoaXNba1dlYlNvY2tldF0gPSB1bmRlZmluZWQ7XG5cbiAgY2xlYXJUaW1lb3V0KHdlYnNvY2tldC5fY2xvc2VUaW1lcik7XG5cbiAgaWYgKFxuICAgIHdlYnNvY2tldC5fcmVjZWl2ZXIuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgfHxcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZFxuICApIHtcbiAgICB3ZWJzb2NrZXQuZW1pdENsb3NlKCk7XG4gIH0gZWxzZSB7XG4gICAgd2Vic29ja2V0Ll9yZWNlaXZlci5vbignZXJyb3InLCByZWNlaXZlck9uRmluaXNoKTtcbiAgICB3ZWJzb2NrZXQuX3JlY2VpdmVyLm9uKCdmaW5pc2gnLCByZWNlaXZlck9uRmluaXNoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZGF0YSdgIGV2ZW50LlxuICpcbiAqIEBwYXJhbSB7QnVmZmVyfSBjaHVuayBBIGNodW5rIG9mIGRhdGFcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRGF0YShjaHVuaykge1xuICBpZiAoIXRoaXNba1dlYlNvY2tldF0uX3JlY2VpdmVyLndyaXRlKGNodW5rKSkge1xuICAgIHRoaXMucGF1c2UoKTtcbiAgfVxufVxuXG4vKipcbiAqIFRoZSBsaXN0ZW5lciBvZiB0aGUgc29ja2V0IGAnZW5kJ2AgZXZlbnQuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gc29ja2V0T25FbmQoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gIHdlYnNvY2tldC5fcmVjZWl2ZXIuZW5kKCk7XG4gIHRoaXMuZW5kKCk7XG59XG5cbi8qKlxuICogVGhlIGxpc3RlbmVyIG9mIHRoZSBzb2NrZXQgYCdlcnJvcidgIGV2ZW50LlxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNvY2tldE9uRXJyb3IoKSB7XG4gIGNvbnN0IHdlYnNvY2tldCA9IHRoaXNba1dlYlNvY2tldF07XG5cbiAgdGhpcy5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBzb2NrZXRPbkVycm9yKTtcbiAgdGhpcy5vbignZXJyb3InLCBOT09QKTtcblxuICBpZiAod2Vic29ja2V0KSB7XG4gICAgd2Vic29ja2V0Ll9yZWFkeVN0YXRlID0gV2ViU29ja2V0LkNMT1NJTkc7XG4gICAgdGhpcy5kZXN0cm95KCk7XG4gIH1cbn1cbiJdLCJuYW1lcyI6WyJFdmVudEVtaXR0ZXIiLCJyZXF1aXJlIiwiaHR0cHMiLCJodHRwIiwibmV0IiwidGxzIiwicmFuZG9tQnl0ZXMiLCJjcmVhdGVIYXNoIiwiRHVwbGV4IiwiUmVhZGFibGUiLCJVUkwiLCJQZXJNZXNzYWdlRGVmbGF0ZSIsIlJlY2VpdmVyIiwiU2VuZGVyIiwiaXNCbG9iIiwiQklOQVJZX1RZUEVTIiwiQ0xPU0VfVElNRU9VVCIsIkVNUFRZX0JVRkZFUiIsIkdVSUQiLCJrRm9yT25FdmVudEF0dHJpYnV0ZSIsImtMaXN0ZW5lciIsImtTdGF0dXNDb2RlIiwia1dlYlNvY2tldCIsIk5PT1AiLCJFdmVudFRhcmdldCIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiZm9ybWF0IiwicGFyc2UiLCJ0b0J1ZmZlciIsImtBYm9ydGVkIiwiU3ltYm9sIiwicHJvdG9jb2xWZXJzaW9ucyIsInJlYWR5U3RhdGVzIiwic3VicHJvdG9jb2xSZWdleCIsIldlYlNvY2tldCIsImNvbnN0cnVjdG9yIiwiYWRkcmVzcyIsInByb3RvY29scyIsIm9wdGlvbnMiLCJfYmluYXJ5VHlwZSIsIl9jbG9zZUNvZGUiLCJfY2xvc2VGcmFtZVJlY2VpdmVkIiwiX2Nsb3NlRnJhbWVTZW50IiwiX2Nsb3NlTWVzc2FnZSIsIl9jbG9zZVRpbWVyIiwiX2Vycm9yRW1pdHRlZCIsIl9leHRlbnNpb25zIiwiX3BhdXNlZCIsIl9wcm90b2NvbCIsIl9yZWFkeVN0YXRlIiwiQ09OTkVDVElORyIsIl9yZWNlaXZlciIsIl9zZW5kZXIiLCJfc29ja2V0IiwiX2J1ZmZlcmVkQW1vdW50IiwiX2lzU2VydmVyIiwiX3JlZGlyZWN0cyIsInVuZGVmaW5lZCIsIkFycmF5IiwiaXNBcnJheSIsImluaXRBc0NsaWVudCIsIl9hdXRvUG9uZyIsImF1dG9Qb25nIiwiX2Nsb3NlVGltZW91dCIsImNsb3NlVGltZW91dCIsImJpbmFyeVR5cGUiLCJ0eXBlIiwiaW5jbHVkZXMiLCJidWZmZXJlZEFtb3VudCIsIl93cml0YWJsZVN0YXRlIiwibGVuZ3RoIiwiX2J1ZmZlcmVkQnl0ZXMiLCJleHRlbnNpb25zIiwiT2JqZWN0Iiwia2V5cyIsImpvaW4iLCJpc1BhdXNlZCIsIm9uY2xvc2UiLCJvbmVycm9yIiwib25vcGVuIiwib25tZXNzYWdlIiwicHJvdG9jb2wiLCJyZWFkeVN0YXRlIiwidXJsIiwiX3VybCIsInNldFNvY2tldCIsInNvY2tldCIsImhlYWQiLCJyZWNlaXZlciIsImFsbG93U3luY2hyb25vdXNFdmVudHMiLCJpc1NlcnZlciIsIm1heFBheWxvYWQiLCJza2lwVVRGOFZhbGlkYXRpb24iLCJzZW5kZXIiLCJnZW5lcmF0ZU1hc2siLCJvbiIsInJlY2VpdmVyT25Db25jbHVkZSIsInJlY2VpdmVyT25EcmFpbiIsInJlY2VpdmVyT25FcnJvciIsInJlY2VpdmVyT25NZXNzYWdlIiwicmVjZWl2ZXJPblBpbmciLCJyZWNlaXZlck9uUG9uZyIsInNlbmRlck9uRXJyb3IiLCJzZXRUaW1lb3V0Iiwic2V0Tm9EZWxheSIsInVuc2hpZnQiLCJzb2NrZXRPbkNsb3NlIiwic29ja2V0T25EYXRhIiwic29ja2V0T25FbmQiLCJzb2NrZXRPbkVycm9yIiwiT1BFTiIsImVtaXQiLCJlbWl0Q2xvc2UiLCJDTE9TRUQiLCJleHRlbnNpb25OYW1lIiwiY2xlYW51cCIsInJlbW92ZUFsbExpc3RlbmVycyIsImNsb3NlIiwiY29kZSIsImRhdGEiLCJtc2ciLCJhYm9ydEhhbmRzaGFrZSIsIl9yZXEiLCJDTE9TSU5HIiwiZXJyb3JFbWl0dGVkIiwiZW5kIiwiZXJyIiwic2V0Q2xvc2VUaW1lciIsInBhdXNlIiwicGluZyIsIm1hc2siLCJjYiIsIkVycm9yIiwidG9TdHJpbmciLCJzZW5kQWZ0ZXJDbG9zZSIsInBvbmciLCJyZXN1bWUiLCJuZWVkRHJhaW4iLCJzZW5kIiwib3B0cyIsImJpbmFyeSIsImNvbXByZXNzIiwiZmluIiwidGVybWluYXRlIiwiZGVzdHJveSIsImRlZmluZVByb3BlcnR5IiwiZW51bWVyYWJsZSIsInZhbHVlIiwiaW5kZXhPZiIsInByb3RvdHlwZSIsImZvckVhY2giLCJwcm9wZXJ0eSIsIm1ldGhvZCIsImdldCIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwic2V0IiwiaGFuZGxlciIsInJlbW92ZUxpc3RlbmVyIiwibW9kdWxlIiwiZXhwb3J0cyIsIndlYnNvY2tldCIsInByb3RvY29sVmVyc2lvbiIsInBlck1lc3NhZ2VEZWZsYXRlIiwiZm9sbG93UmVkaXJlY3RzIiwibWF4UmVkaXJlY3RzIiwic29ja2V0UGF0aCIsImhvc3RuYW1lIiwidGltZW91dCIsImhvc3QiLCJwYXRoIiwicG9ydCIsIlJhbmdlRXJyb3IiLCJwYXJzZWRVcmwiLCJlIiwiU3ludGF4RXJyb3IiLCJocmVmIiwiaXNTZWN1cmUiLCJpc0lwY1VybCIsImludmFsaWRVcmxNZXNzYWdlIiwicGF0aG5hbWUiLCJoYXNoIiwiZW1pdEVycm9yQW5kQ2xvc2UiLCJkZWZhdWx0UG9ydCIsImtleSIsInJlcXVlc3QiLCJwcm90b2NvbFNldCIsIlNldCIsImNyZWF0ZUNvbm5lY3Rpb24iLCJ0bHNDb25uZWN0IiwibmV0Q29ubmVjdCIsInN0YXJ0c1dpdGgiLCJzbGljZSIsImhlYWRlcnMiLCJDb25uZWN0aW9uIiwiVXBncmFkZSIsInNlYXJjaCIsImhhbmRzaGFrZVRpbWVvdXQiLCJvZmZlciIsInRlc3QiLCJoYXMiLCJhZGQiLCJvcmlnaW4iLCJPcmlnaW4iLCJ1c2VybmFtZSIsInBhc3N3b3JkIiwiYXV0aCIsInBhcnRzIiwic3BsaXQiLCJyZXEiLCJfb3JpZ2luYWxJcGMiLCJfb3JpZ2luYWxTZWN1cmUiLCJfb3JpZ2luYWxIb3N0T3JTb2NrZXRQYXRoIiwiZW50cmllcyIsInRvTG93ZXJDYXNlIiwibGlzdGVuZXJDb3VudCIsImlzU2FtZUhvc3QiLCJhdXRob3JpemF0aW9uIiwiY29va2llIiwiQnVmZmVyIiwiZnJvbSIsInJlcyIsImxvY2F0aW9uIiwic3RhdHVzQ29kZSIsImFib3J0IiwiYWRkciIsInVwZ3JhZGUiLCJkaWdlc3QiLCJ1cGRhdGUiLCJzZXJ2ZXJQcm90IiwicHJvdEVycm9yIiwic2l6ZSIsInNlY1dlYlNvY2tldEV4dGVuc2lvbnMiLCJtZXNzYWdlIiwiZXh0ZW5zaW9uTmFtZXMiLCJhY2NlcHQiLCJmaW5pc2hSZXF1ZXN0IiwiY29ubmVjdCIsInNlcnZlcm5hbWUiLCJpc0lQIiwic3RyZWFtIiwiY2FwdHVyZVN0YWNrVHJhY2UiLCJzZXRIZWFkZXIiLCJkZXN0cm95ZWQiLCJwcm9jZXNzIiwibmV4dFRpY2siLCJvbmNlIiwiYmluZCIsInJlYXNvbiIsInJlY2VpdmVyT25GaW5pc2giLCJpc0JpbmFyeSIsIl9yZWFkYWJsZVN0YXRlIiwiZW5kRW1pdHRlZCIsImNodW5rIiwicmVhZCIsIndyaXRlIiwiY2xlYXJUaW1lb3V0IiwiZmluaXNoZWQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/dist/index.mjs":
/*!****************************************************!*\
  !*** ./node_modules/rpc-websockets/dist/index.mjs ***!
  \****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   CommonClient: () => (/* binding */ CommonClient),\n/* harmony export */   DefaultDataPack: () => (/* binding */ DefaultDataPack),\n/* harmony export */   Server: () => (/* binding */ Server),\n/* harmony export */   WebSocket: () => (/* binding */ WebSocket),\n/* harmony export */   createError: () => (/* binding */ createError)\n/* harmony export */ });\n/* harmony import */ var ws__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ws */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/wrapper.mjs\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! eventemitter3 */ \"(rsc)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\");\n/* harmony import */ var node_url__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! node:url */ \"node:url\");\n/* harmony import */ var uuid__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! uuid */ \"(rsc)/./node_modules/uuid/dist/esm-node/v1.js\");\n\n\n\n\n// src/lib/client/websocket.ts\nfunction WebSocket(address, options) {\n    return new ws__WEBPACK_IMPORTED_MODULE_0__[\"default\"](address, options);\n}\n// src/lib/utils.ts\nvar DefaultDataPack = class {\n    encode(value) {\n        return JSON.stringify(value);\n    }\n    decode(value) {\n        return JSON.parse(value);\n    }\n};\n// src/lib/client.ts\nvar CommonClient = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Client class.\n  * @constructor\n  * @param {webSocketFactory} webSocketFactory - factory method for WebSocket\n  * @param {String} address - url to a websocket server\n  * @param {Object} options - ws options object with reconnect parameters\n  * @param {Function} generate_request_id - custom generation request Id\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {CommonClient}\n  */ constructor(webSocketFactory, address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id, dataPack){\n        super();\n        this.webSocketFactory = webSocketFactory;\n        this.queue = {};\n        this.rpc_id = 0;\n        this.address = address;\n        this.autoconnect = autoconnect;\n        this.ready = false;\n        this.reconnect = reconnect;\n        this.reconnect_timer_id = void 0;\n        this.reconnect_interval = reconnect_interval;\n        this.max_reconnects = max_reconnects;\n        this.rest_options = rest_options;\n        this.current_reconnects = 0;\n        this.generate_request_id = generate_request_id || (()=>typeof this.rpc_id === \"number\" ? ++this.rpc_id : Number(this.rpc_id) + 1);\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        if (this.autoconnect) this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Connects to a defined server if not connected already.\n  * @method\n  * @return {Undefined}\n  */ connect() {\n        if (this.socket) return;\n        this._connect(this.address, {\n            autoconnect: this.autoconnect,\n            reconnect: this.reconnect,\n            reconnect_interval: this.reconnect_interval,\n            max_reconnects: this.max_reconnects,\n            ...this.rest_options\n        });\n    }\n    /**\n  * Calls a registered RPC method on server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object|Array} params - optional method parameters\n  * @param {Number} timeout - RPC reply timeout value\n  * @param {Object} ws_opts - options passed to ws\n  * @return {Promise}\n  */ call(method, params, timeout, ws_opts) {\n        if (!ws_opts && \"object\" === typeof timeout) {\n            ws_opts = timeout;\n            timeout = null;\n        }\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const rpc_id = this.generate_request_id(method, params);\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params: params || void 0,\n                id: rpc_id\n            };\n            this.socket.send(this.dataPack.encode(message), ws_opts, (error)=>{\n                if (error) return reject(error);\n                this.queue[rpc_id] = {\n                    promise: [\n                        resolve,\n                        reject\n                    ]\n                };\n                if (timeout) {\n                    this.queue[rpc_id].timeout = setTimeout(()=>{\n                        delete this.queue[rpc_id];\n                        reject(new Error(\"reply timeout\"));\n                    }, timeout);\n                }\n            });\n        });\n    }\n    /**\n  * Logins with the other side of the connection.\n  * @method\n  * @param {Object} params - Login credentials object\n  * @return {Promise}\n  */ async login(params) {\n        const resp = await this.call(\"rpc.login\", params);\n        if (!resp) throw new Error(\"authentication failed\");\n        return resp;\n    }\n    /**\n  * Fetches a list of client's methods registered on server.\n  * @method\n  * @return {Array}\n  */ async listMethods() {\n        return await this.call(\"__listMethods\");\n    }\n    /**\n  * Sends a JSON-RPC 2.0 notification to server.\n  * @method\n  * @param {String} method - RPC method name\n  * @param {Object} params - optional method parameters\n  * @return {Promise}\n  */ notify(method, params) {\n        return new Promise((resolve, reject)=>{\n            if (!this.ready) return reject(new Error(\"socket not ready\"));\n            const message = {\n                jsonrpc: \"2.0\",\n                method,\n                params\n            };\n            this.socket.send(this.dataPack.encode(message), (error)=>{\n                if (error) return reject(error);\n                resolve();\n            });\n        });\n    }\n    /**\n  * Subscribes for a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async subscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.on\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed subscribing to an event '\" + event + \"' with: \" + result[event]);\n        return result;\n    }\n    /**\n  * Unsubscribes from a defined event.\n  * @method\n  * @param {String|Array} event - event name\n  * @return {Undefined}\n  * @throws {Error}\n  */ async unsubscribe(event) {\n        if (typeof event === \"string\") event = [\n            event\n        ];\n        const result = await this.call(\"rpc.off\", event);\n        if (typeof event === \"string\" && result[event] !== \"ok\") throw new Error(\"Failed unsubscribing from an event with: \" + result);\n        return result;\n    }\n    /**\n  * Closes a WebSocket connection gracefully.\n  * @method\n  * @param {Number} code - socket close code\n  * @param {String} data - optional data to be sent before closing\n  * @return {Undefined}\n  */ close(code, data) {\n        if (this.socket) this.socket.close(code || 1e3, data);\n    }\n    /**\n  * Enable / disable automatic reconnection.\n  * @method\n  * @param {Boolean} reconnect - enable / disable reconnection\n  * @return {Undefined}\n  */ setAutoReconnect(reconnect) {\n        this.reconnect = reconnect;\n    }\n    /**\n  * Set the interval between reconnection attempts.\n  * @method\n  * @param {Number} interval - reconnection interval in milliseconds\n  * @return {Undefined}\n  */ setReconnectInterval(interval) {\n        this.reconnect_interval = interval;\n    }\n    /**\n  * Set the maximum number of reconnection attempts.\n  * @method\n  * @param {Number} max_reconnects - maximum reconnection attempts\n  * @return {Undefined}\n  */ setMaxReconnects(max_reconnects) {\n        this.max_reconnects = max_reconnects;\n    }\n    /**\n  * Get the current number of reconnection attempts made.\n  * @method\n  * @return {Number} current reconnection attempts\n  */ getCurrentReconnects() {\n        return this.current_reconnects;\n    }\n    /**\n  * Get the maximum number of reconnection attempts.\n  * @method\n  * @return {Number} maximum reconnection attempts\n  */ getMaxReconnects() {\n        return this.max_reconnects;\n    }\n    /**\n  * Check if the client is currently attempting to reconnect.\n  * @method\n  * @return {Boolean} true if reconnection is in progress\n  */ isReconnecting() {\n        return this.reconnect_timer_id !== void 0;\n    }\n    /**\n  * Check if the client will attempt to reconnect on the next close event.\n  * @method\n  * @return {Boolean} true if reconnection will be attempted\n  */ willReconnect() {\n        return this.reconnect && (this.max_reconnects === 0 || this.current_reconnects < this.max_reconnects);\n    }\n    /**\n  * Connection/Message handler.\n  * @method\n  * @private\n  * @param {String} address - WebSocket API address\n  * @param {Object} options - ws options object\n  * @return {Undefined}\n  */ _connect(address, options) {\n        clearTimeout(this.reconnect_timer_id);\n        this.socket = this.webSocketFactory(address, options);\n        this.socket.addEventListener(\"open\", ()=>{\n            this.ready = true;\n            this.emit(\"open\");\n            this.current_reconnects = 0;\n        });\n        this.socket.addEventListener(\"message\", ({ data: message })=>{\n            if (message instanceof ArrayBuffer) message = Buffer.from(message).toString();\n            try {\n                message = this.dataPack.decode(message);\n            } catch (error) {\n                return;\n            }\n            if (message.notification && this.listeners(message.notification).length) {\n                if (!Object.keys(message.params).length) return this.emit(message.notification);\n                const args = [\n                    message.notification\n                ];\n                if (message.params.constructor === Object) args.push(message.params);\n                else for(let i = 0; i < message.params.length; i++)args.push(message.params[i]);\n                return Promise.resolve().then(()=>{\n                    this.emit.apply(this, args);\n                });\n            }\n            if (!this.queue[message.id]) {\n                if (message.method) {\n                    return Promise.resolve().then(()=>{\n                        this.emit(message.method, message?.params);\n                    });\n                }\n                return;\n            }\n            if (\"error\" in message === \"result\" in message) this.queue[message.id].promise[1](new Error('Server response malformed. Response must include either \"result\" or \"error\", but not both.'));\n            if (this.queue[message.id].timeout) clearTimeout(this.queue[message.id].timeout);\n            if (message.error) this.queue[message.id].promise[1](message.error);\n            else this.queue[message.id].promise[0](message.result);\n            delete this.queue[message.id];\n        });\n        this.socket.addEventListener(\"error\", (error)=>this.emit(\"error\", error));\n        this.socket.addEventListener(\"close\", ({ code, reason })=>{\n            if (this.ready) setTimeout(()=>this.emit(\"close\", code, reason), 0);\n            this.ready = false;\n            this.socket = void 0;\n            if (code === 1e3) return;\n            this.current_reconnects++;\n            if (this.reconnect && (this.max_reconnects > this.current_reconnects || this.max_reconnects === 0)) this.reconnect_timer_id = setTimeout(()=>this._connect(address, options), this.reconnect_interval);\n            else if (this.reconnect && this.max_reconnects > 0 && this.current_reconnects >= this.max_reconnects) {\n                setTimeout(()=>this.emit(\"max_reconnects_reached\", code, reason), 1);\n            }\n        });\n    }\n};\nvar Server = class extends eventemitter3__WEBPACK_IMPORTED_MODULE_1__.EventEmitter {\n    /**\n  * Instantiate a Server class.\n  * @constructor\n  * @param {Object} options - ws constructor's parameters with rpc\n  * @param {DataPack} dataPack - data pack contains encoder and decoder\n  * @return {Server} - returns a new Server instance\n  */ constructor(options, dataPack){\n        super();\n        this.namespaces = {};\n        if (!dataPack) this.dataPack = new DefaultDataPack();\n        else this.dataPack = dataPack;\n        this.wss = new ws__WEBPACK_IMPORTED_MODULE_0__.WebSocketServer(options);\n        this.wss.on(\"listening\", ()=>this.emit(\"listening\"));\n        this.wss.on(\"connection\", (socket, request)=>{\n            const u = node_url__WEBPACK_IMPORTED_MODULE_2__.parse(request.url, true);\n            const ns = u.pathname;\n            if (u.query.socket_id) socket._id = u.query.socket_id;\n            else socket._id = (0,uuid__WEBPACK_IMPORTED_MODULE_3__[\"default\"])();\n            socket[\"_authenticated\"] = false;\n            socket.on(\"error\", (error)=>this.emit(\"socket-error\", socket, error));\n            socket.on(\"close\", ()=>{\n                this.namespaces[ns].clients.delete(socket._id);\n                for (const event of Object.keys(this.namespaces[ns].events)){\n                    const index = this.namespaces[ns].events[event].sockets.indexOf(socket._id);\n                    if (index >= 0) this.namespaces[ns].events[event].sockets.splice(index, 1);\n                }\n                this.emit(\"disconnection\", socket);\n            });\n            if (!this.namespaces[ns]) this._generateNamespace(ns);\n            this.namespaces[ns].clients.set(socket._id, socket);\n            this.emit(\"connection\", socket, request);\n            return this._handleRPC(socket, ns);\n        });\n        this.wss.on(\"error\", (error)=>this.emit(\"error\", error));\n    }\n    /**\n  * Registers an RPC method.\n  * @method\n  * @param {String} name - method name\n  * @param {Function} fn - a callee function\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IMethod object\n  */ register(name, fn, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        this.namespaces[ns].rpc_methods[name] = {\n            fn,\n            protected: false\n        };\n        return {\n            protected: ()=>this._makeProtectedMethod(name, ns),\n            public: ()=>this._makePublicMethod(name, ns)\n        };\n    }\n    /**\n  * Sets an auth method.\n  * @method\n  * @param {Function} fn - an arbitrary auth method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ setAuth(fn, ns = \"/\") {\n        this.register(\"rpc.login\", fn, ns);\n    }\n    /**\n  * Marks an RPC method as protected.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = true;\n    }\n    /**\n  * Marks an RPC method as public.\n  * @method\n  * @param {String} name - method name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicMethod(name, ns = \"/\") {\n        this.namespaces[ns].rpc_methods[name].protected = false;\n    }\n    /**\n  * Marks an event as protected.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makeProtectedEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = true;\n    }\n    /**\n  * Marks an event as public.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @return {Undefined}\n  */ _makePublicEvent(name, ns = \"/\") {\n        this.namespaces[ns].events[name].protected = false;\n    }\n    /**\n  * Removes a namespace and closes all connections\n  * @method\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Undefined}\n  */ closeNamespace(ns) {\n        const namespace = this.namespaces[ns];\n        if (namespace) {\n            delete namespace.rpc_methods;\n            delete namespace.events;\n            for (const socket of namespace.clients.values())socket.close();\n            delete this.namespaces[ns];\n        }\n    }\n    /**\n  * Creates a new event that can be emitted to clients.\n  * @method\n  * @param {String} name - event name\n  * @param {String} ns - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - returns an IEvent object\n  */ event(name, ns = \"/\") {\n        if (!this.namespaces[ns]) this._generateNamespace(ns);\n        else {\n            const index = this.namespaces[ns].events[name];\n            if (index !== void 0) throw new Error(`Already registered event ${ns}${name}`);\n        }\n        this.namespaces[ns].events[name] = {\n            sockets: [],\n            protected: false\n        };\n        this.on(name, (...params)=>{\n            if (params.length === 1 && params[0] instanceof Object) params = params[0];\n            for (const socket_id of this.namespaces[ns].events[name].sockets){\n                const socket = this.namespaces[ns].clients.get(socket_id);\n                if (!socket) continue;\n                socket.send(this.dataPack.encode({\n                    notification: name,\n                    params\n                }));\n            }\n        });\n        return {\n            protected: ()=>this._makeProtectedEvent(name, ns),\n            public: ()=>this._makePublicEvent(name, ns)\n        };\n    }\n    /**\n  * Returns a requested namespace object\n  * @method\n  * @param {String} name - namespace identifier\n  * @throws {TypeError}\n  * @return {Object} - namespace object\n  */ of(name) {\n        if (!this.namespaces[name]) this._generateNamespace(name);\n        const self = this;\n        return {\n            // self.register convenience method\n            register (fn_name, fn) {\n                if (arguments.length !== 2) throw new Error(\"must provide exactly two arguments\");\n                if (typeof fn_name !== \"string\") throw new Error(\"name must be a string\");\n                if (typeof fn !== \"function\") throw new Error(\"handler must be a function\");\n                return self.register(fn_name, fn, name);\n            },\n            // self.event convenience method\n            event (ev_name) {\n                if (arguments.length !== 1) throw new Error(\"must provide exactly one argument\");\n                if (typeof ev_name !== \"string\") throw new Error(\"name must be a string\");\n                return self.event(ev_name, name);\n            },\n            // self.eventList convenience method\n            get eventList () {\n                return Object.keys(self.namespaces[name].events);\n            },\n            /**\n      * Emits a specified event to this namespace.\n      * @inner\n      * @method\n      * @param {String} event - event name\n      * @param {Array} params - event parameters\n      * @return {Undefined}\n      */ emit (event, ...params) {\n                const nsEvent = self.namespaces[name].events[event];\n                if (nsEvent) for (const socket_id of nsEvent.sockets){\n                    const socket = self.namespaces[name].clients.get(socket_id);\n                    if (!socket) continue;\n                    socket.send(self.dataPack.encode({\n                        notification: event,\n                        params\n                    }));\n                }\n            },\n            /**\n      * Returns a name of this namespace.\n      * @inner\n      * @method\n      * @kind constant\n      * @return {String}\n      */ get name () {\n                return name;\n            },\n            /**\n      * Returns a hash of websocket objects connected to this namespace.\n      * @inner\n      * @method\n      * @return {Object}\n      */ connected () {\n                const socket_ids = [\n                    ...self.namespaces[name].clients.keys()\n                ];\n                return socket_ids.reduce((acc, curr)=>({\n                        ...acc,\n                        [curr]: self.namespaces[name].clients.get(curr)\n                    }), {});\n            },\n            /**\n      * Returns a list of client unique identifiers connected to this namespace.\n      * @inner\n      * @method\n      * @return {Array}\n      */ clients () {\n                return self.namespaces[name];\n            }\n        };\n    }\n    /**\n  * Lists all created events in a given namespace. Defaults to \"/\".\n  * @method\n  * @param {String} ns - namespaces identifier\n  * @readonly\n  * @return {Array} - returns a list of created events\n  */ eventList(ns = \"/\") {\n        if (!this.namespaces[ns]) return [];\n        return Object.keys(this.namespaces[ns].events);\n    }\n    /**\n  * Creates a JSON-RPC 2.0 compliant error\n  * @method\n  * @param {Number} code - indicates the error type that occurred\n  * @param {String} message - provides a short description of the error\n  * @param {String|Object} data - details containing additional information about the error\n  * @return {Object}\n  */ createError(code, message, data) {\n        return {\n            code,\n            message,\n            data: data || null\n        };\n    }\n    /**\n  * Closes the server and terminates all clients.\n  * @method\n  * @return {Promise}\n  */ close() {\n        return new Promise((resolve, reject)=>{\n            try {\n                this.wss.close();\n                this.emit(\"close\");\n                resolve();\n            } catch (error) {\n                reject(error);\n            }\n        });\n    }\n    /**\n  * Handles all WebSocket JSON RPC 2.0 requests.\n  * @private\n  * @param {Object} socket - ws socket instance\n  * @param {String} ns - namespaces identifier\n  * @return {Undefined}\n  */ _handleRPC(socket, ns = \"/\") {\n        socket.on(\"message\", async (data)=>{\n            const msg_options = {};\n            if (data instanceof ArrayBuffer) {\n                msg_options.binary = true;\n                data = Buffer.from(data).toString();\n            }\n            if (socket.readyState !== 1) return;\n            let parsedData;\n            try {\n                parsedData = this.dataPack.decode(data);\n            } catch (error) {\n                return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32700, error.toString()),\n                    id: null\n                }), msg_options);\n            }\n            if (Array.isArray(parsedData)) {\n                if (!parsedData.length) return socket.send(this.dataPack.encode({\n                    jsonrpc: \"2.0\",\n                    error: createError(-32600, \"Invalid array\"),\n                    id: null\n                }), msg_options);\n                const responses = [];\n                for (const message of parsedData){\n                    const response2 = await this._runMethod(message, socket._id, ns);\n                    if (!response2) continue;\n                    responses.push(response2);\n                }\n                if (!responses.length) return;\n                return socket.send(this.dataPack.encode(responses), msg_options);\n            }\n            const response = await this._runMethod(parsedData, socket._id, ns);\n            if (!response) return;\n            return socket.send(this.dataPack.encode(response), msg_options);\n        });\n    }\n    /**\n  * Runs a defined RPC method.\n  * @private\n  * @param {Object} message - a message received\n  * @param {Object} socket_id - user's socket id\n  * @param {String} ns - namespaces identifier\n  * @return {Object|undefined}\n  */ async _runMethod(message, socket_id, ns = \"/\") {\n        if (typeof message !== \"object\" || message === null) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: null\n        };\n        if (message.jsonrpc !== \"2.0\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid JSON RPC version\"),\n            id: message.id || null\n        };\n        if (!message.method) return {\n            jsonrpc: \"2.0\",\n            error: createError(-32602, \"Method not specified\"),\n            id: message.id || null\n        };\n        if (typeof message.method !== \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600, \"Invalid method name\"),\n            id: message.id || null\n        };\n        if (message.params && typeof message.params === \"string\") return {\n            jsonrpc: \"2.0\",\n            error: createError(-32600),\n            id: message.id || null\n        };\n        if (message.method === \"rpc.on\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            const event_names = Object.keys(this.namespaces[ns].events);\n            for (const name of message.params){\n                const index = event_names.indexOf(name);\n                const namespace = this.namespaces[ns];\n                if (index === -1) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                if (namespace.events[event_names[index]].protected === true && namespace.clients.get(socket_id)[\"_authenticated\"] === false) {\n                    return {\n                        jsonrpc: \"2.0\",\n                        error: createError(-32606),\n                        id: message.id || null\n                    };\n                }\n                const socket_index = namespace.events[event_names[index]].sockets.indexOf(socket_id);\n                if (socket_index >= 0) {\n                    results[name] = \"socket has already been subscribed to event\";\n                    continue;\n                }\n                namespace.events[event_names[index]].sockets.push(socket_id);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.off\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32e3),\n                id: message.id || null\n            };\n            const results = {};\n            for (const name of message.params){\n                if (!this.namespaces[ns].events[name]) {\n                    results[name] = \"provided event invalid\";\n                    continue;\n                }\n                const index = this.namespaces[ns].events[name].sockets.indexOf(socket_id);\n                if (index === -1) {\n                    results[name] = \"not subscribed\";\n                    continue;\n                }\n                this.namespaces[ns].events[name].sockets.splice(index, 1);\n                results[name] = \"ok\";\n            }\n            return {\n                jsonrpc: \"2.0\",\n                result: results,\n                id: message.id || null\n            };\n        } else if (message.method === \"rpc.login\") {\n            if (!message.params) return {\n                jsonrpc: \"2.0\",\n                error: createError(-32604),\n                id: message.id || null\n            };\n        }\n        if (!this.namespaces[ns].rpc_methods[message.method]) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32601),\n                id: message.id || null\n            };\n        }\n        let response = null;\n        if (this.namespaces[ns].rpc_methods[message.method].protected === true && this.namespaces[ns].clients.get(socket_id)[\"_authenticated\"] === false) {\n            return {\n                jsonrpc: \"2.0\",\n                error: createError(-32605),\n                id: message.id || null\n            };\n        }\n        try {\n            response = await this.namespaces[ns].rpc_methods[message.method].fn(message.params, socket_id);\n        } catch (error) {\n            if (!message.id) return;\n            if (error instanceof Error) return {\n                jsonrpc: \"2.0\",\n                error: {\n                    code: -32e3,\n                    message: error.name,\n                    data: error.message\n                },\n                id: message.id\n            };\n            return {\n                jsonrpc: \"2.0\",\n                error,\n                id: message.id\n            };\n        }\n        if (!message.id) return;\n        if (message.method === \"rpc.login\" && response === true) {\n            const s = this.namespaces[ns].clients.get(socket_id);\n            s[\"_authenticated\"] = true;\n            this.namespaces[ns].clients.set(socket_id, s);\n        }\n        return {\n            jsonrpc: \"2.0\",\n            result: response,\n            id: message.id\n        };\n    }\n    /**\n  * Generate a new namespace store.\n  * Also preregister some special namespace methods.\n  * @private\n  * @param {String} name - namespaces identifier\n  * @return {undefined}\n  */ _generateNamespace(name) {\n        this.namespaces[name] = {\n            rpc_methods: {\n                __listMethods: {\n                    fn: ()=>Object.keys(this.namespaces[name].rpc_methods),\n                    protected: false\n                }\n            },\n            clients: /* @__PURE__ */ new Map(),\n            events: {}\n        };\n    }\n};\nvar RPC_ERRORS = /* @__PURE__ */ new Map([\n    [\n        -32e3,\n        \"Event not provided\"\n    ],\n    [\n        -32600,\n        \"Invalid Request\"\n    ],\n    [\n        -32601,\n        \"Method not found\"\n    ],\n    [\n        -32602,\n        \"Invalid params\"\n    ],\n    [\n        -32603,\n        \"Internal error\"\n    ],\n    [\n        -32604,\n        \"Params not found\"\n    ],\n    [\n        -32605,\n        \"Method forbidden\"\n    ],\n    [\n        -32606,\n        \"Event forbidden\"\n    ],\n    [\n        -32700,\n        \"Parse error\"\n    ]\n]);\nfunction createError(code, details) {\n    const error = {\n        code,\n        message: RPC_ERRORS.get(code) || \"Internal Server Error\"\n    };\n    if (details) error[\"data\"] = details;\n    return error;\n}\n// src/index.ts\nvar Client = class extends CommonClient {\n    constructor(address = \"ws://localhost:8080\", { autoconnect = true, reconnect = true, reconnect_interval = 1e3, max_reconnects = 5, ...rest_options } = {}, generate_request_id){\n        super(WebSocket, address, {\n            autoconnect,\n            reconnect,\n            reconnect_interval,\n            max_reconnects,\n            ...rest_options\n        }, generate_request_id);\n    }\n};\n //# sourceMappingURL=index.mjs.map\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQUFvRDtBQUNQO0FBQ2xCO0FBQ0Q7QUFFMUIsOEJBQThCO0FBQzlCLFNBQVNLLFVBQVVDLE9BQU8sRUFBRUMsT0FBTztJQUNqQyxPQUFPLElBQUlQLDBDQUFhQSxDQUFDTSxTQUFTQztBQUNwQztBQUVBLG1CQUFtQjtBQUNuQixJQUFJQyxrQkFBa0I7SUFDcEJDLE9BQU9DLEtBQUssRUFBRTtRQUNaLE9BQU9DLEtBQUtDLFNBQVMsQ0FBQ0Y7SUFDeEI7SUFDQUcsT0FBT0gsS0FBSyxFQUFFO1FBQ1osT0FBT0MsS0FBS0csS0FBSyxDQUFDSjtJQUNwQjtBQUNGO0FBRUEsb0JBQW9CO0FBQ3BCLElBQUlLLGVBQWUsY0FBY2IsdURBQVlBO0lBaUIzQzs7Ozs7Ozs7O0VBU0EsR0FDQWMsWUFBWUMsZ0JBQWdCLEVBQUVYLFVBQVUscUJBQXFCLEVBQUUsRUFDN0RZLGNBQWMsSUFBSSxFQUNsQkMsWUFBWSxJQUFJLEVBQ2hCQyxxQkFBcUIsR0FBRyxFQUN4QkMsaUJBQWlCLENBQUMsRUFDbEIsR0FBR0MsY0FDSixHQUFHLENBQUMsQ0FBQyxFQUFFQyxtQkFBbUIsRUFBRUMsUUFBUSxDQUFFO1FBQ3JDLEtBQUs7UUFDTCxJQUFJLENBQUNQLGdCQUFnQixHQUFHQTtRQUN4QixJQUFJLENBQUNRLEtBQUssR0FBRyxDQUFDO1FBQ2QsSUFBSSxDQUFDQyxNQUFNLEdBQUc7UUFDZCxJQUFJLENBQUNwQixPQUFPLEdBQUdBO1FBQ2YsSUFBSSxDQUFDWSxXQUFXLEdBQUdBO1FBQ25CLElBQUksQ0FBQ1MsS0FBSyxHQUFHO1FBQ2IsSUFBSSxDQUFDUixTQUFTLEdBQUdBO1FBQ2pCLElBQUksQ0FBQ1Msa0JBQWtCLEdBQUcsS0FBSztRQUMvQixJQUFJLENBQUNSLGtCQUFrQixHQUFHQTtRQUMxQixJQUFJLENBQUNDLGNBQWMsR0FBR0E7UUFDdEIs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cy9ycGMtd2Vic29ja2V0cy9kaXN0L2luZGV4Lm1qcz9hZDE0Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBXZWJTb2NrZXRJbXBsLCB7IFdlYlNvY2tldFNlcnZlciB9IGZyb20gJ3dzJztcbmltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ2V2ZW50ZW1pdHRlcjMnO1xuaW1wb3J0IHVybCBmcm9tICdub2RlOnVybCc7XG5pbXBvcnQgeyB2MSB9IGZyb20gJ3V1aWQnO1xuXG4vLyBzcmMvbGliL2NsaWVudC93ZWJzb2NrZXQudHNcbmZ1bmN0aW9uIFdlYlNvY2tldChhZGRyZXNzLCBvcHRpb25zKSB7XG4gIHJldHVybiBuZXcgV2ViU29ja2V0SW1wbChhZGRyZXNzLCBvcHRpb25zKTtcbn1cblxuLy8gc3JjL2xpYi91dGlscy50c1xudmFyIERlZmF1bHREYXRhUGFjayA9IGNsYXNzIHtcbiAgZW5jb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHZhbHVlKTtcbiAgfVxuICBkZWNvZGUodmFsdWUpIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gIH1cbn07XG5cbi8vIHNyYy9saWIvY2xpZW50LnRzXG52YXIgQ29tbW9uQ2xpZW50ID0gY2xhc3MgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBhZGRyZXNzO1xuICBycGNfaWQ7XG4gIHF1ZXVlO1xuICBvcHRpb25zO1xuICBhdXRvY29ubmVjdDtcbiAgcmVhZHk7XG4gIHJlY29ubmVjdDtcbiAgcmVjb25uZWN0X3RpbWVyX2lkO1xuICByZWNvbm5lY3RfaW50ZXJ2YWw7XG4gIG1heF9yZWNvbm5lY3RzO1xuICByZXN0X29wdGlvbnM7XG4gIGN1cnJlbnRfcmVjb25uZWN0cztcbiAgZ2VuZXJhdGVfcmVxdWVzdF9pZDtcbiAgc29ja2V0O1xuICB3ZWJTb2NrZXRGYWN0b3J5O1xuICBkYXRhUGFjaztcbiAgLyoqXG4gICogSW5zdGFudGlhdGUgYSBDbGllbnQgY2xhc3MuXG4gICogQGNvbnN0cnVjdG9yXG4gICogQHBhcmFtIHt3ZWJTb2NrZXRGYWN0b3J5fSB3ZWJTb2NrZXRGYWN0b3J5IC0gZmFjdG9yeSBtZXRob2QgZm9yIFdlYlNvY2tldFxuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gdXJsIHRvIGEgd2Vic29ja2V0IHNlcnZlclxuICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gd3Mgb3B0aW9ucyBvYmplY3Qgd2l0aCByZWNvbm5lY3QgcGFyYW1ldGVyc1xuICAqIEBwYXJhbSB7RnVuY3Rpb259IGdlbmVyYXRlX3JlcXVlc3RfaWQgLSBjdXN0b20gZ2VuZXJhdGlvbiByZXF1ZXN0IElkXG4gICogQHBhcmFtIHtEYXRhUGFja30gZGF0YVBhY2sgLSBkYXRhIHBhY2sgY29udGFpbnMgZW5jb2RlciBhbmQgZGVjb2RlclxuICAqIEByZXR1cm4ge0NvbW1vbkNsaWVudH1cbiAgKi9cbiAgY29uc3RydWN0b3Iod2ViU29ja2V0RmFjdG9yeSwgYWRkcmVzcyA9IFwid3M6Ly9sb2NhbGhvc3Q6ODA4MFwiLCB7XG4gICAgYXV0b2Nvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdCA9IHRydWUsXG4gICAgcmVjb25uZWN0X2ludGVydmFsID0gMWUzLFxuICAgIG1heF9yZWNvbm5lY3RzID0gNSxcbiAgICAuLi5yZXN0X29wdGlvbnNcbiAgfSA9IHt9LCBnZW5lcmF0ZV9yZXF1ZXN0X2lkLCBkYXRhUGFjaykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy53ZWJTb2NrZXRGYWN0b3J5ID0gd2ViU29ja2V0RmFjdG9yeTtcbiAgICB0aGlzLnF1ZXVlID0ge307XG4gICAgdGhpcy5ycGNfaWQgPSAwO1xuICAgIHRoaXMuYWRkcmVzcyA9IGFkZHJlc3M7XG4gICAgdGhpcy5hdXRvY29ubmVjdCA9IGF1dG9jb25uZWN0O1xuICAgIHRoaXMucmVhZHkgPSBmYWxzZTtcbiAgICB0aGlzLnJlY29ubmVjdCA9IHJlY29ubmVjdDtcbiAgICB0aGlzLnJlY29ubmVjdF90aW1lcl9pZCA9IHZvaWQgMDtcbiAgICB0aGlzLnJlY29ubmVjdF9pbnRlcnZhbCA9IHJlY29ubmVjdF9pbnRlcnZhbDtcbiAgICB0aGlzLm1heF9yZWNvbm5lY3RzID0gbWF4X3JlY29ubmVjdHM7XG4gICAgdGhpcy5yZXN0X29wdGlvbnMgPSByZXN0X29wdGlvbnM7XG4gICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPSAwO1xuICAgIHRoaXMuZ2VuZXJhdGVfcmVxdWVzdF9pZCA9IGdlbmVyYXRlX3JlcXVlc3RfaWQgfHwgKCgpID0+IHR5cGVvZiB0aGlzLnJwY19pZCA9PT0gXCJudW1iZXJcIiA/ICsrdGhpcy5ycGNfaWQgOiBOdW1iZXIodGhpcy5ycGNfaWQpICsgMSk7XG4gICAgaWYgKCFkYXRhUGFjaykgdGhpcy5kYXRhUGFjayA9IG5ldyBEZWZhdWx0RGF0YVBhY2soKTtcbiAgICBlbHNlIHRoaXMuZGF0YVBhY2sgPSBkYXRhUGFjaztcbiAgICBpZiAodGhpcy5hdXRvY29ubmVjdClcbiAgICAgIHRoaXMuX2Nvbm5lY3QodGhpcy5hZGRyZXNzLCB7XG4gICAgICAgIGF1dG9jb25uZWN0OiB0aGlzLmF1dG9jb25uZWN0LFxuICAgICAgICByZWNvbm5lY3Q6IHRoaXMucmVjb25uZWN0LFxuICAgICAgICByZWNvbm5lY3RfaW50ZXJ2YWw6IHRoaXMucmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgICBtYXhfcmVjb25uZWN0czogdGhpcy5tYXhfcmVjb25uZWN0cyxcbiAgICAgICAgLi4udGhpcy5yZXN0X29wdGlvbnNcbiAgICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIENvbm5lY3RzIHRvIGEgZGVmaW5lZCBzZXJ2ZXIgaWYgbm90IGNvbm5lY3RlZCBhbHJlYWR5LlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNvbm5lY3QoKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0KSByZXR1cm47XG4gICAgdGhpcy5fY29ubmVjdCh0aGlzLmFkZHJlc3MsIHtcbiAgICAgIGF1dG9jb25uZWN0OiB0aGlzLmF1dG9jb25uZWN0LFxuICAgICAgcmVjb25uZWN0OiB0aGlzLnJlY29ubmVjdCxcbiAgICAgIHJlY29ubmVjdF9pbnRlcnZhbDogdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwsXG4gICAgICBtYXhfcmVjb25uZWN0czogdGhpcy5tYXhfcmVjb25uZWN0cyxcbiAgICAgIC4uLnRoaXMucmVzdF9vcHRpb25zXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogQ2FsbHMgYSByZWdpc3RlcmVkIFJQQyBtZXRob2Qgb24gc2VydmVyLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kIC0gUlBDIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtPYmplY3R8QXJyYXl9IHBhcmFtcyAtIG9wdGlvbmFsIG1ldGhvZCBwYXJhbWV0ZXJzXG4gICogQHBhcmFtIHtOdW1iZXJ9IHRpbWVvdXQgLSBSUEMgcmVwbHkgdGltZW91dCB2YWx1ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSB3c19vcHRzIC0gb3B0aW9ucyBwYXNzZWQgdG8gd3NcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBjYWxsKG1ldGhvZCwgcGFyYW1zLCB0aW1lb3V0LCB3c19vcHRzKSB7XG4gICAgaWYgKCF3c19vcHRzICYmIFwib2JqZWN0XCIgPT09IHR5cGVvZiB0aW1lb3V0KSB7XG4gICAgICB3c19vcHRzID0gdGltZW91dDtcbiAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnJlYWR5KSByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcInNvY2tldCBub3QgcmVhZHlcIikpO1xuICAgICAgY29uc3QgcnBjX2lkID0gdGhpcy5nZW5lcmF0ZV9yZXF1ZXN0X2lkKG1ldGhvZCwgcGFyYW1zKTtcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIG1ldGhvZCxcbiAgICAgICAgcGFyYW1zOiBwYXJhbXMgfHwgdm9pZCAwLFxuICAgICAgICBpZDogcnBjX2lkXG4gICAgICB9O1xuICAgICAgdGhpcy5zb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShtZXNzYWdlKSwgd3Nfb3B0cywgKGVycm9yKSA9PiB7XG4gICAgICAgIGlmIChlcnJvcikgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMucXVldWVbcnBjX2lkXSA9IHsgcHJvbWlzZTogW3Jlc29sdmUsIHJlamVjdF0gfTtcbiAgICAgICAgaWYgKHRpbWVvdXQpIHtcbiAgICAgICAgICB0aGlzLnF1ZXVlW3JwY19pZF0udGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMucXVldWVbcnBjX2lkXTtcbiAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXBseSB0aW1lb3V0XCIpKTtcbiAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogTG9naW5zIHdpdGggdGhlIG90aGVyIHNpZGUgb2YgdGhlIGNvbm5lY3Rpb24uXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBMb2dpbiBjcmVkZW50aWFscyBvYmplY3RcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBhc3luYyBsb2dpbihwYXJhbXMpIHtcbiAgICBjb25zdCByZXNwID0gYXdhaXQgdGhpcy5jYWxsKFwicnBjLmxvZ2luXCIsIHBhcmFtcyk7XG4gICAgaWYgKCFyZXNwKSB0aHJvdyBuZXcgRXJyb3IoXCJhdXRoZW50aWNhdGlvbiBmYWlsZWRcIik7XG4gICAgcmV0dXJuIHJlc3A7XG4gIH1cbiAgLyoqXG4gICogRmV0Y2hlcyBhIGxpc3Qgb2YgY2xpZW50J3MgbWV0aG9kcyByZWdpc3RlcmVkIG9uIHNlcnZlci5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7QXJyYXl9XG4gICovXG4gIGFzeW5jIGxpc3RNZXRob2RzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLmNhbGwoXCJfX2xpc3RNZXRob2RzXCIpO1xuICB9XG4gIC8qKlxuICAqIFNlbmRzIGEgSlNPTi1SUEMgMi4wIG5vdGlmaWNhdGlvbiB0byBzZXJ2ZXIuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBtZXRob2QgLSBSUEMgbWV0aG9kIG5hbWVcbiAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gb3B0aW9uYWwgbWV0aG9kIHBhcmFtZXRlcnNcbiAgKiBAcmV0dXJuIHtQcm9taXNlfVxuICAqL1xuICBub3RpZnkobWV0aG9kLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLnJlYWR5KSByZXR1cm4gcmVqZWN0KG5ldyBFcnJvcihcInNvY2tldCBub3QgcmVhZHlcIikpO1xuICAgICAgY29uc3QgbWVzc2FnZSA9IHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgbWV0aG9kLFxuICAgICAgICBwYXJhbXNcbiAgICAgIH07XG4gICAgICB0aGlzLnNvY2tldC5zZW5kKHRoaXMuZGF0YVBhY2suZW5jb2RlKG1lc3NhZ2UpLCAoZXJyb3IpID0+IHtcbiAgICAgICAgaWYgKGVycm9yKSByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogU3Vic2NyaWJlcyBmb3IgYSBkZWZpbmVkIGV2ZW50LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZXZlbnQgLSBldmVudCBuYW1lXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqIEB0aHJvd3Mge0Vycm9yfVxuICAqL1xuICBhc3luYyBzdWJzY3JpYmUoZXZlbnQpIHtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiKSBldmVudCA9IFtldmVudF07XG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgdGhpcy5jYWxsKFwicnBjLm9uXCIsIGV2ZW50KTtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiICYmIHJlc3VsdFtldmVudF0gIT09IFwib2tcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgXCJGYWlsZWQgc3Vic2NyaWJpbmcgdG8gYW4gZXZlbnQgJ1wiICsgZXZlbnQgKyBcIicgd2l0aDogXCIgKyByZXN1bHRbZXZlbnRdXG4gICAgICApO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICogVW5zdWJzY3JpYmVzIGZyb20gYSBkZWZpbmVkIGV2ZW50LlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ3xBcnJheX0gZXZlbnQgLSBldmVudCBuYW1lXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqIEB0aHJvd3Mge0Vycm9yfVxuICAqL1xuICBhc3luYyB1bnN1YnNjcmliZShldmVudCkge1xuICAgIGlmICh0eXBlb2YgZXZlbnQgPT09IFwic3RyaW5nXCIpIGV2ZW50ID0gW2V2ZW50XTtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB0aGlzLmNhbGwoXCJycGMub2ZmXCIsIGV2ZW50KTtcbiAgICBpZiAodHlwZW9mIGV2ZW50ID09PSBcInN0cmluZ1wiICYmIHJlc3VsdFtldmVudF0gIT09IFwib2tcIilcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB1bnN1YnNjcmliaW5nIGZyb20gYW4gZXZlbnQgd2l0aDogXCIgKyByZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgLyoqXG4gICogQ2xvc2VzIGEgV2ViU29ja2V0IGNvbm5lY3Rpb24gZ3JhY2VmdWxseS5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IGNvZGUgLSBzb2NrZXQgY2xvc2UgY29kZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBkYXRhIC0gb3B0aW9uYWwgZGF0YSB0byBiZSBzZW50IGJlZm9yZSBjbG9zaW5nXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBjbG9zZShjb2RlLCBkYXRhKSB7XG4gICAgaWYgKHRoaXMuc29ja2V0KSB0aGlzLnNvY2tldC5jbG9zZShjb2RlIHx8IDFlMywgZGF0YSk7XG4gIH1cbiAgLyoqXG4gICogRW5hYmxlIC8gZGlzYWJsZSBhdXRvbWF0aWMgcmVjb25uZWN0aW9uLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge0Jvb2xlYW59IHJlY29ubmVjdCAtIGVuYWJsZSAvIGRpc2FibGUgcmVjb25uZWN0aW9uXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBzZXRBdXRvUmVjb25uZWN0KHJlY29ubmVjdCkge1xuICAgIHRoaXMucmVjb25uZWN0ID0gcmVjb25uZWN0O1xuICB9XG4gIC8qKlxuICAqIFNldCB0aGUgaW50ZXJ2YWwgYmV0d2VlbiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBpbnRlcnZhbCAtIHJlY29ubmVjdGlvbiBpbnRlcnZhbCBpbiBtaWxsaXNlY29uZHNcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldFJlY29ubmVjdEludGVydmFsKGludGVydmFsKSB7XG4gICAgdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWwgPSBpbnRlcnZhbDtcbiAgfVxuICAvKipcbiAgKiBTZXQgdGhlIG1heGltdW0gbnVtYmVyIG9mIHJlY29ubmVjdGlvbiBhdHRlbXB0cy5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtOdW1iZXJ9IG1heF9yZWNvbm5lY3RzIC0gbWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIHNldE1heFJlY29ubmVjdHMobWF4X3JlY29ubmVjdHMpIHtcbiAgICB0aGlzLm1heF9yZWNvbm5lY3RzID0gbWF4X3JlY29ubmVjdHM7XG4gIH1cbiAgLyoqXG4gICogR2V0IHRoZSBjdXJyZW50IG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMgbWFkZS5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7TnVtYmVyfSBjdXJyZW50IHJlY29ubmVjdGlvbiBhdHRlbXB0c1xuICAqL1xuICBnZXRDdXJyZW50UmVjb25uZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5jdXJyZW50X3JlY29ubmVjdHM7XG4gIH1cbiAgLyoqXG4gICogR2V0IHRoZSBtYXhpbXVtIG51bWJlciBvZiByZWNvbm5lY3Rpb24gYXR0ZW1wdHMuXG4gICogQG1ldGhvZFxuICAqIEByZXR1cm4ge051bWJlcn0gbWF4aW11bSByZWNvbm5lY3Rpb24gYXR0ZW1wdHNcbiAgKi9cbiAgZ2V0TWF4UmVjb25uZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhfcmVjb25uZWN0cztcbiAgfVxuICAvKipcbiAgKiBDaGVjayBpZiB0aGUgY2xpZW50IGlzIGN1cnJlbnRseSBhdHRlbXB0aW5nIHRvIHJlY29ubmVjdC5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7Qm9vbGVhbn0gdHJ1ZSBpZiByZWNvbm5lY3Rpb24gaXMgaW4gcHJvZ3Jlc3NcbiAgKi9cbiAgaXNSZWNvbm5lY3RpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMucmVjb25uZWN0X3RpbWVyX2lkICE9PSB2b2lkIDA7XG4gIH1cbiAgLyoqXG4gICogQ2hlY2sgaWYgdGhlIGNsaWVudCB3aWxsIGF0dGVtcHQgdG8gcmVjb25uZWN0IG9uIHRoZSBuZXh0IGNsb3NlIGV2ZW50LlxuICAqIEBtZXRob2RcbiAgKiBAcmV0dXJuIHtCb29sZWFufSB0cnVlIGlmIHJlY29ubmVjdGlvbiB3aWxsIGJlIGF0dGVtcHRlZFxuICAqL1xuICB3aWxsUmVjb25uZWN0KCkge1xuICAgIHJldHVybiB0aGlzLnJlY29ubmVjdCAmJiAodGhpcy5tYXhfcmVjb25uZWN0cyA9PT0gMCB8fCB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyA8IHRoaXMubWF4X3JlY29ubmVjdHMpO1xuICB9XG4gIC8qKlxuICAqIENvbm5lY3Rpb24vTWVzc2FnZSBoYW5kbGVyLlxuICAqIEBtZXRob2RcbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBhZGRyZXNzIC0gV2ViU29ja2V0IEFQSSBhZGRyZXNzXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBvcHRpb25zIG9iamVjdFxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucykge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdF90aW1lcl9pZCk7XG4gICAgdGhpcy5zb2NrZXQgPSB0aGlzLndlYlNvY2tldEZhY3RvcnkoYWRkcmVzcywgb3B0aW9ucyk7XG4gICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgKCkgPT4ge1xuICAgICAgdGhpcy5yZWFkeSA9IHRydWU7XG4gICAgICB0aGlzLmVtaXQoXCJvcGVuXCIpO1xuICAgICAgdGhpcy5jdXJyZW50X3JlY29ubmVjdHMgPSAwO1xuICAgIH0pO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsICh7IGRhdGE6IG1lc3NhZ2UgfSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2UgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcilcbiAgICAgICAgbWVzc2FnZSA9IEJ1ZmZlci5mcm9tKG1lc3NhZ2UpLnRvU3RyaW5nKCk7XG4gICAgICB0cnkge1xuICAgICAgICBtZXNzYWdlID0gdGhpcy5kYXRhUGFjay5kZWNvZGUobWVzc2FnZSk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAobWVzc2FnZS5ub3RpZmljYXRpb24gJiYgdGhpcy5saXN0ZW5lcnMobWVzc2FnZS5ub3RpZmljYXRpb24pLmxlbmd0aCkge1xuICAgICAgICBpZiAoIU9iamVjdC5rZXlzKG1lc3NhZ2UucGFyYW1zKS5sZW5ndGgpXG4gICAgICAgICAgcmV0dXJuIHRoaXMuZW1pdChtZXNzYWdlLm5vdGlmaWNhdGlvbik7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBbbWVzc2FnZS5ub3RpZmljYXRpb25dO1xuICAgICAgICBpZiAobWVzc2FnZS5wYXJhbXMuY29uc3RydWN0b3IgPT09IE9iamVjdCkgYXJncy5wdXNoKG1lc3NhZ2UucGFyYW1zKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWVzc2FnZS5wYXJhbXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICBhcmdzLnB1c2gobWVzc2FnZS5wYXJhbXNbaV0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgdGhpcy5lbWl0LmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5xdWV1ZVttZXNzYWdlLmlkXSkge1xuICAgICAgICBpZiAobWVzc2FnZS5tZXRob2QpIHtcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQobWVzc2FnZS5tZXRob2QsIG1lc3NhZ2U/LnBhcmFtcyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKFwiZXJyb3JcIiBpbiBtZXNzYWdlID09PSBcInJlc3VsdFwiIGluIG1lc3NhZ2UpXG4gICAgICAgIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVsxXShcbiAgICAgICAgICBuZXcgRXJyb3IoXG4gICAgICAgICAgICAnU2VydmVyIHJlc3BvbnNlIG1hbGZvcm1lZC4gUmVzcG9uc2UgbXVzdCBpbmNsdWRlIGVpdGhlciBcInJlc3VsdFwiIG9yIFwiZXJyb3JcIiwgYnV0IG5vdCBib3RoLidcbiAgICAgICAgICApXG4gICAgICAgICk7XG4gICAgICBpZiAodGhpcy5xdWV1ZVttZXNzYWdlLmlkXS50aW1lb3V0KVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5xdWV1ZVttZXNzYWdlLmlkXS50aW1lb3V0KTtcbiAgICAgIGlmIChtZXNzYWdlLmVycm9yKSB0aGlzLnF1ZXVlW21lc3NhZ2UuaWRdLnByb21pc2VbMV0obWVzc2FnZS5lcnJvcik7XG4gICAgICBlbHNlIHRoaXMucXVldWVbbWVzc2FnZS5pZF0ucHJvbWlzZVswXShtZXNzYWdlLnJlc3VsdCk7XG4gICAgICBkZWxldGUgdGhpcy5xdWV1ZVttZXNzYWdlLmlkXTtcbiAgICB9KTtcbiAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCAoeyBjb2RlLCByZWFzb24gfSkgPT4ge1xuICAgICAgaWYgKHRoaXMucmVhZHkpXG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5lbWl0KFwiY2xvc2VcIiwgY29kZSwgcmVhc29uKSwgMCk7XG4gICAgICB0aGlzLnJlYWR5ID0gZmFsc2U7XG4gICAgICB0aGlzLnNvY2tldCA9IHZvaWQgMDtcbiAgICAgIGlmIChjb2RlID09PSAxZTMpIHJldHVybjtcbiAgICAgIHRoaXMuY3VycmVudF9yZWNvbm5lY3RzKys7XG4gICAgICBpZiAodGhpcy5yZWNvbm5lY3QgJiYgKHRoaXMubWF4X3JlY29ubmVjdHMgPiB0aGlzLmN1cnJlbnRfcmVjb25uZWN0cyB8fCB0aGlzLm1heF9yZWNvbm5lY3RzID09PSAwKSlcbiAgICAgICAgdGhpcy5yZWNvbm5lY3RfdGltZXJfaWQgPSBzZXRUaW1lb3V0KFxuICAgICAgICAgICgpID0+IHRoaXMuX2Nvbm5lY3QoYWRkcmVzcywgb3B0aW9ucyksXG4gICAgICAgICAgdGhpcy5yZWNvbm5lY3RfaW50ZXJ2YWxcbiAgICAgICAgKTtcbiAgICAgIGVsc2UgaWYgKHRoaXMucmVjb25uZWN0ICYmIHRoaXMubWF4X3JlY29ubmVjdHMgPiAwICYmIHRoaXMuY3VycmVudF9yZWNvbm5lY3RzID49IHRoaXMubWF4X3JlY29ubmVjdHMpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB0aGlzLmVtaXQoXCJtYXhfcmVjb25uZWN0c19yZWFjaGVkXCIsIGNvZGUsIHJlYXNvbiksIDEpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59O1xudmFyIFNlcnZlciA9IGNsYXNzIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgbmFtZXNwYWNlcztcbiAgZGF0YVBhY2s7XG4gIHdzcztcbiAgLyoqXG4gICogSW5zdGFudGlhdGUgYSBTZXJ2ZXIgY2xhc3MuXG4gICogQGNvbnN0cnVjdG9yXG4gICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSB3cyBjb25zdHJ1Y3RvcidzIHBhcmFtZXRlcnMgd2l0aCBycGNcbiAgKiBAcGFyYW0ge0RhdGFQYWNrfSBkYXRhUGFjayAtIGRhdGEgcGFjayBjb250YWlucyBlbmNvZGVyIGFuZCBkZWNvZGVyXG4gICogQHJldHVybiB7U2VydmVyfSAtIHJldHVybnMgYSBuZXcgU2VydmVyIGluc3RhbmNlXG4gICovXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMsIGRhdGFQYWNrKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm5hbWVzcGFjZXMgPSB7fTtcbiAgICBpZiAoIWRhdGFQYWNrKSB0aGlzLmRhdGFQYWNrID0gbmV3IERlZmF1bHREYXRhUGFjaygpO1xuICAgIGVsc2UgdGhpcy5kYXRhUGFjayA9IGRhdGFQYWNrO1xuICAgIHRoaXMud3NzID0gbmV3IFdlYlNvY2tldFNlcnZlcihvcHRpb25zKTtcbiAgICB0aGlzLndzcy5vbihcImxpc3RlbmluZ1wiLCAoKSA9PiB0aGlzLmVtaXQoXCJsaXN0ZW5pbmdcIikpO1xuICAgIHRoaXMud3NzLm9uKFwiY29ubmVjdGlvblwiLCAoc29ja2V0LCByZXF1ZXN0KSA9PiB7XG4gICAgICBjb25zdCB1ID0gdXJsLnBhcnNlKHJlcXVlc3QudXJsLCB0cnVlKTtcbiAgICAgIGNvbnN0IG5zID0gdS5wYXRobmFtZTtcbiAgICAgIGlmICh1LnF1ZXJ5LnNvY2tldF9pZCkgc29ja2V0Ll9pZCA9IHUucXVlcnkuc29ja2V0X2lkO1xuICAgICAgZWxzZSBzb2NrZXQuX2lkID0gdjEoKTtcbiAgICAgIHNvY2tldFtcIl9hdXRoZW50aWNhdGVkXCJdID0gZmFsc2U7XG4gICAgICBzb2NrZXQub24oXCJlcnJvclwiLCAoZXJyb3IpID0+IHRoaXMuZW1pdChcInNvY2tldC1lcnJvclwiLCBzb2NrZXQsIGVycm9yKSk7XG4gICAgICBzb2NrZXQub24oXCJjbG9zZVwiLCAoKSA9PiB7XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5kZWxldGUoc29ja2V0Ll9pZCk7XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpKSB7XG4gICAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tldmVudF0uc29ja2V0cy5pbmRleE9mKFxuICAgICAgICAgICAgc29ja2V0Ll9pZFxuICAgICAgICAgICk7XG4gICAgICAgICAgaWYgKGluZGV4ID49IDApXG4gICAgICAgICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tldmVudF0uc29ja2V0cy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdChcImRpc2Nvbm5lY3Rpb25cIiwgc29ja2V0KTtcbiAgICAgIH0pO1xuICAgICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuc2V0KHNvY2tldC5faWQsIHNvY2tldCk7XG4gICAgICB0aGlzLmVtaXQoXCJjb25uZWN0aW9uXCIsIHNvY2tldCwgcmVxdWVzdCk7XG4gICAgICByZXR1cm4gdGhpcy5faGFuZGxlUlBDKHNvY2tldCwgbnMpO1xuICAgIH0pO1xuICAgIHRoaXMud3NzLm9uKFwiZXJyb3JcIiwgKGVycm9yKSA9PiB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICB9XG4gIC8qKlxuICAqIFJlZ2lzdGVycyBhbiBSUEMgbWV0aG9kLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gLSBhIGNhbGxlZSBmdW5jdGlvblxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5zIGFuIElNZXRob2Qgb2JqZWN0XG4gICovXG4gIHJlZ2lzdGVyKG5hbWUsIGZuLCBucyA9IFwiL1wiKSB7XG4gICAgaWYgKCF0aGlzLm5hbWVzcGFjZXNbbnNdKSB0aGlzLl9nZW5lcmF0ZU5hbWVzcGFjZShucyk7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1tuYW1lXSA9IHtcbiAgICAgIGZuLFxuICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgIHByb3RlY3RlZDogKCkgPT4gdGhpcy5fbWFrZVByb3RlY3RlZE1ldGhvZChuYW1lLCBucyksXG4gICAgICBwdWJsaWM6ICgpID0+IHRoaXMuX21ha2VQdWJsaWNNZXRob2QobmFtZSwgbnMpXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBTZXRzIGFuIGF1dGggbWV0aG9kLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIGFuIGFyYml0cmFyeSBhdXRoIG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgc2V0QXV0aChmbiwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMucmVnaXN0ZXIoXCJycGMubG9naW5cIiwgZm4sIG5zKTtcbiAgfVxuICAvKipcbiAgKiBNYXJrcyBhbiBSUEMgbWV0aG9kIGFzIHByb3RlY3RlZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBtZXRob2QgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfbWFrZVByb3RlY3RlZE1ldGhvZChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1tuYW1lXS5wcm90ZWN0ZWQgPSB0cnVlO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIFJQQyBtZXRob2QgYXMgcHVibGljLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG1ldGhvZCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHVibGljTWV0aG9kKG5hbWUsIG5zID0gXCIvXCIpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLnJwY19tZXRob2RzW25hbWVdLnByb3RlY3RlZCA9IGZhbHNlO1xuICB9XG4gIC8qKlxuICAqIE1hcmtzIGFuIGV2ZW50IGFzIHByb3RlY3RlZC5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5hbWUgLSBldmVudCBuYW1lXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIF9tYWtlUHJvdGVjdGVkRXZlbnQobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnByb3RlY3RlZCA9IHRydWU7XG4gIH1cbiAgLyoqXG4gICogTWFya3MgYW4gZXZlbnQgYXMgcHVibGljLlxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIGV2ZW50IG5hbWVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgKi9cbiAgX21ha2VQdWJsaWNFdmVudChuYW1lLCBucyA9IFwiL1wiKSB7XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0ucHJvdGVjdGVkID0gZmFsc2U7XG4gIH1cbiAgLyoqXG4gICogUmVtb3ZlcyBhIG5hbWVzcGFjZSBhbmQgY2xvc2VzIGFsbCBjb25uZWN0aW9uc1xuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2UgaWRlbnRpZmllclxuICAqIEB0aHJvd3Mge1R5cGVFcnJvcn1cbiAgKiBAcmV0dXJuIHtVbmRlZmluZWR9XG4gICovXG4gIGNsb3NlTmFtZXNwYWNlKG5zKSB7XG4gICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICBpZiAobmFtZXNwYWNlKSB7XG4gICAgICBkZWxldGUgbmFtZXNwYWNlLnJwY19tZXRob2RzO1xuICAgICAgZGVsZXRlIG5hbWVzcGFjZS5ldmVudHM7XG4gICAgICBmb3IgKGNvbnN0IHNvY2tldCBvZiBuYW1lc3BhY2UuY2xpZW50cy52YWx1ZXMoKSkgc29ja2V0LmNsb3NlKCk7XG4gICAgICBkZWxldGUgdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICB9XG4gIH1cbiAgLyoqXG4gICogQ3JlYXRlcyBhIG5ldyBldmVudCB0aGF0IGNhbiBiZSBlbWl0dGVkIHRvIGNsaWVudHMuXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lIC0gZXZlbnQgbmFtZVxuICAqIEBwYXJhbSB7U3RyaW5nfSBucyAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSByZXR1cm5zIGFuIElFdmVudCBvYmplY3RcbiAgKi9cbiAgZXZlbnQobmFtZSwgbnMgPSBcIi9cIikge1xuICAgIGlmICghdGhpcy5uYW1lc3BhY2VzW25zXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobnMpO1xuICAgIGVsc2Uge1xuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXTtcbiAgICAgIGlmIChpbmRleCAhPT0gdm9pZCAwKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEFscmVhZHkgcmVnaXN0ZXJlZCBldmVudCAke25zfSR7bmFtZX1gKTtcbiAgICB9XG4gICAgdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0gPSB7XG4gICAgICBzb2NrZXRzOiBbXSxcbiAgICAgIHByb3RlY3RlZDogZmFsc2VcbiAgICB9O1xuICAgIHRoaXMub24obmFtZSwgKC4uLnBhcmFtcykgPT4ge1xuICAgICAgaWYgKHBhcmFtcy5sZW5ndGggPT09IDEgJiYgcGFyYW1zWzBdIGluc3RhbmNlb2YgT2JqZWN0KVxuICAgICAgICBwYXJhbXMgPSBwYXJhbXNbMF07XG4gICAgICBmb3IgKGNvbnN0IHNvY2tldF9pZCBvZiB0aGlzLm5hbWVzcGFjZXNbbnNdLmV2ZW50c1tuYW1lXS5zb2NrZXRzKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldCA9IHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKTtcbiAgICAgICAgaWYgKCFzb2NrZXQpIGNvbnRpbnVlO1xuICAgICAgICBzb2NrZXQuc2VuZChcbiAgICAgICAgICB0aGlzLmRhdGFQYWNrLmVuY29kZSh7XG4gICAgICAgICAgICBub3RpZmljYXRpb246IG5hbWUsXG4gICAgICAgICAgICBwYXJhbXNcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICBwcm90ZWN0ZWQ6ICgpID0+IHRoaXMuX21ha2VQcm90ZWN0ZWRFdmVudChuYW1lLCBucyksXG4gICAgICBwdWJsaWM6ICgpID0+IHRoaXMuX21ha2VQdWJsaWNFdmVudChuYW1lLCBucylcbiAgICB9O1xuICB9XG4gIC8qKlxuICAqIFJldHVybnMgYSByZXF1ZXN0ZWQgbmFtZXNwYWNlIG9iamVjdFxuICAqIEBtZXRob2RcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVzcGFjZSBpZGVudGlmaWVyXG4gICogQHRocm93cyB7VHlwZUVycm9yfVxuICAqIEByZXR1cm4ge09iamVjdH0gLSBuYW1lc3BhY2Ugb2JqZWN0XG4gICovXG4gIG9mKG5hbWUpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuYW1lXSkgdGhpcy5fZ2VuZXJhdGVOYW1lc3BhY2UobmFtZSk7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgcmV0dXJuIHtcbiAgICAgIC8vIHNlbGYucmVnaXN0ZXIgY29udmVuaWVuY2UgbWV0aG9kXG4gICAgICByZWdpc3Rlcihmbl9uYW1lLCBmbikge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHByb3ZpZGUgZXhhY3RseSB0d28gYXJndW1lbnRzXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZuX25hbWUgIT09IFwic3RyaW5nXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibmFtZSBtdXN0IGJlIGEgc3RyaW5nXCIpO1xuICAgICAgICBpZiAodHlwZW9mIGZuICE9PSBcImZ1bmN0aW9uXCIpXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaGFuZGxlciBtdXN0IGJlIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIHJldHVybiBzZWxmLnJlZ2lzdGVyKGZuX25hbWUsIGZuLCBuYW1lKTtcbiAgICAgIH0sXG4gICAgICAvLyBzZWxmLmV2ZW50IGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAgZXZlbnQoZXZfbmFtZSkge1xuICAgICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCAhPT0gMSlcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJtdXN0IHByb3ZpZGUgZXhhY3RseSBvbmUgYXJndW1lbnRcIik7XG4gICAgICAgIGlmICh0eXBlb2YgZXZfbmFtZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJuYW1lIG11c3QgYmUgYSBzdHJpbmdcIik7XG4gICAgICAgIHJldHVybiBzZWxmLmV2ZW50KGV2X25hbWUsIG5hbWUpO1xuICAgICAgfSxcbiAgICAgIC8vIHNlbGYuZXZlbnRMaXN0IGNvbnZlbmllbmNlIG1ldGhvZFxuICAgICAgZ2V0IGV2ZW50TGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHNlbGYubmFtZXNwYWNlc1tuYW1lXS5ldmVudHMpO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBFbWl0cyBhIHNwZWNpZmllZCBldmVudCB0byB0aGlzIG5hbWVzcGFjZS5cbiAgICAgICogQGlubmVyXG4gICAgICAqIEBtZXRob2RcbiAgICAgICogQHBhcmFtIHtTdHJpbmd9IGV2ZW50IC0gZXZlbnQgbmFtZVxuICAgICAgKiBAcGFyYW0ge0FycmF5fSBwYXJhbXMgLSBldmVudCBwYXJhbWV0ZXJzXG4gICAgICAqIEByZXR1cm4ge1VuZGVmaW5lZH1cbiAgICAgICovXG4gICAgICBlbWl0KGV2ZW50LCAuLi5wYXJhbXMpIHtcbiAgICAgICAgY29uc3QgbnNFdmVudCA9IHNlbGYubmFtZXNwYWNlc1tuYW1lXS5ldmVudHNbZXZlbnRdO1xuICAgICAgICBpZiAobnNFdmVudClcbiAgICAgICAgICBmb3IgKGNvbnN0IHNvY2tldF9pZCBvZiBuc0V2ZW50LnNvY2tldHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvY2tldCA9IHNlbGYubmFtZXNwYWNlc1tuYW1lXS5jbGllbnRzLmdldChzb2NrZXRfaWQpO1xuICAgICAgICAgICAgaWYgKCFzb2NrZXQpIGNvbnRpbnVlO1xuICAgICAgICAgICAgc29ja2V0LnNlbmQoXG4gICAgICAgICAgICAgIHNlbGYuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgICAgICBub3RpZmljYXRpb246IGV2ZW50LFxuICAgICAgICAgICAgICAgIHBhcmFtc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBuYW1lIG9mIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAa2luZCBjb25zdGFudFxuICAgICAgKiBAcmV0dXJuIHtTdHJpbmd9XG4gICAgICAqL1xuICAgICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgfSxcbiAgICAgIC8qKlxuICAgICAgKiBSZXR1cm5zIGEgaGFzaCBvZiB3ZWJzb2NrZXQgb2JqZWN0cyBjb25uZWN0ZWQgdG8gdGhpcyBuYW1lc3BhY2UuXG4gICAgICAqIEBpbm5lclxuICAgICAgKiBAbWV0aG9kXG4gICAgICAqIEByZXR1cm4ge09iamVjdH1cbiAgICAgICovXG4gICAgICBjb25uZWN0ZWQoKSB7XG4gICAgICAgIGNvbnN0IHNvY2tldF9pZHMgPSBbLi4uc2VsZi5uYW1lc3BhY2VzW25hbWVdLmNsaWVudHMua2V5cygpXTtcbiAgICAgICAgcmV0dXJuIHNvY2tldF9pZHMucmVkdWNlKFxuICAgICAgICAgIChhY2MsIGN1cnIpID0+ICh7XG4gICAgICAgICAgICAuLi5hY2MsXG4gICAgICAgICAgICBbY3Vycl06IHNlbGYubmFtZXNwYWNlc1tuYW1lXS5jbGllbnRzLmdldChjdXJyKVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHt9XG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgLyoqXG4gICAgICAqIFJldHVybnMgYSBsaXN0IG9mIGNsaWVudCB1bmlxdWUgaWRlbnRpZmllcnMgY29ubmVjdGVkIHRvIHRoaXMgbmFtZXNwYWNlLlxuICAgICAgKiBAaW5uZXJcbiAgICAgICogQG1ldGhvZFxuICAgICAgKiBAcmV0dXJuIHtBcnJheX1cbiAgICAgICovXG4gICAgICBjbGllbnRzKCkge1xuICAgICAgICByZXR1cm4gc2VsZi5uYW1lc3BhY2VzW25hbWVdO1xuICAgICAgfVxuICAgIH07XG4gIH1cbiAgLyoqXG4gICogTGlzdHMgYWxsIGNyZWF0ZWQgZXZlbnRzIGluIGEgZ2l2ZW4gbmFtZXNwYWNlLiBEZWZhdWx0cyB0byBcIi9cIi5cbiAgKiBAbWV0aG9kXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJlYWRvbmx5XG4gICogQHJldHVybiB7QXJyYXl9IC0gcmV0dXJucyBhIGxpc3Qgb2YgY3JlYXRlZCBldmVudHNcbiAgKi9cbiAgZXZlbnRMaXN0KG5zID0gXCIvXCIpIHtcbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10pIHJldHVybiBbXTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpO1xuICB9XG4gIC8qKlxuICAqIENyZWF0ZXMgYSBKU09OLVJQQyAyLjAgY29tcGxpYW50IGVycm9yXG4gICogQG1ldGhvZFxuICAqIEBwYXJhbSB7TnVtYmVyfSBjb2RlIC0gaW5kaWNhdGVzIHRoZSBlcnJvciB0eXBlIHRoYXQgb2NjdXJyZWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gbWVzc2FnZSAtIHByb3ZpZGVzIGEgc2hvcnQgZGVzY3JpcHRpb24gb2YgdGhlIGVycm9yXG4gICogQHBhcmFtIHtTdHJpbmd8T2JqZWN0fSBkYXRhIC0gZGV0YWlscyBjb250YWluaW5nIGFkZGl0aW9uYWwgaW5mb3JtYXRpb24gYWJvdXQgdGhlIGVycm9yXG4gICogQHJldHVybiB7T2JqZWN0fVxuICAqL1xuICBjcmVhdGVFcnJvcihjb2RlLCBtZXNzYWdlLCBkYXRhKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNvZGUsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZGF0YTogZGF0YSB8fCBudWxsXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBDbG9zZXMgdGhlIHNlcnZlciBhbmQgdGVybWluYXRlcyBhbGwgY2xpZW50cy5cbiAgKiBAbWV0aG9kXG4gICogQHJldHVybiB7UHJvbWlzZX1cbiAgKi9cbiAgY2xvc2UoKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRoaXMud3NzLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdChcImNsb3NlXCIpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIC8qKlxuICAqIEhhbmRsZXMgYWxsIFdlYlNvY2tldCBKU09OIFJQQyAyLjAgcmVxdWVzdHMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge09iamVjdH0gc29ja2V0IC0gd3Mgc29ja2V0IGluc3RhbmNlXG4gICogQHBhcmFtIHtTdHJpbmd9IG5zIC0gbmFtZXNwYWNlcyBpZGVudGlmaWVyXG4gICogQHJldHVybiB7VW5kZWZpbmVkfVxuICAqL1xuICBfaGFuZGxlUlBDKHNvY2tldCwgbnMgPSBcIi9cIikge1xuICAgIHNvY2tldC5vbihcIm1lc3NhZ2VcIiwgYXN5bmMgKGRhdGEpID0+IHtcbiAgICAgIGNvbnN0IG1zZ19vcHRpb25zID0ge307XG4gICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIG1zZ19vcHRpb25zLmJpbmFyeSA9IHRydWU7XG4gICAgICAgIGRhdGEgPSBCdWZmZXIuZnJvbShkYXRhKS50b1N0cmluZygpO1xuICAgICAgfVxuICAgICAgaWYgKHNvY2tldC5yZWFkeVN0YXRlICE9PSAxKSByZXR1cm47XG4gICAgICBsZXQgcGFyc2VkRGF0YTtcbiAgICAgIHRyeSB7XG4gICAgICAgIHBhcnNlZERhdGEgPSB0aGlzLmRhdGFQYWNrLmRlY29kZShkYXRhKTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBzb2NrZXQuc2VuZChcbiAgICAgICAgICB0aGlzLmRhdGFQYWNrLmVuY29kZSh7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjcwMCwgZXJyb3IudG9TdHJpbmcoKSksXG4gICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgIH0pLFxuICAgICAgICAgIG1zZ19vcHRpb25zXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShwYXJzZWREYXRhKSkge1xuICAgICAgICBpZiAoIXBhcnNlZERhdGEubGVuZ3RoKVxuICAgICAgICAgIHJldHVybiBzb2NrZXQuc2VuZChcbiAgICAgICAgICAgIHRoaXMuZGF0YVBhY2suZW5jb2RlKHtcbiAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCwgXCJJbnZhbGlkIGFycmF5XCIpLFxuICAgICAgICAgICAgICBpZDogbnVsbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBtc2dfb3B0aW9uc1xuICAgICAgICAgICk7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcGFyc2VkRGF0YSkge1xuICAgICAgICAgIGNvbnN0IHJlc3BvbnNlMiA9IGF3YWl0IHRoaXMuX3J1bk1ldGhvZChtZXNzYWdlLCBzb2NrZXQuX2lkLCBucyk7XG4gICAgICAgICAgaWYgKCFyZXNwb25zZTIpIGNvbnRpbnVlO1xuICAgICAgICAgIHJlc3BvbnNlcy5wdXNoKHJlc3BvbnNlMik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXNwb25zZXMubGVuZ3RoKSByZXR1cm47XG4gICAgICAgIHJldHVybiBzb2NrZXQuc2VuZCh0aGlzLmRhdGFQYWNrLmVuY29kZShyZXNwb25zZXMpLCBtc2dfb3B0aW9ucyk7XG4gICAgICB9XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHRoaXMuX3J1bk1ldGhvZChwYXJzZWREYXRhLCBzb2NrZXQuX2lkLCBucyk7XG4gICAgICBpZiAoIXJlc3BvbnNlKSByZXR1cm47XG4gICAgICByZXR1cm4gc29ja2V0LnNlbmQodGhpcy5kYXRhUGFjay5lbmNvZGUocmVzcG9uc2UpLCBtc2dfb3B0aW9ucyk7XG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gICogUnVucyBhIGRlZmluZWQgUlBDIG1ldGhvZC5cbiAgKiBAcHJpdmF0ZVxuICAqIEBwYXJhbSB7T2JqZWN0fSBtZXNzYWdlIC0gYSBtZXNzYWdlIHJlY2VpdmVkXG4gICogQHBhcmFtIHtPYmplY3R9IHNvY2tldF9pZCAtIHVzZXIncyBzb2NrZXQgaWRcbiAgKiBAcGFyYW0ge1N0cmluZ30gbnMgLSBuYW1lc3BhY2VzIGlkZW50aWZpZXJcbiAgKiBAcmV0dXJuIHtPYmplY3R8dW5kZWZpbmVkfVxuICAqL1xuICBhc3luYyBfcnVuTWV0aG9kKG1lc3NhZ2UsIHNvY2tldF9pZCwgbnMgPSBcIi9cIikge1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSAhPT0gXCJvYmplY3RcIiB8fCBtZXNzYWdlID09PSBudWxsKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCksXG4gICAgICAgIGlkOiBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLmpzb25ycGMgIT09IFwiMi4wXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwLCBcIkludmFsaWQgSlNPTiBSUEMgdmVyc2lvblwiKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAoIW1lc3NhZ2UubWV0aG9kKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMiwgXCJNZXRob2Qgbm90IHNwZWNpZmllZFwiKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UubWV0aG9kICE9PSBcInN0cmluZ1wiKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwMCwgXCJJbnZhbGlkIG1ldGhvZCBuYW1lXCIpLFxuICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICB9O1xuICAgIGlmIChtZXNzYWdlLnBhcmFtcyAmJiB0eXBlb2YgbWVzc2FnZS5wYXJhbXMgPT09IFwic3RyaW5nXCIpXG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAwKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICBpZiAobWVzc2FnZS5tZXRob2QgPT09IFwicnBjLm9uXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyZTMpLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICAgIGNvbnN0IGV2ZW50X25hbWVzID0gT2JqZWN0LmtleXModGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHMpO1xuICAgICAgZm9yIChjb25zdCBuYW1lIG9mIG1lc3NhZ2UucGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gZXZlbnRfbmFtZXMuaW5kZXhPZihuYW1lKTtcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gdGhpcy5uYW1lc3BhY2VzW25zXTtcbiAgICAgICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcInByb3ZpZGVkIGV2ZW50IGludmFsaWRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobmFtZXNwYWNlLmV2ZW50c1tldmVudF9uYW1lc1tpbmRleF1dLnByb3RlY3RlZCA9PT0gdHJ1ZSAmJiBuYW1lc3BhY2UuY2xpZW50cy5nZXQoc29ja2V0X2lkKVtcIl9hdXRoZW50aWNhdGVkXCJdID09PSBmYWxzZSkge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNiksXG4gICAgICAgICAgICBpZDogbWVzc2FnZS5pZCB8fCBudWxsXG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzb2NrZXRfaW5kZXggPSBuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0uc29ja2V0cy5pbmRleE9mKHNvY2tldF9pZCk7XG4gICAgICAgIGlmIChzb2NrZXRfaW5kZXggPj0gMCkge1xuICAgICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcInNvY2tldCBoYXMgYWxyZWFkeSBiZWVuIHN1YnNjcmliZWQgdG8gZXZlbnRcIjtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lc3BhY2UuZXZlbnRzW2V2ZW50X25hbWVzW2luZGV4XV0uc29ja2V0cy5wdXNoKHNvY2tldF9pZCk7XG4gICAgICAgIHJlc3VsdHNbbmFtZV0gPSBcIm9rXCI7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICByZXN1bHQ6IHJlc3VsdHMsXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfSBlbHNlIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMub2ZmXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZS5wYXJhbXMpXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyZTMpLFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgICAgfTtcbiAgICAgIGNvbnN0IHJlc3VsdHMgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBtZXNzYWdlLnBhcmFtcykge1xuICAgICAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdKSB7XG4gICAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwicHJvdmlkZWQgZXZlbnQgaW52YWxpZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGluZGV4ID0gdGhpcy5uYW1lc3BhY2VzW25zXS5ldmVudHNbbmFtZV0uc29ja2V0cy5pbmRleE9mKHNvY2tldF9pZCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICByZXN1bHRzW25hbWVdID0gXCJub3Qgc3Vic2NyaWJlZFwiO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubmFtZXNwYWNlc1tuc10uZXZlbnRzW25hbWVdLnNvY2tldHMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgcmVzdWx0c1tuYW1lXSA9IFwib2tcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgIHJlc3VsdDogcmVzdWx0cyxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKG1lc3NhZ2UubWV0aG9kID09PSBcInJwYy5sb2dpblwiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UucGFyYW1zKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNCksXG4gICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoIXRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbWVzc2FnZS5tZXRob2RdKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcjogY3JlYXRlRXJyb3IoLTMyNjAxKSxcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWQgfHwgbnVsbFxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICBpZiAodGhpcy5uYW1lc3BhY2VzW25zXS5ycGNfbWV0aG9kc1ttZXNzYWdlLm1ldGhvZF0ucHJvdGVjdGVkID09PSB0cnVlICYmIHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKVtcIl9hdXRoZW50aWNhdGVkXCJdID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAganNvbnJwYzogXCIyLjBcIixcbiAgICAgICAgZXJyb3I6IGNyZWF0ZUVycm9yKC0zMjYwNSksXG4gICAgICAgIGlkOiBtZXNzYWdlLmlkIHx8IG51bGxcbiAgICAgIH07XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXNwb25zZSA9IGF3YWl0IHRoaXMubmFtZXNwYWNlc1tuc10ucnBjX21ldGhvZHNbbWVzc2FnZS5tZXRob2RdLmZuKFxuICAgICAgICBtZXNzYWdlLnBhcmFtcyxcbiAgICAgICAgc29ja2V0X2lkXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICBpZiAoIW1lc3NhZ2UuaWQpIHJldHVybjtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCIsXG4gICAgICAgICAgZXJyb3I6IHtcbiAgICAgICAgICAgIGNvZGU6IC0zMmUzLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubmFtZSxcbiAgICAgICAgICAgIGRhdGE6IGVycm9yLm1lc3NhZ2VcbiAgICAgICAgICB9LFxuICAgICAgICAgIGlkOiBtZXNzYWdlLmlkXG4gICAgICAgIH07XG4gICAgICByZXR1cm4ge1xuICAgICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgICBlcnJvcixcbiAgICAgICAgaWQ6IG1lc3NhZ2UuaWRcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbWVzc2FnZS5pZCkgcmV0dXJuO1xuICAgIGlmIChtZXNzYWdlLm1ldGhvZCA9PT0gXCJycGMubG9naW5cIiAmJiByZXNwb25zZSA9PT0gdHJ1ZSkge1xuICAgICAgY29uc3QgcyA9IHRoaXMubmFtZXNwYWNlc1tuc10uY2xpZW50cy5nZXQoc29ja2V0X2lkKTtcbiAgICAgIHNbXCJfYXV0aGVudGljYXRlZFwiXSA9IHRydWU7XG4gICAgICB0aGlzLm5hbWVzcGFjZXNbbnNdLmNsaWVudHMuc2V0KHNvY2tldF9pZCwgcyk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBqc29ucnBjOiBcIjIuMFwiLFxuICAgICAgcmVzdWx0OiByZXNwb25zZSxcbiAgICAgIGlkOiBtZXNzYWdlLmlkXG4gICAgfTtcbiAgfVxuICAvKipcbiAgKiBHZW5lcmF0ZSBhIG5ldyBuYW1lc3BhY2Ugc3RvcmUuXG4gICogQWxzbyBwcmVyZWdpc3RlciBzb21lIHNwZWNpYWwgbmFtZXNwYWNlIG1ldGhvZHMuXG4gICogQHByaXZhdGVcbiAgKiBAcGFyYW0ge1N0cmluZ30gbmFtZSAtIG5hbWVzcGFjZXMgaWRlbnRpZmllclxuICAqIEByZXR1cm4ge3VuZGVmaW5lZH1cbiAgKi9cbiAgX2dlbmVyYXRlTmFtZXNwYWNlKG5hbWUpIHtcbiAgICB0aGlzLm5hbWVzcGFjZXNbbmFtZV0gPSB7XG4gICAgICBycGNfbWV0aG9kczoge1xuICAgICAgICBfX2xpc3RNZXRob2RzOiB7XG4gICAgICAgICAgZm46ICgpID0+IE9iamVjdC5rZXlzKHRoaXMubmFtZXNwYWNlc1tuYW1lXS5ycGNfbWV0aG9kcyksXG4gICAgICAgICAgcHJvdGVjdGVkOiBmYWxzZVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgY2xpZW50czogLyogQF9fUFVSRV9fICovIG5ldyBNYXAoKSxcbiAgICAgIGV2ZW50czoge31cbiAgICB9O1xuICB9XG59O1xudmFyIFJQQ19FUlJPUlMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcChbXG4gIFstMzJlMywgXCJFdmVudCBub3QgcHJvdmlkZWRcIl0sXG4gIFstMzI2MDAsIFwiSW52YWxpZCBSZXF1ZXN0XCJdLFxuICBbLTMyNjAxLCBcIk1ldGhvZCBub3QgZm91bmRcIl0sXG4gIFstMzI2MDIsIFwiSW52YWxpZCBwYXJhbXNcIl0sXG4gIFstMzI2MDMsIFwiSW50ZXJuYWwgZXJyb3JcIl0sXG4gIFstMzI2MDQsIFwiUGFyYW1zIG5vdCBmb3VuZFwiXSxcbiAgWy0zMjYwNSwgXCJNZXRob2QgZm9yYmlkZGVuXCJdLFxuICBbLTMyNjA2LCBcIkV2ZW50IGZvcmJpZGRlblwiXSxcbiAgWy0zMjcwMCwgXCJQYXJzZSBlcnJvclwiXVxuXSk7XG5mdW5jdGlvbiBjcmVhdGVFcnJvcihjb2RlLCBkZXRhaWxzKSB7XG4gIGNvbnN0IGVycm9yID0ge1xuICAgIGNvZGUsXG4gICAgbWVzc2FnZTogUlBDX0VSUk9SUy5nZXQoY29kZSkgfHwgXCJJbnRlcm5hbCBTZXJ2ZXIgRXJyb3JcIlxuICB9O1xuICBpZiAoZGV0YWlscykgZXJyb3JbXCJkYXRhXCJdID0gZGV0YWlscztcbiAgcmV0dXJuIGVycm9yO1xufVxuXG4vLyBzcmMvaW5kZXgudHNcbnZhciBDbGllbnQgPSBjbGFzcyBleHRlbmRzIENvbW1vbkNsaWVudCB7XG4gIGNvbnN0cnVjdG9yKGFkZHJlc3MgPSBcIndzOi8vbG9jYWxob3N0OjgwODBcIiwge1xuICAgIGF1dG9jb25uZWN0ID0gdHJ1ZSxcbiAgICByZWNvbm5lY3QgPSB0cnVlLFxuICAgIHJlY29ubmVjdF9pbnRlcnZhbCA9IDFlMyxcbiAgICBtYXhfcmVjb25uZWN0cyA9IDUsXG4gICAgLi4ucmVzdF9vcHRpb25zXG4gIH0gPSB7fSwgZ2VuZXJhdGVfcmVxdWVzdF9pZCkge1xuICAgIHN1cGVyKFxuICAgICAgV2ViU29ja2V0LFxuICAgICAgYWRkcmVzcyxcbiAgICAgIHtcbiAgICAgICAgYXV0b2Nvbm5lY3QsXG4gICAgICAgIHJlY29ubmVjdCxcbiAgICAgICAgcmVjb25uZWN0X2ludGVydmFsLFxuICAgICAgICBtYXhfcmVjb25uZWN0cyxcbiAgICAgICAgLi4ucmVzdF9vcHRpb25zXG4gICAgICB9LFxuICAgICAgZ2VuZXJhdGVfcmVxdWVzdF9pZFxuICAgICk7XG4gIH1cbn07XG5cbmV4cG9ydCB7IENsaWVudCwgQ29tbW9uQ2xpZW50LCBEZWZhdWx0RGF0YVBhY2ssIFNlcnZlciwgV2ViU29ja2V0LCBjcmVhdGVFcnJvciB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJXZWJTb2NrZXRJbXBsIiwiV2ViU29ja2V0U2VydmVyIiwiRXZlbnRFbWl0dGVyIiwidXJsIiwidjEiLCJXZWJTb2NrZXQiLCJhZGRyZXNzIiwib3B0aW9ucyIsIkRlZmF1bHREYXRhUGFjayIsImVuY29kZSIsInZhbHVlIiwiSlNPTiIsInN0cmluZ2lmeSIsImRlY29kZSIsInBhcnNlIiwiQ29tbW9uQ2xpZW50IiwiY29uc3RydWN0b3IiLCJ3ZWJTb2NrZXRGYWN0b3J5IiwiYXV0b2Nvbm5lY3QiLCJyZWNvbm5lY3QiLCJyZWNvbm5lY3RfaW50ZXJ2YWwiLCJtYXhfcmVjb25uZWN0cyIsInJlc3Rfb3B0aW9ucyIsImdlbmVyYXRlX3JlcXVlc3RfaWQiLCJkYXRhUGFjayIsInF1ZXVlIiwicnBjX2lkIiwicmVhZHkiLCJyZWNvbm5lY3RfdGltZXJfaWQiLCJjdXJyZW50X3JlY29ubmVjdHMiLCJOdW1iZXIiLCJfY29ubmVjdCIsImNvbm5lY3QiLCJzb2NrZXQiLCJjYWxsIiwibWV0aG9kIiwicGFyYW1zIiwidGltZW91dCIsIndzX29wdHMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsIkVycm9yIiwibWVzc2FnZSIsImpzb25ycGMiLCJpZCIsInNlbmQiLCJlcnJvciIsInByb21pc2UiLCJzZXRUaW1lb3V0IiwibG9naW4iLCJyZXNwIiwibGlzdE1ldGhvZHMiLCJub3RpZnkiLCJzdWJzY3JpYmUiLCJldmVudCIsInJlc3VsdCIsInVuc3Vic2NyaWJlIiwiY2xvc2UiLCJjb2RlIiwiZGF0YSIsInNldEF1dG9SZWNvbm5lY3QiLCJzZXRSZWNvbm5lY3RJbnRlcnZhbCIsImludGVydmFsIiwic2V0TWF4UmVjb25uZWN0cyIsImdldEN1cnJlbnRSZWNvbm5lY3RzIiwiZ2V0TWF4UmVjb25uZWN0cyIsImlzUmVjb25uZWN0aW5nIiwid2lsbFJlY29ubmVjdCIsImNsZWFyVGltZW91dCIsImFkZEV2ZW50TGlzdGVuZXIiLCJlbWl0IiwiQXJyYXlCdWZmZXIiLCJCdWZmZXIiLCJmcm9tIiwidG9TdHJpbmciLCJub3RpZmljYXRpb24iLCJsaXN0ZW5lcnMiLCJsZW5ndGgiLCJPYmplY3QiLCJrZXlzIiwiYXJncyIsInB1c2giLCJpIiwidGhlbiIsImFwcGx5IiwicmVhc29uIiwiU2VydmVyIiwibmFtZXNwYWNlcyIsIndzcyIsIm9uIiwicmVxdWVzdCIsInUiLCJucyIsInBhdGhuYW1lIiwicXVlcnkiLCJzb2NrZXRfaWQiLCJfaWQiLCJjbGllbnRzIiwiZGVsZXRlIiwiZXZlbnRzIiwiaW5kZXgiLCJzb2NrZXRzIiwiaW5kZXhPZiIsInNwbGljZSIsIl9nZW5lcmF0ZU5hbWVzcGFjZSIsInNldCIsIl9oYW5kbGVSUEMiLCJyZWdpc3RlciIsIm5hbWUiLCJmbiIsInJwY19tZXRob2RzIiwicHJvdGVjdGVkIiwiX21ha2VQcm90ZWN0ZWRNZXRob2QiLCJwdWJsaWMiLCJfbWFrZVB1YmxpY01ldGhvZCIsInNldEF1dGgiLCJfbWFrZVByb3RlY3RlZEV2ZW50IiwiX21ha2VQdWJsaWNFdmVudCIsImNsb3NlTmFtZXNwYWNlIiwibmFtZXNwYWNlIiwidmFsdWVzIiwiZ2V0Iiwib2YiLCJzZWxmIiwiZm5fbmFtZSIsImFyZ3VtZW50cyIsImV2X25hbWUiLCJldmVudExpc3QiLCJuc0V2ZW50IiwiY29ubmVjdGVkIiwic29ja2V0X2lkcyIsInJlZHVjZSIsImFjYyIsImN1cnIiLCJjcmVhdGVFcnJvciIsIm1zZ19vcHRpb25zIiwiYmluYXJ5IiwicmVhZHlTdGF0ZSIsInBhcnNlZERhdGEiLCJBcnJheSIsImlzQXJyYXkiLCJyZXNwb25zZXMiLCJyZXNwb25zZTIiLCJfcnVuTWV0aG9kIiwicmVzcG9uc2UiLCJyZXN1bHRzIiwiZXZlbnRfbmFtZXMiLCJzb2NrZXRfaW5kZXgiLCJzIiwiX19saXN0TWV0aG9kcyIsIk1hcCIsIlJQQ19FUlJPUlMiLCJkZXRhaWxzIiwiQ2xpZW50Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs":
/*!**************************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs ***!
  \**************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EventEmitter: () => (/* reexport default export from named module */ _index_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.js */ \"(rsc)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_index_js__WEBPACK_IMPORTED_MODULE_0__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL2V2ZW50ZW1pdHRlcjMvaW5kZXgubWpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFxQztBQUVkO0FBQ3ZCLGlFQUFlQSxzQ0FBWUEsRUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL3RlcnJhZm9ybWF0aW9uLy4vbm9kZV9tb2R1bGVzL3JwYy13ZWJzb2NrZXRzL25vZGVfbW9kdWxlcy9ldmVudGVtaXR0ZXIzL2luZGV4Lm1qcz9iMzI3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBFdmVudEVtaXR0ZXIgZnJvbSAnLi9pbmRleC5qcydcblxuZXhwb3J0IHsgRXZlbnRFbWl0dGVyIH1cbmV4cG9ydCBkZWZhdWx0IEV2ZW50RW1pdHRlclxuIl0sIm5hbWVzIjpbIkV2ZW50RW1pdHRlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/eventemitter3/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/rpc-websockets/node_modules/ws/wrapper.mjs":
/*!*****************************************************************!*\
  !*** ./node_modules/rpc-websockets/node_modules/ws/wrapper.mjs ***!
  \*****************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Receiver: () => (/* reexport default export from named module */ _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__),\n/* harmony export */   Sender: () => (/* reexport default export from named module */ _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__),\n/* harmony export */   WebSocket: () => (/* reexport default export from named module */ _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__),\n/* harmony export */   WebSocketServer: () => (/* reexport default export from named module */ _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__),\n/* harmony export */   createWebSocketStream: () => (/* reexport default export from named module */ _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_stream_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/stream.js */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/stream.js\");\n/* harmony import */ var _lib_receiver_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./lib/receiver.js */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/receiver.js\");\n/* harmony import */ var _lib_sender_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib/sender.js */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/sender.js\");\n/* harmony import */ var _lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./lib/websocket.js */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket.js\");\n/* harmony import */ var _lib_websocket_server_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./lib/websocket-server.js */ \"(rsc)/./node_modules/rpc-websockets/node_modules/ws/lib/websocket-server.js\");\n\n\n\n\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_websocket_js__WEBPACK_IMPORTED_MODULE_3__);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL3dyYXBwZXIubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQW9EO0FBQ1g7QUFDSjtBQUNNO0FBQ2E7QUFFdUI7QUFDL0UsaUVBQWVHLDhDQUFTQSxFQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdGVycmFmb3JtYXRpb24vLi9ub2RlX21vZHVsZXMvcnBjLXdlYnNvY2tldHMvbm9kZV9tb2R1bGVzL3dzL3dyYXBwZXIubWpzPzY0NWMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IGNyZWF0ZVdlYlNvY2tldFN0cmVhbSBmcm9tICcuL2xpYi9zdHJlYW0uanMnO1xuaW1wb3J0IFJlY2VpdmVyIGZyb20gJy4vbGliL3JlY2VpdmVyLmpzJztcbmltcG9ydCBTZW5kZXIgZnJvbSAnLi9saWIvc2VuZGVyLmpzJztcbmltcG9ydCBXZWJTb2NrZXQgZnJvbSAnLi9saWIvd2Vic29ja2V0LmpzJztcbmltcG9ydCBXZWJTb2NrZXRTZXJ2ZXIgZnJvbSAnLi9saWIvd2Vic29ja2V0LXNlcnZlci5qcyc7XG5cbmV4cG9ydCB7IGNyZWF0ZVdlYlNvY2tldFN0cmVhbSwgUmVjZWl2ZXIsIFNlbmRlciwgV2ViU29ja2V0LCBXZWJTb2NrZXRTZXJ2ZXIgfTtcbmV4cG9ydCBkZWZhdWx0IFdlYlNvY2tldDtcbiJdLCJuYW1lcyI6WyJjcmVhdGVXZWJTb2NrZXRTdHJlYW0iLCJSZWNlaXZlciIsIlNlbmRlciIsIldlYlNvY2tldCIsIldlYlNvY2tldFNlcnZlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/rpc-websockets/node_modules/ws/wrapper.mjs\n");

/***/ })

};
;